var ko=typeof globalThis!=="undefined"?globalThis:typeof window!=="undefined"?window:typeof global!=="undefined"?global:typeof self!=="undefined"?self:{};function Ru(m){if(m.__esModule)return m;var t=m.default;if(typeof t=="function"){var a=function x(){if(this instanceof x){return Reflect.construct(t,arguments,this.constructor)}return t.apply(this,arguments)};a.prototype=t.prototype}else a={};Object.defineProperty(a,"__esModule",{value:true});Object.keys(m).forEach(function(x){var q=Object.getOwnPropertyDescriptor(m,x);Object.defineProperty(a,x,q.get?q:{enumerable:true,get:function(){return m[x]}})});return a}var Ai={exports:{}};var Vu={};var zu=Object.freeze({__proto__:null,default:Vu});var Ia=Ru(zu);/*! For license information please see index.js.LICENSE.txt */(function(m,t){!function(a,x){m.exports=x()}(ko,function(){return(()=>{var a={5528:(b,u,e)=>{e.r(u),e.d(u,{MathBackendCPU:()=>w,shared:()=>g,version_cpu:()=>Or});var g={};e.r(g),e.d(g,{addImpl:()=>ie,bincountImpl:()=>Q,bincountReduceImpl:()=>oe,ceilImpl:()=>De,concatImpl:()=>Ke,equalImpl:()=>Ye,expImpl:()=>tt,expm1Impl:()=>Ct,floorImpl:()=>Ht,gatherNdImpl:()=>Ut,gatherV2Impl:()=>Wt,greaterEqualImpl:()=>be,greaterImpl:()=>Be,lessEqualImpl:()=>Ft,lessImpl:()=>yt,linSpaceImpl:()=>an,logImpl:()=>gn,maxImpl:()=>jt,maximumImpl:()=>Nn,minimumImpl:()=>vn,multiplyImpl:()=>Mn,negImpl:()=>ir,notEqualImpl:()=>hs,prodImpl:()=>Os,rangeImpl:()=>Kr,rsqrtImpl:()=>Xr,sigmoidImpl:()=>oa,simpleAbsImpl:()=>k,sliceImpl:()=>fs,sparseFillEmptyRowsImpl:()=>Ps,sparseReshapeImpl:()=>ms,sparseSegmentReductionImpl:()=>gr,sqrtImpl:()=>Dr,squaredDifferenceImpl:()=>Gn,stridedSliceImpl:()=>Jr,stringNGramsImpl:()=>Rs,stringSplitImpl:()=>zs,stringToHashBucketFastImpl:()=>gs,subImpl:()=>Fr,tileImpl:()=>ys,topKImpl:()=>bs,transposeImpl:()=>Gr,uniqueImpl:()=>ks});var n=e(5363);function h(S,A){Array.isArray(S)||(S=[S]),S.forEach(s=>{null!=s&&n.util.assert("complex64"!==s.dtype,()=>`${A} does not support complex64 tensors in the CPU backend.`)})}const i=n.kernel_impls.whereImpl;class w extends n.KernelBackend{constructor(){super(),this.blockSize=48,this.firstUse=true,this.data=new n.DataStorage(this,(0,n.engine)())}nextDataId(){return w.nextDataId++}write(A,s,N){this.firstUse&&(this.firstUse=false,(0,n.env)().get("IS_NODE")&&n.backend_util.warn("\n============================\nHi there ðŸ‘‹. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const r={id:this.nextDataId()};return this.data.set(r,{values:A,dtype:N,refCount:1}),r}makeTensorInfo(A,s,N){let r;if("string"===s&&null!=N&&N.length>0&&n.util.isString(N[0])){const v=N.map(C=>n.util.encodeString(C));r=this.write(v,A,s)}else r=this.write(N,A,s);return{dataId:r,shape:A,dtype:s}}refCount(A){if(this.data.has(A)){return this.data.get(A).refCount}return 0}incRef(A){this.data.get(A).refCount++}decRef(A){if(this.data.has(A)){this.data.get(A).refCount--}}move(A,s,N,r,v){this.data.set(A,{values:s,dtype:r,refCount:v})}numDataIds(){return this.data.numDataIds()}async read(A){return this.readSync(A)}readSync(A){const{dtype:s,complexTensorInfos:N}=this.data.get(A);if("complex64"===s){const r=this.readSync(N.real.dataId),v=this.readSync(N.imag.dataId);return n.backend_util.mergeRealAndImagArrays(r,v)}return this.data.get(A).values}bufferSync(A){const s=this.readSync(A.dataId);let N=s;if("string"===A.dtype)try{N=s.map(r=>n.util.decodeString(r))}catch(r){throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,n.buffer)(A.shape,A.dtype,N)}makeOutput(A,s,N){const r=this.write(A,s,N);return(0,n.engine)().makeTensorFromDataId(r,s,N,this)}disposeData(A,s=false){if(this.data.has(A)){if(this.data.get(A).refCount--,!s&&this.data.get(A).refCount>0)return false;const{complexTensorInfos:N}=this.data.get(A);null!=N&&(this.disposeData(N.real.dataId,true),this.disposeData(N.imag.dataId,true)),this.data.delete(A)}return true}disposeIntermediateTensorInfo(A){this.disposeData(A.dataId)}async time(A){const s=n.util.now();A();return{kernelMs:n.util.now()-s}}memory(){return{unreliable:true,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(A){h([A],"where");const s=this.readSync(A.dataId);return i(A.shape,s)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}function k(S){const A=new Float32Array(S.length);for(let s=0;s<S.length;++s)A[s]=Math.abs(S[s]);return A}w.nextDataId=0;const I={kernelName:n.Abs,backendName:"cpu",kernelFunc:S=>{const{x:A}=S.inputs,s=S.backend;h(A,"abs");let N=new Float32Array(n.util.sizeFromShape(A.shape));return N=k(s.data.get(A.dataId).values),s.makeOutput(N,A.shape,"float32")}};function T(S){return(A,s,N,r,v)=>{const C=n.backend_util.assertAndGetBroadcastShape(A,s),V=C.length,O=n.util.computeStrides(C),z=n.util.sizeFromShape(C),U=n.util.getTypedArrayFromDType(v,z),G=A.length,Z=s.length,ne=n.util.computeStrides(A),pe=n.util.computeStrides(s),fe=n.backend_util.getBroadcastDims(A,C),ae=n.backend_util.getBroadcastDims(s,C);if(fe.length+ae.length===0)for(let le=0;le<U.length;++le)U[le]=S(N[le%N.length],r[le%r.length]);else for(let le=0;le<U.length;++le){const _e=n.util.indexToLoc(le,V,O),Me=_e.slice(-G);fe.forEach(nt=>Me[nt]=0);const $e=n.util.locToIndex(Me,G,ne),Oe=_e.slice(-Z);ae.forEach(nt=>Oe[nt]=0);const Ge=n.util.locToIndex(Oe,Z,pe);U[le]=S(N[$e],r[Ge])}return[U,C]}}function c(S){const{inputs:A,backend:s}=S,{real:N,imag:r}=A,v=s.data.get(N.dataId).values,C=s.data.get(r.dataId).values,V=s.makeTensorInfo(N.shape,"complex64");return s.data.get(V.dataId).complexTensorInfos={real:s.makeTensorInfo(N.shape,"float32",v),imag:s.makeTensorInfo(r.shape,"float32",C)},V}const p={kernelName:n.Complex,backendName:"cpu",kernelFunc:c};function y(S,A,s="float32"){if("complex64"===s){return c({inputs:{real:y(S,A,"float32"),imag:y(S,A,"float32")},backend:S})}const N=n.util.makeZerosTypedArray(n.util.sizeFromShape(A),s);return S.makeTensorInfo(A,s,N)}function W(S){const{inputs:A,backend:s}=S,{x:N}=A;return s.incRef(N.dataId),{dataId:N.dataId,shape:N.shape,dtype:N.dtype}}const L={kernelName:n.Identity,backendName:"cpu",kernelFunc:W};function R(S){const{inputs:A,backend:s}=S,{input:N}=A,r=s.data.get(N.dataId).complexTensorInfos.real,v=s.data.get(r.dataId).values;return s.makeTensorInfo(r.shape,r.dtype,v)}const K={kernelName:n.Real,backendName:"cpu",kernelFunc:R};function re(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{dtype:v}=N;if("complex64"===v){if("complex64"===r.dtype)return W({inputs:{x:r},backend:s});const C=y(s,r.shape,r.dtype),V=re({inputs:{x:r},backend:s,attrs:{dtype:"float32"}}),O=c({inputs:{real:V,imag:C},backend:s});return s.disposeIntermediateTensorInfo(C),s.disposeIntermediateTensorInfo(V),O}if("complex64"===r.dtype){const C=R({inputs:{input:r},backend:s}),V=re({inputs:{x:C},backend:s,attrs:{dtype:v}});return s.disposeIntermediateTensorInfo(C),V}if(!n.util.hasEncodingLoss(r.dtype,v)){const C=W({inputs:{x:r},backend:s});return{dataId:C.dataId,shape:C.shape,dtype:v}}if("int32"===v){const C=s.data.get(r.dataId).values,V=Int32Array.from(C);return s.makeTensorInfo(r.shape,"int32",V)}if("bool"===v){const C=s.data.get(r.dataId).values,V=n.util.toTypedArray([0],r.dtype),[O,z]=T((U,G)=>U!==G?1:0)(r.shape,[],C,V,"bool");return s.makeTensorInfo(z,"bool",O)}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${v}`)}const J={kernelName:n.Cast,backendName:"cpu",kernelFunc:re};function ve(S,A,s,N){return null==s?({inputs:r,backend:v})=>{const{a:C,b:V}=r,O=v;h([C,V],S);const z=O.data.get(C.dataId).values,U=O.data.get(V.dataId).values,G="string"===C.dtype?n.backend_util.fromUint8ToStringArray(z):z,Z="string"===C.dtype?n.backend_util.fromUint8ToStringArray(U):U,ne=N||C.dtype,[pe,fe]=A(C.shape,V.shape,G,Z,ne);return O.makeTensorInfo(fe,ne,pe)}:({inputs:r,backend:v})=>{const{a:C,b:V}=r,O=v;if("complex64"===C.dtype||"complex64"===V.dtype){const z=re({inputs:{x:C},backend:O,attrs:{dtype:"complex64"}}),U=O.data.get(z.dataId),G=U.complexTensorInfos.real,Z=U.complexTensorInfos.imag,ne=O.data.get(G.dataId).values,pe=O.data.get(Z.dataId).values,fe=re({inputs:{x:V},backend:O,attrs:{dtype:"complex64"}}),ae=O.data.get(fe.dataId),le=ae.complexTensorInfos.real,_e=ae.complexTensorInfos.imag,Me=O.data.get(le.dataId).values,$e=O.data.get(_e.dataId).values,[Oe,Ge,nt]=s(C.shape,V.shape,ne,pe,Me,$e),Xe=O.makeTensorInfo(nt,"float32",Oe),ct=O.makeTensorInfo(nt,"float32",Ge),lt=c({inputs:{real:Xe,imag:ct},backend:O});return O.disposeIntermediateTensorInfo(z),O.disposeIntermediateTensorInfo(fe),O.disposeIntermediateTensorInfo(Xe),O.disposeIntermediateTensorInfo(ct),lt}{const z=O.data.get(C.dataId).values,U=O.data.get(V.dataId).values,G=N||C.dtype,[Z,ne]=A(C.shape,V.shape,z,U,G);return O.makeTensorInfo(ne,G,Z)}}}function ue(S){return(A,s,N,r,v,C)=>{const V=n.backend_util.assertAndGetBroadcastShape(A,s),O=n.util.sizeFromShape(V),z=V.length,U=n.util.computeStrides(V),G=n.util.getTypedArrayFromDType("float32",O),Z=n.util.getTypedArrayFromDType("float32",O),ne=n.backend_util.getBroadcastDims(A,V),pe=n.backend_util.getBroadcastDims(s,V),fe=n.backend_util.mergeRealAndImagArrays(N,r),ae=n.backend_util.mergeRealAndImagArrays(v,C),le=A.length,_e=n.util.computeStrides(A),Me=s.length,$e=n.util.computeStrides(s);if(ne.length+pe.length===0)for(let Oe=0;Oe<G.length;Oe++){const Ge=Oe%fe.length,nt=Oe%ae.length,Xe=S(fe[2*Ge],fe[2*Ge+1],ae[2*nt],ae[2*nt+1]);G[Oe]=Xe.real,Z[Oe]=Xe.imag}else for(let Oe=0;Oe<G.length;Oe++){const Ge=n.util.indexToLoc(Oe,z,U),nt=Ge.slice(-le);ne.forEach(at=>nt[at]=0);const Xe=n.util.locToIndex(nt,le,_e),ct=Ge.slice(-Me);pe.forEach(at=>ct[at]=0);const lt=n.util.locToIndex(ct,Me,$e),st=S(fe[2*Xe],fe[2*Xe+1],ae[2*lt],ae[2*lt+1]);G[Oe]=st.real,Z[Oe]=st.imag}return[G,Z,V]}}const ie=T((S,A)=>S+A),F=ue((S,A,s,N)=>({real:S+s,imag:A+N})),P=ve(n.Add,ie,F),f={kernelName:n.Add,backendName:"cpu",kernelFunc:P};function Q(S,A,s,N,r){const v=n.util.sizeFromShape(N),C=n.util.makeZerosTypedArray(r,s);for(let V=0;V<S.length;V++){const O=S[V];if(O<0)throw new Error("Input x must be non-negative!");O>=r||(C[O]+=v>0?A[V]:1)}return C}function oe(S,A,s,N=false){const r=S.shape[0],v=S.shape[1],C=(0,n.buffer)([r,s],A.dtype);for(let V=0;V<r;V++)for(let O=0;O<v;O++){const z=S.get(V,O);if(z<0)throw new Error("Input x must be non-negative!");z>=s||(N?C.set(1,V,z):A.size>0?C.set(C.get(V,z)+A.get(V,O),V,z):C.set(C.get(V,z)+1,V,z))}return C}function se(S){return(A,s,N)=>{const r=n.util.getTypedArrayFromDType(s,A.length);for(let v=0;v<A.length;++v)r[v]=S(A[v],N);return r}}function o(S,A,s){return({inputs:N,attrs:r,backend:v})=>{const{x:C}=N;if(h(C,S),"string"===C.dtype||"string"===s)throw new Error("unaryKernelFunc does not support string input/output");const V=v,O=V.data.get(C.dataId).values,z=n.util.sizeFromShape(C.shape),U=s||C.dtype,G=n.util.getArrayFromDType(U,z);for(let Z=0;Z<z;++Z)G[Z]=A(O[Z],r);return V.makeTensorInfo(C.shape,U,G)}}function te(S,A,s){return({inputs:N,attrs:r,backend:v})=>{const{x:C}=N;if(h(C,S),"string"===C.dtype||"string"===s)throw new Error("unaryKernelFunc does not support string input/output");const V=v,O=V.data.get(C.dataId).values,z=C.dtype,U=A(O,z,r);return V.makeTensorInfo(C.shape,z,U)}}const De=se(S=>Math.ceil(S)),Ve=te(n.Ceil,De),ze={kernelName:n.Ceil,backendName:"cpu",kernelFunc:Ve};function Ke(S,A,s,N){const r=n.util.getArrayFromDType(s,n.util.sizeFromShape(A));if(N&&"string"!==s){let v=0;S.forEach(C=>{const V=n.util.sizeFromShape(C.shape);r.set(C.vals,v),v+=V})}else{let v=0;S.forEach(C=>{const V="string"===s?n.backend_util.fromUint8ToStringArray(C.vals):C.vals;let O=0;for(let z=0;z<C.shape[0];++z){const U=z*A[1]+v;for(let G=0;G<C.shape[1];++G)r[U+G]=V[O++]}v+=C.shape[1]})}return r}const Ye=T((S,A)=>S===A?1:0),rt=ve(n.Equal,Ye,null,"bool"),Qe={kernelName:n.Equal,backendName:"cpu",kernelFunc:rt},tt=se(S=>Math.exp(S)),Nt=te(n.Exp,tt),$t={kernelName:n.Exp,backendName:"cpu",kernelFunc:Nt},Ct=se(S=>Math.expm1(S)),Ot=te(n.Expm1,Ct),zt={kernelName:n.Expm1,backendName:"cpu",kernelFunc:Ot},Ht=se(S=>Math.floor(S)),tn=te(n.Floor,Ht),qt={kernelName:n.Floor,backendName:"cpu",kernelFunc:tn};function Ut(S,A,s,N,r,v,C,V,O){const z=(0,n.buffer)([N,v],s);for(let U=0;U<N;U++){const G=[];let Z=0;for(let ne=0;ne<r;ne++){const pe=S[U*r+ne];Z+=pe*C[ne],G.push(pe)}if(Z<0||Z>=O/v)throw new Error(`Invalid indices: ${G} does not index into ${V}`);for(let ne=0;ne<v;ne++)z.values[U*v+ne]=A.get(...A.indexToLoc(Z*v+ne))}return z}function Wt(S,A,s){const N=(0,n.buffer)(s,S.dtype);for(let r=0;r<N.size;++r){const v=N.indexToLoc(r).slice(),C=v[0],V=v[2],O=A.locToIndex([C,V]);v[2]=A.values[O];const z=S.locToIndex(v);N.values[r]=S.values[z]}return N}const Be=T((S,A)=>S>A?1:0),Fe=ve(n.Greater,Be,null,"bool"),Y={kernelName:n.Greater,backendName:"cpu",kernelFunc:Fe},be=T((S,A)=>S>=A?1:0),ke=ve(n.GreaterEqual,be,null,"bool"),We={kernelName:n.GreaterEqual,backendName:"cpu",kernelFunc:ke},yt=T((S,A)=>S<A?1:0),_t=ve(n.Less,yt,null,"bool"),dt={kernelName:n.Less,backendName:"cpu",kernelFunc:_t},Ft=T((S,A)=>S<=A?1:0),Yt=ve(n.LessEqual,Ft,null,"bool"),fn={kernelName:n.LessEqual,backendName:"cpu",kernelFunc:Yt};function an(S,A,s){const N=(A-S)/(s-1),r=n.util.makeZerosTypedArray(s,"float32");r[0]=S;for(let v=1;v<r.length;v++)r[v]=r[v-1]+N;return r}const gn=se(S=>Math.log(S)),Rt=te(n.Log,gn),Xt={kernelName:n.Log,backendName:"cpu",kernelFunc:Rt};function jt(S,A,s,N){const r=n.util.getTypedArrayFromDType(N,n.util.sizeFromShape(s));for(let v=0;v<r.length;++v){const C=v*A;let V=S[C];for(let O=0;O<A;++O){const z=S[C+O];(Number.isNaN(z)||z>V)&&(V=z)}r[v]=V}return r}const Nn=T((S,A)=>Math.max(S,A)),yn=ve(n.Maximum,Nn),An={kernelName:n.Maximum,backendName:"cpu",kernelFunc:yn},vn=T((S,A)=>Math.min(S,A)),Tn=ve(n.Minimum,vn),wn={kernelName:n.Minimum,backendName:"cpu",kernelFunc:Tn},Mn=T((S,A)=>S*A),fr=ue((S,A,s,N)=>({real:S*s-A*N,imag:S*N+A*s})),Jn=ve(n.Multiply,Mn,fr),Hr={kernelName:n.Multiply,backendName:"cpu",kernelFunc:Jn};function ir(S,A,s){const N=n.util.createScalarValue(-1,s);return Mn([],A,N,S,s)}const Ds={kernelName:n.Neg,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s}=S,{x:N}=A;h(N,"neg");const r=s.data.get(N.dataId).values,[v,C]=ir(r,N.shape,N.dtype);return s.makeTensorInfo(C,N.dtype,v)}},hs=T((S,A)=>S!==A?1:0),ur=ve(n.NotEqual,hs,null,"bool"),jr={kernelName:n.NotEqual,backendName:"cpu",kernelFunc:ur};function Gr(S,A,s,N,r){const v=A.length,C=n.util.sizeFromShape(A),V=n.util.computeStrides(A),O=n.util.computeStrides(r),z=n.util.getTypedArrayFromDType(s,n.util.sizeFromShape(r));for(let U=0;U<C;++U){const G=n.util.indexToLoc(U,v,V),Z=new Array(G.length);for(let ne=0;ne<Z.length;ne++)Z[ne]=G[N[ne]];z[n.util.locToIndex(Z,v,O)]=S[U]}return z}function $n(S){const{inputs:A,attrs:s,backend:N}=S,{x:r}=A,{perm:v}=s;h(r,"transpose");const C=r.shape.length,V=new Array(C);for(let z=0;z<V.length;z++)V[z]=r.shape[v[z]];const O=Gr(N.data.get(r.dataId).values,r.shape,r.dtype,v,V);return{dataId:N.write(O,V,r.dtype),shape:V,dtype:r.dtype}}const Fs={kernelName:n.Transpose,backendName:"cpu",kernelFunc:$n};function Os(S,A,s,N){const[r,v]=n.backend_util.computeOutAndReduceShapes(S,N),C=(0,n.upcastType)(A,"int32"),V=n.util.makeZerosTypedArray(n.util.sizeFromShape(r),C),O=n.util.sizeFromShape(v);for(let z=0;z<V.length;++z){const U=z*O;let G=1;for(let Z=0;Z<O;++Z)G*=s[U+Z];V[z]=G}return{outVals:V,outShape:r,outDtype:C}}const Bs={kernelName:n.Prod,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{axis:v,keepDims:C}=N;h(r,"prod");const V=r.shape.length,O=n.util.parseAxisParam(v,r.shape),z=n.backend_util.getAxesPermutation(O,V);let U=O,G=r;const Z=[];null!=z&&(G=$n({inputs:{x:r},backend:s,attrs:{perm:z}}),Z.push(G),U=n.backend_util.getInnerMostAxes(U.length,V));const ne=s.data.get(G.dataId).values,{outVals:pe,outShape:fe,outDtype:ae}=Os(G.shape,G.dtype,ne,U);let le=fe;return C&&(le=n.backend_util.expandShapeToKeepDim(fe,O)),Z.forEach(_e=>s.disposeIntermediateTensorInfo(_e)),s.makeTensorInfo(le,ae,pe)}};function Kr(S,A,s,N){if(S===A||S<A&&s<0||A<S&&s>1)return n.util.makeZerosTypedArray(0,N);const r=Math.abs(Math.ceil((A-S)/s)),v=n.util.makeZerosTypedArray(r,N);A<S&&1===s&&(s=-1),v[0]=S;for(let C=1;C<v.length;C++)v[C]=v[C-1]+s;return v}const Xr=se(S=>1/Math.sqrt(S)),Zr=te(n.Rsqrt,Xr),ps={kernelName:n.Rsqrt,backendName:"cpu",kernelFunc:Zr},oa=se(S=>1/(1+Math.exp(-S))),mr=o(n.Sigmoid,S=>1/(1+Math.exp(-S))),Ls={kernelName:n.Sigmoid,backendName:"cpu",kernelFunc:mr};function fs(S,A,s,N,r){const v=n.slice_util.isSliceContinous(N,A,s),C=n.util.sizeFromShape(s),V=n.util.computeStrides(N);if(v){const G=n.slice_util.computeFlatOffset(A,V);return"string"===r?S.slice(G,G+C):S.subarray(G,G+C)}const O="string"===r?n.backend_util.fromUint8ToStringArray(S):S,z=(0,n.buffer)(N,r,O),U=(0,n.buffer)(s,r);for(let G=0;G<U.size;++G){const Z=U.indexToLoc(G),ne=Z.map((pe,fe)=>pe+A[fe]);U.set(z.get(...ne),...Z)}return"string"===r?n.backend_util.fromStringArrayToUint8(U.values):U.values}function Dn(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{begin:v,size:C}=N;h(r,"slice");const[V,O]=n.slice_util.parseSliceParams(r,v,C);n.slice_util.assertParamsValid(r,V,O);const z=fs(s.data.get(r.dataId).values,V,O,r.shape,r.dtype);return s.makeTensorInfo(O,r.dtype,z)}const Sr={kernelName:n.Slice,backendName:"cpu",kernelFunc:Dn};function Ps(S,A,s,N,r,v,C){const V=A[0],O=v[0],z=new Array(O),U=new Array(V),G=A[1];if(0===O){if(0!==V)throw new Error(`Received SparseTensor with denseShape[0] = 0 but
         indices.shape[0] = ${V}`);return[n.util.getArrayFromDType(s,0),[0,G],n.util.getArrayFromDType(r,0),z,U]}let Z=true,ne=0;const pe=new Array(O).fill(0);for(let ae=0;ae<V;++ae){const le=S[ae*G];if(le<0)throw new Error(`indices(${ae}, 0) is invalid: ${le} < 0`);if(le>=O)throw new Error(`indices(${ae}, 0) is invalid: ${le} >= ${O}`);++pe[le],Z=Z&&le>=ne,ne=le}let fe=true;for(let ae=0;ae<O;++ae){const le=0===pe[ae];z[ae]=le,fe=fe&&!le,pe[ae]=Math.max(pe[ae],1),ae>0&&(pe[ae]+=pe[ae-1])}if(fe&&Z){const ae=S,le=N;for(let _e=0;_e<V;++_e)U[_e]=_e;return[ae,[V,G],le,z,U]}{const ae=pe[O-1],le=n.util.getArrayFromDType(s,ae*G),_e=n.util.getArrayFromDType(r,ae),Me=new Array(O).fill(0);for(let $e=0;$e<V;++$e){const Oe=S[$e*G],Ge=Me[Oe],nt=(0===Oe?0:pe[Oe-1])+Ge;Me[Oe]++;for(let Xe=0;Xe<G;++Xe)le[nt*G+Xe]=S[$e*G+Xe];_e[nt]=N[$e],U[$e]=nt}for(let $e=0;$e<O;++$e){if(0===Me[$e]){const Oe=0===$e?0:pe[$e-1];le[Oe*G+0]=$e;for(let Ge=1;Ge<G;++Ge)le[Oe*G+Ge]=0;_e[Oe]=C}}return[le,[ae,G],_e,z,U]}}function ms(S,A,s,N,r){const v=n.util.sizeFromShape(N),C=A[0],V=r.length,O=[];let z=1,U=-1;for(let ae=0;ae<V;++ae){const le=r[ae];if(-1===le){if(-1!==U)throw new Error(`only one output dimension may be -1, not both ${U} and ${ae}`);U=ae,O.push(1)}else{if(le<0)throw new Error(`size ${ae} must be non-negative, not ${le}`);z*=le,O.push(le)}}if(-1!==U){if(z<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const ae=Math.trunc(v/z);if(z*ae!==v)throw new Error(`Input to reshape is a SparseTensor with ${v}
          dense values, but the requested shape requires a multiple of ${z}. inputShape=${N} outputShape= ${O}`);O[U]=ae}const G=n.util.sizeFromShape(O);if(G!==v)throw new Error(`Input to reshape is a tensor with ${v} dense values, but the requested shape has ${G}. inputShape=${N} outputShape=${O}`);const Z=N.length,ne=[];if(Z>0){ne[Z-1]=1;for(let ae=Z-2;ae>=0;--ae)ne[ae]=ne[ae+1]*N[ae+1]}const pe=[];if(V>0){pe[V-1]=1;for(let ae=V-2;ae>=0;--ae)pe[ae]=pe[ae+1]*O[ae+1]}const fe=n.util.getArrayFromDType(s,C*V);for(let ae=0;ae<C;++ae){let le=0;for(let _e=0;_e<Z;++_e)le+=S[ae*Z+_e]*ne[_e];for(let _e=0;_e<V;++_e)fe[ae*V+_e]=Math.trunc(le/pe[_e]),le%=pe[_e]}return[fe,[C,V],O]}function gr(S,A,s,N,r,v=false,C=0){const V=N.length;if(V!==r.length)throw new Error("segmentIds and indices should have same size.");const O=[A[0],S.length/A[0]],z=O[1],U=V>0?r[V-1]+1:0;if(U<0)throw new Error("segment ids must be >= 0");const G=A.slice();G[0]=U;const Z=G.reduce((_e,Me)=>_e*Me,1),ne=n.util.getArrayFromDType(s,Z);if(0===V)return U>0&&ne.fill(C),[ne,G];if(U<=0)throw new Error("segment ids must be >= 0");let pe=0,fe=1,ae=0,le=r[pe];for(;;){let _e=0;if(fe<V){if(_e=r[fe],le===_e){++fe;continue}if(le>=_e)throw new Error("segment ids are not increasing")}if(le<0||le>=U)throw new Error(`Segment id ${le} out of range [0, ${U}), possibly because segmentIds input is not sorted.`);le>ae&&ne.fill(C,ae*z,le*z);for(let Me=pe;Me<fe;++Me){const $e=N[Me];if($e<0||$e>=O[0])throw new Error(`Bad: indices[${Me}] == ${N[Me]} out of range [0, ${O[0]})`);for(let Oe=0;Oe<z;Oe++)ne[le*z+Oe]+=S[$e*z+Oe]}if(v)for(let Me=0;Me<z;Me++)ne[le*z+Me]/=fe-pe;if(pe=fe,++fe,ae=le+1,le=_e,fe>V)break}return ae<U&&ne.fill(C,ae*z,U*z),[ne,G]}const Dr=se(S=>Math.sqrt(S)),sn=o(n.Sqrt,S=>Math.sqrt(S)),Ce={kernelName:n.Sqrt,backendName:"cpu",kernelFunc:sn},Gn=T((S,A)=>{const s=S-A;return s*s}),Qr=ve(n.SquaredDifference,Gn),yr={kernelName:n.SquaredDifference,backendName:"cpu",kernelFunc:Qr};function Jr(S,A,s,N){const r=(0,n.buffer)(S,A.dtype);for(let v=0;v<r.size;v++){const C=r.indexToLoc(v),V=new Array(C.length);for(let O=0;O<V.length;O++)V[O]=C[O]*s[O]+N[O];r.set(A.get(...V),...C)}return r}class ia{constructor(A,s,N,r,v,C){this.separator=n.util.encodeString(A),this.nGramWidths=s,this.leftPad=n.util.encodeString(N),this.rightPad=n.util.encodeString(r),this.padWidth=v,this.preserveShort=C}getPadWidth(A){return Math.min(this.padWidth<0?A-1:this.padWidth,A-1)}getNumNGrams(A,s){const N=this.getPadWidth(s);return Math.max(0,A+2*N-s+1)}createNGrams(A,s,N,r,v,C){for(let V=0;V<v;++V){const O=this.getPadWidth(C),z=Math.max(0,O-V),U=Math.max(0,O-(v-(V+1))),G=C-(z+U),Z=s+(z>0?0:V-O);let ne=0;ne+=z*this.leftPad.length;for(let le=0;le<G;++le)ne+=A[Z+le].length;ne+=U*this.rightPad.length;ne+=(z+U+G-1)*this.separator.length,N[r+V]=new Uint8Array(ne);const pe=N[r+V];let fe=0;const ae=le=>le.forEach(_e=>pe[fe++]=_e);for(let le=0;le<z;++le)ae(this.leftPad),ae(this.separator);for(let le=0;le<G-1;++le)ae(A[Z+le]),ae(this.separator);if(G>0){ae(A[Z+G-1]);for(let le=0;le<U;++le)ae(this.separator),ae(this.rightPad)}else{for(let le=0;le<U-1;++le)ae(this.rightPad),ae(this.separator);ae(this.rightPad)}}}compute(A,s){const N=A.length,r=s.length;if(r>0){let O=s[0];if(0!==O)throw new Error(`First split value must be 0, got ${O}`);for(let z=1;z<r;++z){let U=s[z]>=O;if(U=U&&s[z]<=N,!U)throw new Error(`Invalid split value ${s[z]}, must be in [${O}, ${N}]`);O=s[z]}if(O!==N)throw new Error(`Last split value must be data size. Expected ${N}, got ${O}`)}const v=r-1,C=n.util.getArrayFromDType("int32",r);if(0===N||0===r){const O=new Array(N);for(let z=0;z<=v;++z)C[z]=0;return[O,C]}C[0]=0;for(let O=1;O<=v;++O){const z=s[O]-s[O-1];let U=0;this.nGramWidths.forEach(G=>{U+=this.getNumNGrams(z,G)}),this.preserveShort&&z>0&&0===U&&(U=1),C[O]=C[O-1]+U}const V=new Array(C[v]);for(let O=0;O<v;++O){const z=s[O];let U=C[O];if(this.nGramWidths.forEach(G=>{const Z=s[O+1]-s[O],ne=this.getNumNGrams(Z,G);this.createNGrams(A,z,V,U,ne,G),U+=ne}),this.preserveShort&&U===C[O]){const G=s[O+1]-s[O];if(0===G)continue;const Z=G+2*this.padWidth,ne=1;this.createNGrams(A,z,V,U,ne,Z)}}return[V,C]}}function Rs(S,A,s,N,r,v,C,V){return new ia(s,N,r,v,C,V).compute(S,A)}function Vs(S,A,s,N){if(!S.length)return;if(0===A.length){for(let v=0;v<S.length;++v)N.push(S.subarray(v,v+1));return}if(1===A.length){const v=A[0];let C=S.indexOf(v);for(;-1!==C;){const V=S.subarray(0,C);s&&0===V.length||N.push(V),C=(S=S.subarray(C+1)).indexOf(v)}return void(s&&0===S.length||N.push(S))}let r=0;for(let v=0;v<S.length+1;v++)if(v===S.length||-1!==A.indexOf(S[v])){const C=S.subarray(r,v);s&&0===C.length||N.push(C),r=v+1}}function zs(S,A,s){const N=S.length,r=[];let v=0,C=0;const V=new Array(N);for(let Z=0;Z<N;++Z){const ne=r.length;Vs(S[Z],A,s,r);const pe=r.length-ne;V[Z]=pe,v+=pe,C=Math.max(C,pe)}const O=n.util.getArrayFromDType("int32",2*v),z=new Array(v),U=[N,C];let G=0;for(let Z=0;Z<N;++Z)for(let ne=0;ne<V[Z];++ne)O[2*G]=Z,O[2*G+1]=ne,z[G]=r[G],++G;return[O,z,U]}function gs(S,A){const s=n.util.getArrayFromDType("int32",S.length);for(let N=0;N<S.length;++N)s[N]=n.util.fingerPrint64(S[N]).modulo(A).getLowBitsUnsigned();return s}const Fr=T((S,A)=>S-A),Yr=ue((S,A,s,N)=>({real:S-s,imag:A-N})),Kn=ve(n.Sub,Fr,Yr),es={kernelName:n.Sub,backendName:"cpu",kernelFunc:Kn};function ys(S,A){const s=new Array(S.rank);for(let r=0;r<s.length;r++)s[r]=S.shape[r]*A[r];const N=(0,n.buffer)(s,S.dtype);for(let r=0;r<N.values.length;++r){const v=N.indexToLoc(r),C=new Array(S.rank);for(let O=0;O<C.length;O++)C[O]=v[O]%S.shape[O];const V=S.locToIndex(C);N.values[r]=S.values[V]}return N}const lr=(S,A)=>{const s=A.value-S.value;return 0===s?S.index-A.index:s};function ts(S,A,s=0,N=S.length-1){for(;N>s;){if(N-s>600){const V=N-s+1,O=A-s+1,z=Math.log(V),U=.5*Math.exp(2*z/3),G=.5*Math.sqrt(z*U*(V-U)/V)*Math.sign(O-V/2);ts(S,A,Math.max(s,Math.floor(A-O*U/V+G)),Math.min(N,Math.floor(A+(V-O)*U/V+G)))}const r=S[A];let v=s,C=N;for(n.util.swap(S,s,A),lr(S[N],r)>0&&n.util.swap(S,s,N);v<C;){for(n.util.swap(S,v,C),v++,C--;lr(S[v],r)<0;)v+=1;for(;lr(S[C],r)>0;)C-=1}0===lr(S[s],r)?n.util.swap(S,s,C):(C+=1,n.util.swap(S,C,N)),C<=A&&(s=C+1),A<=C&&(N=C-1)}}function bs(S,A,s,N,r){const v=A[A.length-1],[C,V]=[S.length/v,v],O=n.util.getTypedArrayFromDType(s,C*N),z=n.util.getTypedArrayFromDType("int32",C*N);for(let G=0;G<C;G++){const Z=G*V,ne=S.subarray(Z,Z+V);let pe=new Array(ne.length);ne.forEach((_e,Me)=>pe[Me]={value:_e,index:Me}),N<pe.length&&(ts(pe,N),pe=pe.slice(0,N)),r&&pe.sort(lr);const fe=G*N,ae=O.subarray(fe,fe+N),le=z.subarray(fe,fe+N);for(let _e=0;_e<N;_e++)ae[_e]=pe[_e].value,le[_e]=pe[_e].index}const U=A.slice();return U[U.length-1]=N,[(0,n.buffer)(U,s,O),(0,n.buffer)(U,"int32",z)]}function ks(S,A,s,N){const r=n.util.parseAxisParam(A,s)[0],v=[1,s[0],1];for(let pe=0;pe<r;pe++)v[0]*=s[pe];v[1]=s[r];for(let pe=r+1;pe<s.length;pe++)v[2]*=s[pe];const C={},V=new Int32Array(s[r]),O=new n.TensorBuffer(v,N,S),z=[],U=1===v[0]&&1===v[2];for(let pe=0;pe<s[r];pe++){let fe;if(U)fe=S[pe].toString();else{const ae=[];for(let le=0;le<v[0];le++)for(let _e=0;_e<v[2];_e++)ae.push(O.get(le,pe,_e));fe=ae.join(",")}if(void 0!==C[fe])V[pe]=C[fe];else{const ae=Object.keys(C).length;C[fe]=ae,V[pe]=ae,z.push(pe)}}const G=v.slice();G[1]=Object.keys(C).length;const Z=new n.TensorBuffer(G,N);z.forEach((pe,fe)=>{for(let ae=0;ae<v[0];ae++)for(let le=0;le<v[2];le++)Z.set(O.get(ae,pe,le),ae,fe,le)});const ne=s.slice();return ne[r]=G[1],{outputValues:Z.values,outputShape:ne,indices:V}}const Or="3.9.0";(0,n.registerBackend)("cpu",()=>new w,1);const ns=o(n.Elu,S=>S>=0?S:Math.exp(S)-1),Ws={kernelName:n.Elu,backendName:"cpu",kernelFunc:ns};function ws(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{alpha:v}=N;h([r],"leakyRelu");const C=n.util.sizeFromShape(r.shape),V=s.data.get(r.dataId).values,O=n.util.getTypedArrayFromDType("float32",C);for(let z=0;z<V.length;z++)O[z]=V[z]<0?v*V[z]:V[z];return s.makeTensorInfo(r.shape,"float32",O)}const Us={kernelName:n.LeakyRelu,backendName:"cpu",kernelFunc:ws},Un=T((S,A)=>S<0?A*S:S);function vs(S){const{inputs:A,backend:s}=S,{x:N,alpha:r}=A;h([N,r],"prelu");const v=s.data.get(N.dataId).values,C=s.data.get(r.dataId).values,[V,O]=Un(N.shape,r.shape,v,C,N.dtype);return s.makeTensorInfo(O,N.dtype,V)}const Br={kernelName:n.Prelu,backendName:"cpu",kernelFunc:vs},nr=o(n.Relu,S=>Math.max(0,S)),cr={kernelName:n.Relu,backendName:"cpu",kernelFunc:nr},Fn=o(n.Relu6,S=>Math.min(Math.max(0,S),6)),ua={kernelName:n.Relu6,backendName:"cpu",kernelFunc:Fn};function Tr(S,A,s,N,r){if("linear"===s)return W({inputs:{x:A},backend:S});if("relu"===s)return nr({inputs:{x:A},backend:S});if("elu"===s)return ns({inputs:{x:A},backend:S});if("relu6"===s)return Fn({inputs:{x:A},backend:S});if("prelu"===s)return vs({inputs:{x:A,alpha:N},backend:S});if("leakyrelu"===s)return ws({inputs:{x:A},backend:S,attrs:{alpha:r}});if("sigmoid"===s)return mr({inputs:{x:A},backend:S});throw new Error(`Activation ${s} has not been implemented for the CPU backend.`)}function cn(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{shape:v}=N,C=n.util.sizeFromShape(r.shape),V=n.util.inferFromImplicitShape(v,C),O=n.util.sizeFromShape(V);n.util.assert(C===O,()=>`The new shape (${V}) has ${O} elements and the old shape (${r.shape}) has ${C} elements. The new shape and old shape must have the same number of elements.`),s.incRef(r.dataId);const z=s.data.get(r.dataId);if(null!=z.complexTensorInfos){const U=z.complexTensorInfos.real,G=z.complexTensorInfos.imag;U.shape=V,G.shape=V}return{dataId:r.dataId,shape:V,dtype:r.dtype}}const rs={kernelName:n.Reshape,backendName:"cpu",kernelFunc:cn};function ss(S){const{inputs:A,backend:s,attrs:N}=S,{a:r,b:v}=A,{transposeA:C,transposeB:V}=N;h([r,v],"matMul");const O=r.shape.length,z=v.shape.length,U=C?r.shape[O-2]:r.shape[O-1],G=V?v.shape[z-1]:v.shape[z-2],Z=C?r.shape[O-1]:r.shape[O-2],ne=V?v.shape[z-2]:v.shape[z-1],pe=r.shape.slice(0,-2),fe=v.shape.slice(0,-2),ae=n.util.sizeFromShape(pe),le=n.util.sizeFromShape(fe),_e=ae===le||1===ae||1===le;n.util.assert(O>=2&&z>=2&&_e,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${pe}) and (${fe}).`);const Me=(ae>le?r.shape.slice(0,-2):v.shape.slice(0,-2)).concat([Z,ne]);n.util.assert(U===G,()=>`Error in matMul: inner shapes (${U}) and (${G}) of Tensors with shapes ${r.shape} and ${v.shape} and transposeA=${C} and transposeB=${V} must match.`);const $e=V?[le,ne,G]:[le,G,ne],Oe=cn({inputs:{x:r},backend:s,attrs:{shape:C?[ae,U,Z]:[ae,Z,U]}}),Ge=cn({inputs:{x:v},backend:s,attrs:{shape:$e}}),nt=C?Oe.shape[1]:Oe.shape[2],Xe=C?Oe.shape[2]:Oe.shape[1],ct=V?Ge.shape[1]:Ge.shape[2],lt=Math.max(ae,le),st=s.data.get(Oe.dataId).values,at=s.data.get(Ge.dataId).values,ot=n.util.computeStrides(Oe.shape),bt=n.util.computeStrides(Ge.shape),[vt,wt,mt]=C?[ot[0],1,ot[1]]:[ot[0],ot[1],1],[kt,gt,St]=V?[1,bt[1],bt[0]]:[bt[1],1,bt[0]],xt=Xe*ct,It=(0,n.buffer)([lt,Xe,ct],Oe.dtype),Et=It.values,Mt=s.blockSize;for(let Dt=0;Dt<lt;Dt++)for(let Lt=0;Lt<Xe;Lt+=Mt)for(let Pt=0;Pt<ct;Pt+=Mt)for(let Gt=0;Gt<nt;Gt+=Mt){const Jt=Math.min(Lt+Mt,Xe),nn=Math.min(Pt+Mt,ct),Kt=Math.min(Gt+Mt,nt);for(let pn=Lt;pn<Jt;pn++)for(let kn=Pt;kn<nn;kn++){let Cn=0;for(let hn=Gt;hn<Kt;hn++){const xn=Math.min(Dt,ae-1)*vt,_n=Math.min(Dt,le-1)*St;Cn+=st[xn+pn*wt+hn*mt]*at[hn*kt+kn*gt+_n]}Et[Dt*xt+(pn*ct+kn)]+=Cn}}return s.disposeIntermediateTensorInfo(Oe),s.disposeIntermediateTensorInfo(Ge),s.makeTensorInfo(Me,It.dtype,It.values)}const Lr={kernelName:n.BatchMatMul,backendName:"cpu",kernelFunc:ss};const la={kernelName:n._FusedMatMul,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{a:r,b:v,bias:C,preluActivationWeights:V}=A,{transposeA:O,transposeB:z,activation:U,leakyreluAlpha:G}=N;let Z,ne,pe;const fe=[];Z=ss({inputs:{a:r,b:v},attrs:{transposeA:O,transposeB:z},backend:s}),C&&(ne=P({inputs:{a:Z,b:C},backend:s}),fe.push(Z),Z=ne),U&&(pe=Tr(s,Z,U,V,G),fe.push(Z),Z=pe);for(const ae of fe)s.disposeIntermediateTensorInfo(ae);return Z}},ca=o(n.Acos,S=>Math.acos(S)),da={kernelName:n.Acos,backendName:"cpu",kernelFunc:ca},Ns=o(n.Acosh,S=>Math.acosh(S)),qs={kernelName:n.Acosh,backendName:"cpu",kernelFunc:Ns};const ha={kernelName:n.AddN,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s}=S,N=A;h(A,"addN");const r=N.map(V=>s.data.get(V.dataId).values),v=(0,n.buffer)(N[0].shape,N[0].dtype),C=v.values;for(let V=0;V<N.length;V++){const O=r[V];for(let z=0;z<C.length;z++)C[z]+=O[z]}return s.makeTensorInfo(v.shape,v.dtype,v.values)}};const Hs={kernelName:n.All,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{axis:v,keepDims:C}=N;h(r,"all");const V=n.util.parseAxisParam(v,r.shape);let O=V;const z=n.backend_util.getAxesPermutation(O,r.shape.length);let U=r;null!=z&&(U=$n({inputs:{x:r},backend:s,attrs:{perm:z}}),O=n.backend_util.getInnerMostAxes(O.length,r.shape.length)),n.backend_util.assertAxesAreInnerMostDims("all",O,U.shape.length);const[G,Z]=n.backend_util.computeOutAndReduceShapes(U.shape,O),ne=n.util.sizeFromShape(Z),pe=n.util.makeZerosTypedArray(n.util.sizeFromShape(G),U.dtype),fe=s.data.get(U.dataId).values;for(let le=0;le<pe.length;++le){const _e=le*ne;let Me=fe[_e];for(let $e=0;$e<ne;++$e){const Oe=fe[_e+$e];Me=Me&&Oe}pe[le]=Me}null!=z&&s.disposeIntermediateTensorInfo(U);const ae=s.makeTensorInfo(G,U.dtype,pe);if(C){const le=cn({inputs:{x:ae},backend:s,attrs:{shape:n.backend_util.expandShapeToKeepDim(G,V)}});return s.disposeIntermediateTensorInfo(ae),le}return ae}};const xs={kernelName:n.Any,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{axis:v,keepDims:C}=N;h(r,"any");const V=n.util.parseAxisParam(v,r.shape);let O=V;const z=n.backend_util.getAxesPermutation(O,r.shape.length);let U=r;null!=z&&(U=$n({inputs:{x:r},backend:s,attrs:{perm:z}}),O=n.backend_util.getInnerMostAxes(O.length,r.shape.length)),n.backend_util.assertAxesAreInnerMostDims("any",O,U.shape.length);const[G,Z]=n.backend_util.computeOutAndReduceShapes(U.shape,O),ne=n.util.sizeFromShape(Z),pe=n.util.makeZerosTypedArray(n.util.sizeFromShape(G),U.dtype),fe=s.data.get(U.dataId).values;for(let le=0;le<pe.length;++le){const _e=le*ne;let Me=fe[_e];for(let $e=0;$e<ne;++$e){const Oe=fe[_e+$e];Me=Me||Oe}pe[le]=Me}null!=z&&s.disposeIntermediateTensorInfo(U);const ae=s.makeTensorInfo(G,U.dtype,pe);if(C){const le=cn({inputs:{x:ae},backend:s,attrs:{shape:n.backend_util.expandShapeToKeepDim(G,V)}});return s.disposeIntermediateTensorInfo(ae),le}return ae}};const Bt={kernelName:n.ArgMax,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{axis:v}=N;h(r,"argMax");let C=n.util.parseAxisParam(v,r.shape);const V=n.backend_util.getAxesPermutation(C,r.shape.length);let O=r;const z=[];null!=V&&(O=$n({inputs:{x:r},backend:s,attrs:{perm:V}}),z.push(O),C=n.backend_util.getInnerMostAxes(C.length,O.shape.length)),C=[C[0]],n.backend_util.assertAxesAreInnerMostDims("argMax",C,O.shape.length);const[U,G]=n.backend_util.computeOutAndReduceShapes(O.shape,C),Z=n.util.sizeFromShape(U),ne=n.util.makeZerosTypedArray(Z,"int32"),pe=n.util.sizeFromShape(G),fe=s.data.get(O.dataId).values;for(let ae=0;ae<ne.length;++ae){const le=ae*pe;let _e=fe[le],Me=0;for(let $e=0;$e<pe;++$e){const Oe=fe[le+$e];Oe>_e&&(_e=Oe,Me=$e)}ne[ae]=Me}return z.forEach(ae=>s.disposeIntermediateTensorInfo(ae)),s.makeTensorInfo(U,"int32",ne)}};const on={kernelName:n.ArgMin,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{axis:v}=N;h(r,"argMin");let C=n.util.parseAxisParam(v,r.shape);const V=n.backend_util.getAxesPermutation(C,r.shape.length);let O=r;const z=[];null!=V&&(O=$n({inputs:{x:r},backend:s,attrs:{perm:V}}),z.push(O),C=n.backend_util.getInnerMostAxes(C.length,O.shape.length)),C=[C[0]],n.backend_util.assertAxesAreInnerMostDims("argMin",C,O.shape.length);const[U,G]=n.backend_util.computeOutAndReduceShapes(O.shape,C),Z=n.util.sizeFromShape(U),ne=n.util.makeZerosTypedArray(Z,"int32"),pe=n.util.sizeFromShape(G),fe=s.data.get(O.dataId).values;for(let ae=0;ae<ne.length;++ae){const le=ae*pe;let _e=fe[le],Me=0;for(let $e=0;$e<pe;++$e){const Oe=fe[le+$e];Oe<_e&&(_e=Oe,Me=$e)}ne[ae]=Me}return z.forEach(ae=>s.disposeIntermediateTensorInfo(ae)),s.makeTensorInfo(U,"int32",ne)}},Yn=o(n.Asin,S=>Math.asin(S)),Zt={kernelName:n.Asin,backendName:"cpu",kernelFunc:Yn},Ir=o(n.Asinh,S=>Math.asinh(S)),Xn={kernelName:n.Asinh,backendName:"cpu",kernelFunc:Ir},er=o(n.Atan,S=>Math.atan(S)),br={kernelName:n.Atan,backendName:"cpu",kernelFunc:er},kr=T((S,A)=>Math.atan2(S,A)),dr=ve(n.Atan2,kr),Pr={kernelName:n.Atan2,backendName:"cpu",kernelFunc:dr},Ln=o(n.Atanh,S=>Math.atanh(S)),un={kernelName:n.Atanh,backendName:"cpu",kernelFunc:Ln};function as(S,A,s,N,r,v){const C=r.strideHeight,V=r.strideWidth,O=r.dilationHeight,z=r.dilationWidth,U=r.effectiveFilterHeight,G=r.effectiveFilterWidth,Z=r.padInfo.top,ne=r.padInfo.left,pe="max"===v?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,fe=(0,n.buffer)(r.outShape,s),ae=fe.values,le=r.outShape[1]*r.outShape[2]*r.outShape[3],_e=r.outShape[2]*r.outShape[3],Me=r.outShape[3];for(let $e=0;$e<r.batchSize;++$e){const Oe=$e*le,Ge=$e*N[0];for(let nt=0;nt<r.inChannels;++nt)for(let Xe=0;Xe<r.outHeight;++Xe){const ct=Xe*C-Z,lt=Math.max(0,ct),st=Math.min(r.inHeight,U+ct),at=Oe+Xe*_e;for(let ot=0;ot<r.outWidth;++ot){const bt=ot*V-ne,vt=Math.max(0,bt),wt=Math.min(r.inWidth,G+bt);let mt=pe,kt=0,gt=0;for(let St=lt;St<st;St+=O){const xt=Ge+St*N[1];for(let It=vt;It<wt;It+=z){const Et=S[xt+It*N[2]+nt];"max"===v&&Et>mt?mt=Et:"avg"===v&&(kt+=Et,gt++)}if(isNaN(mt))break}ae[at+ot*Me+nt]="avg"===v?kt/gt:mt}}}return fe}function wr(S,A,s,N,r=false,v=false){const C=(0,n.buffer)(N.outShape,"int32"),V=N.strideHeight,O=N.strideWidth,z=N.dilationHeight,U=N.dilationWidth,G=N.effectiveFilterHeight,Z=N.effectiveFilterWidth,ne=N.padInfo.top,pe=N.padInfo.left,fe=(0,n.buffer)(A,s,S);for(let ae=0;ae<N.batchSize;++ae)for(let le=0;le<N.inChannels;++le)for(let _e=0;_e<N.outHeight;++_e){const Me=_e*V-ne;let $e=Me;for(;$e<0;)$e+=z;const Oe=Math.min(N.inHeight,G+Me);for(let Ge=0;Ge<N.outWidth;++Ge){const nt=Ge*O-pe;let Xe=nt;for(;Xe<0;)Xe+=U;const ct=Math.min(N.inWidth,Z+nt);let lt=Number.NEGATIVE_INFINITY,st=-1;for(let at=$e;at<Oe;at+=z){const ot=at-Me;for(let bt=Xe;bt<ct;bt+=U){const vt=bt-nt,wt=fe.get(ae,at,bt,le);wt>lt&&(lt=wt,st=r?v?((ae*N.inHeight+at)*N.inWidth+bt)*N.inChannels+le:(at*N.inWidth+bt)*N.inChannels+le:ot*Z+vt)}}C.set(st,ae,_e,Ge,le)}}return C}function vr(S,A,s,N,r,v){const C=r.strideDepth,V=r.strideHeight,O=r.strideWidth,z=r.dilationDepth,U=r.dilationHeight,G=r.dilationWidth,Z=r.effectiveFilterDepth,ne=r.effectiveFilterHeight,pe=r.effectiveFilterWidth,fe=r.padInfo.front,ae=r.padInfo.top,le=r.padInfo.left,_e="max"===v?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,Me=(0,n.buffer)(r.outShape,s),$e=Me.values,Oe=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],Ge=r.outShape[2]*r.outShape[3]*r.outShape[4],nt=r.outShape[3]*r.outShape[4],Xe=r.outShape[4];for(let ct=0;ct<r.batchSize;++ct){const lt=ct*Oe,st=ct*N[0];for(let at=0;at<r.inChannels;++at)for(let ot=0;ot<r.outDepth;++ot){const bt=ot*C-fe;let vt=bt;for(;vt<0;)vt+=z;const wt=Math.min(r.inDepth,Z+bt),mt=lt+ot*Ge;for(let kt=0;kt<r.outHeight;++kt){const gt=kt*V-ae;let St=gt;for(;St<0;)St+=U;const xt=Math.min(r.inHeight,ne+gt),It=mt+kt*nt;for(let Et=0;Et<r.outWidth;++Et){const Mt=Et*O-le;let Dt=Mt;for(;Dt<0;)Dt+=G;const Lt=Math.min(r.inWidth,pe+Mt),Pt=It+Et*Xe;let Gt=_e,Jt=0,nn=0;for(let Kt=vt;Kt<wt;Kt+=z){const pn=st+Kt*N[1];for(let kn=St;kn<xt;kn+=U){const Cn=pn+kn*N[2];for(let hn=Dt;hn<Lt;hn+=G){const xn=S[Cn+hn*N[3]+at];if("max"===v&&xn>Gt?Gt=xn:"avg"===v&&(Jt+=xn,nn++),isNaN(Gt))break}if(isNaN(Gt))break}if(isNaN(Gt))break}$e[Pt+at]="avg"===v?Jt/nn:Gt}}}}return Me}const pa={kernelName:n.AvgPool,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A;h(r,"avgPool");const{filterSize:v,strides:C,pad:V,dimRoundingMode:O}=N;n.util.assert(n.backend_util.eitherStridesOrDilationsAreOne(C,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${C} and dilations '1'`);const z=n.backend_util.computePool2DInfo(r.shape,v,C,1,V,O);let U;if(1===z.filterWidth&&1===z.filterHeight&&n.util.arraysEqual(z.inShape,z.outShape))U=W({inputs:{x:r},backend:s});else{const G=s.data.get(r.dataId).values,Z=n.util.computeStrides(r.shape),ne=as(G,r.shape,r.dtype,Z,z,"avg");U=s.makeTensorInfo(z.outShape,r.dtype,ne.values)}return U}};const js={kernelName:n.AvgPool3D,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{filterSize:v,strides:C,pad:V,dimRoundingMode:O,dataFormat:z}=N;h(r,"avgPool3d");const U=n.backend_util.computePool3DInfo(r.shape,v,C,1,V,O,z),G=vr(s.data.get(r.dataId).values,r.shape,r.dtype,n.util.computeStrides(r.shape),U,"avg");return s.makeTensorInfo(G.shape,"float32",G.values)}};const Rr={kernelName:n.AvgPool3DGrad,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{dy:r,input:v}=A,{filterSize:C,strides:V,pad:O,dimRoundingMode:z}=N;h([r,v],"avgPool3DGrad");const U=n.backend_util.computePool3DInfo(v.shape,C,V,1,O,z),G=U.strideDepth,Z=U.strideHeight,ne=U.strideWidth,pe=U.filterDepth,fe=U.filterHeight,ae=U.filterWidth,le=U.dilationDepth,_e=U.dilationHeight,Me=U.dilationWidth,$e=U.effectiveFilterDepth,Oe=U.effectiveFilterHeight,Ge=U.effectiveFilterWidth,nt=$e-1-U.padInfo.front,Xe=Ge-1-U.padInfo.left,ct=Oe-1-U.padInfo.top,lt=(0,n.buffer)(v.shape,"float32"),st=1/(pe*fe*ae),at=s.bufferSync(r);for(let ot=0;ot<U.batchSize;++ot)for(let bt=0;bt<U.inChannels;++bt)for(let vt=0;vt<U.inDepth;++vt)for(let wt=0;wt<U.inHeight;++wt)for(let mt=0;mt<U.inWidth;++mt){const kt=vt-nt,gt=wt-ct,St=mt-Xe;let xt=0;for(let It=0;It<$e;It+=le){const Et=(kt+It)/G;if(!(Et<0||Et>=U.outDepth||Math.floor(Et)!==Et))for(let Mt=0;Mt<Oe;Mt+=_e){const Dt=(gt+Mt)/Z;if(!(Dt<0||Dt>=U.outHeight||Math.floor(Dt)!==Dt))for(let Lt=0;Lt<Ge;Lt+=Me){const Pt=(St+Lt)/ne;if(Pt<0||Pt>=U.outWidth||Math.floor(Pt)!==Pt)continue;xt+=at.get(ot,Et,Dt,Pt,bt)}}}lt.set(xt*st,ot,vt,wt,mt,bt)}return s.makeTensorInfo(lt.shape,lt.dtype,lt.values)}};const hr={kernelName:n.AvgPoolGrad,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{dy:r,input:v}=A,C=v;h([r,v],"avgPoolGrad");const{filterSize:V,strides:O,pad:z}=N,U=n.backend_util.computePool2DInfo(C.shape,V,O,1,z),G=U.strideHeight,Z=U.strideWidth,ne=U.filterHeight,pe=U.filterWidth,fe=U.dilationHeight,ae=U.dilationWidth,le=U.effectiveFilterHeight,_e=U.effectiveFilterWidth,Me=_e-1-U.padInfo.left,$e=le-1-U.padInfo.top,Oe=(0,n.buffer)(C.shape,"float32"),Ge=1/(ne*pe),nt=s.data.get(r.dataId).values,Xe=(0,n.buffer)(r.shape,"float32",nt);for(let ct=0;ct<U.batchSize;++ct)for(let lt=0;lt<U.inChannels;++lt)for(let st=0;st<U.inHeight;++st)for(let at=0;at<U.inWidth;++at){const ot=st-$e,bt=at-Me;let vt=0;for(let wt=0;wt<le;wt+=fe){const mt=(ot+wt)/G;if(!(mt<0||mt>=U.outHeight||Math.floor(mt)!==mt))for(let kt=0;kt<_e;kt+=ae){const gt=(bt+kt)/Z;if(gt<0||gt>=U.outWidth||Math.floor(gt)!==gt)continue;vt+=Xe.get(ct,mt,gt,lt)}}Oe.set(vt*Ge,ct,st,at,lt)}return s.makeTensorInfo(Oe.shape,Oe.dtype,Oe.values)}};const os={kernelName:n.FusedBatchNorm,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r,scale:v,offset:C,mean:V,variance:O}=A;n.util.assert(V.shape.length===O.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),n.util.assert(null==C||V.shape.length===C.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),n.util.assert(null==v||V.shape.length===v.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),h([r,V,O,v,C],"batchNorm");let{varianceEpsilon:z}=N;null==z&&(z=.001);const U=s.data.get(r.dataId).values,G=s.data.get(V.dataId).values,Z=s.data.get(O.dataId).values,ne=v?s.data.get(v.dataId).values:new Float32Array([1]),pe=C?s.data.get(C.dataId).values:new Float32Array([0]),fe=new Float32Array(U.length),ae=pe.length,le=ne.length,_e=Z.length,Me=G.length;let $e=0,Oe=0,Ge=0,nt=0;for(let Xe=0;Xe<U.length;++Xe)fe[Xe]=pe[$e++]+(U[Xe]-G[Oe++])*ne[Ge++]/Math.sqrt(Z[nt++]+z),$e>=ae&&($e=0),Oe>=Me&&(Oe=0),Ge>=le&&(Ge=0),nt>=_e&&(nt=0);return s.makeTensorInfo(r.shape,r.dtype,fe)}};const is={kernelName:n.BatchToSpaceND,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{blockShape:v,crops:C}=N;h([r],"batchToSpaceND");const V=v.reduce((le,_e)=>le*_e),O=n.backend_util.getReshaped(r.shape,v,V),z=n.backend_util.getPermuted(O.length,v.length),U=n.backend_util.getReshapedPermuted(r.shape,v,V),G=n.backend_util.getSliceBeginCoords(C,v.length),Z=n.backend_util.getSliceSize(U,C,v.length),ne=cn({inputs:{x:r},backend:s,attrs:{shape:O}}),pe=$n({inputs:{x:ne},backend:s,attrs:{perm:z}}),fe=cn({inputs:{x:pe},backend:s,attrs:{shape:U}}),ae=Dn({inputs:{x:fe},backend:s,attrs:{begin:G,size:Z}});return s.disposeIntermediateTensorInfo(ne),s.disposeIntermediateTensorInfo(pe),s.disposeIntermediateTensorInfo(fe),ae}};const us={kernelName:n.Bincount,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r,weights:v}=A,{size:C}=N,V=Q(s.data.get(r.dataId).values,s.data.get(v.dataId).values,v.dtype,v.shape,C);return s.makeTensorInfo([C],v.dtype,V)}};const Ie={kernelName:n.BroadcastArgs,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s}=S,{s0:N,s1:r}=A,v=s.data.get(N.dataId).values,C=s.data.get(r.dataId).values,V=n.backend_util.assertAndGetBroadcastShape(Array.from(v),Array.from(C));return s.makeTensorInfo([V.length],"int32",Int32Array.from(V))}},Gs=o(n.ClipByValue,(S,A)=>{const s=A;return S>s.clipValueMax?s.clipValueMax:S<s.clipValueMin?s.clipValueMin:S}),Er={kernelName:n.ClipByValue,backendName:"cpu",kernelFunc:Gs},Ca={kernelName:n.ComplexAbs,backendName:"cpu",kernelFunc:S=>{const{x:A}=S.inputs,s=S.backend,N=new Float32Array(n.util.sizeFromShape(A.shape)),r=s.data.get(A.dataId),v=r.complexTensorInfos.real,C=r.complexTensorInfos.imag,V=s.data.get(v.dataId).values,O=s.data.get(C.dataId).values;for(let z=0;z<V.length;z++){const U=V[z],G=O[z];N[z]=Math.hypot(U,G)}return s.makeOutput(N,A.shape,"float32")}};function Ar(S){const{inputs:A,backend:s}=S,{input:N}=A,r=s.data.get(N.dataId).complexTensorInfos.imag,v=s.data.get(r.dataId).values;return s.makeTensorInfo(r.shape,r.dtype,v)}const fa={kernelName:n.Imag,backendName:"cpu",kernelFunc:Ar};function Pn(S){const{inputs:A,backend:s,attrs:N}=S,{axis:r}=N,v=n.util.parseAxisParam(r,A[0].shape)[0];let C=n.backend_util.computeOutShape(A.map(fe=>fe.shape),v);if(0===n.util.sizeFromShape(C))return s.makeTensorInfo(C,A[0].dtype,[]);const V=A.filter(fe=>n.util.sizeFromShape(fe.shape)>0);if(1===V.length)return W({inputs:{x:V[0]},backend:s});const O=V.map(fe=>fe.shape);if(n.backend_util.assertParamsConsistent(O,v),"complex64"===V[0].dtype){const fe=V.map($e=>R({inputs:{input:$e},backend:s})),ae=V.map($e=>Ar({inputs:{input:$e},backend:s})),le=Pn({inputs:fe,backend:s,attrs:{axis:v}}),_e=Pn({inputs:ae,backend:s,attrs:{axis:v}}),Me=c({inputs:{real:le,imag:_e},backend:s});return fe.forEach($e=>s.disposeIntermediateTensorInfo($e)),ae.forEach($e=>s.disposeIntermediateTensorInfo($e)),s.disposeIntermediateTensorInfo(le),s.disposeIntermediateTensorInfo(_e),Me}const z=V.map(fe=>{const ae=n.util.sizeFromShape(fe.shape.slice(v));return cn({inputs:{x:fe},backend:s,attrs:{shape:[-1,ae]}})}),U=z.map(fe=>({vals:s.data.get(fe.dataId).values,shape:fe.shape}));C=n.backend_util.computeOutShape(z.map(fe=>fe.shape),1);const G=1===z[0].shape[0],Z=Ke(U,C,A[0].dtype,G),ne=n.backend_util.computeOutShape(V.map(fe=>fe.shape),v),pe=s.makeTensorInfo(ne,A[0].dtype,Z);return z.forEach(fe=>s.disposeIntermediateTensorInfo(fe)),pe}const Ks={kernelName:n.Concat,backendName:"cpu",kernelFunc:Pn};function Xs(S){const{inputs:A,backend:s,attrs:N}=S,{x:r,filter:v}=A,{strides:C,pad:V,dataFormat:O,dilations:z,dimRoundingMode:U}=N;h([r,v],"conv2d");const G=n.backend_util.convertConv2DDataFormat(O),Z=n.backend_util.computeConv2DInfo(r.shape,v.shape,C,z,V,U,false,G),ne=Z.filterHeight,pe=Z.filterWidth,fe=Z.dilationHeight,ae=Z.dilationWidth,le=Z.padInfo.left,_e=Z.padInfo.top,Me="channelsLast"===Z.dataFormat,$e=new n.TensorBuffer(Z.outShape,r.dtype),Oe=n.util.computeStrides(r.shape),Ge=n.util.computeStrides(v.shape),nt=Oe[0],Xe=Me?Oe[1]:Oe[2],ct=Me?Oe[2]:1,lt=Me?1:Oe[1],st=$e.strides[0],at=Me?$e.strides[1]:$e.strides[2],ot=Me?$e.strides[2]:1,bt=Me?1:$e.strides[1],vt=s.data.get(r.dataId).values,wt=s.data.get(v.dataId).values,mt=$e.values;for(let kt=0;kt<Z.batchSize;++kt){const gt=kt*nt,St=kt*st;for(let xt=0;xt<Z.outHeight;++xt){const It=St+xt*at,Et=xt*Z.strideHeight-_e;for(let Mt=0;Mt<ne;++Mt){const Dt=Et+Mt*fe;if(Dt<0||Dt>=Z.inHeight)continue;const Lt=Mt*Ge[0],Pt=gt+Dt*Xe;for(let Gt=0;Gt<Z.outWidth;++Gt){const Jt=It+Gt*ot,nn=Gt*Z.strideWidth-le;for(let Kt=0;Kt<pe;++Kt){const pn=nn+Kt*ae;if(pn<0||pn>=Z.inWidth)continue;const kn=Pt+pn*ct;let Cn=Lt+Kt*Ge[1];for(let hn=0;hn<Z.inChannels;++hn){const xn=vt[kn+hn*lt];for(let _n=0;_n<Z.outChannels;++_n)mt[Jt+_n*bt]+=xn*wt[Cn+_n];Cn+=Z.outChannels}}}}}}return s.makeTensorInfo($e.shape,$e.dtype,mt)}const _s={kernelName:n.Conv2D,backendName:"cpu",kernelFunc:Xs};const Nr={kernelName:n.Conv2DBackpropFilter,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r,dy:v}=A,{strides:C,pad:V,dataFormat:O,dimRoundingMode:z,filterShape:U}=N;h([r,v],"conv2dBackpropFilter");const G=n.backend_util.convertConv2DDataFormat(O),Z=n.backend_util.computeConv2DInfo(r.shape,U,C,1,V,z,false,G),{strideHeight:ne,strideWidth:pe,filterHeight:fe,filterWidth:ae}=Z,le="channelsLast"===Z.dataFormat,_e=new n.TensorBuffer(Z.filterShape,"float32"),Me=Z.padInfo.left,$e=Z.padInfo.top,Oe=s.data.get(r.dataId).values,Ge=s.data.get(v.dataId).values,nt=new n.TensorBuffer(r.shape,r.dtype,Oe),Xe=new n.TensorBuffer(v.shape,v.dtype,Ge);for(let ct=0;ct<fe;++ct){const lt=Math.max(0,Math.ceil(($e-ct)/ne)),st=Math.min(Z.outHeight,(Z.inHeight+$e-ct)/ne);for(let at=0;at<ae;++at){const ot=Math.max(0,Math.ceil((Me-at)/pe)),bt=Math.min(Z.outWidth,(Z.inWidth+Me-at)/pe);for(let vt=0;vt<Z.inChannels;++vt)for(let wt=0;wt<Z.outChannels;++wt){let mt=0;for(let kt=0;kt<Z.batchSize;++kt)for(let gt=lt;gt<st;++gt){const St=ct+gt*ne-$e;for(let xt=ot;xt<bt;++xt){const It=at+xt*pe-Me;mt+=le?nt.get(kt,St,It,vt)*Xe.get(kt,gt,xt,wt):nt.get(kt,vt,St,It)*Xe.get(kt,wt,gt,xt)}}_e.set(mt,ct,at,vt,wt)}}}return s.makeTensorInfo(_e.shape,_e.dtype,_e.values)}};const Zs={kernelName:n.Conv2DBackpropInput,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{dy:r,filter:v}=A,{inputShape:C,strides:V,pad:O,dataFormat:z,dimRoundingMode:U}=N;h([r,v],"conv2dBackpropInput");const G=n.util.computeStrides(v.shape),Z=n.util.computeStrides(r.shape);let ne=n.backend_util.convertConv2DDataFormat(z);const pe=n.backend_util.computeConv2DInfo(C,v.shape,V,1,O,U,false,ne),fe=new n.TensorBuffer(pe.inShape,"float32"),ae=fe.values,le=s.data.get(r.dataId).values,_e=s.data.get(v.dataId).values,[Me,$e,Oe]=G,{batchSize:Ge,filterHeight:nt,filterWidth:Xe,inChannels:ct,inHeight:lt,inWidth:st,outChannels:at,outHeight:ot,outWidth:bt,strideHeight:vt,strideWidth:wt}=pe;ne=pe.dataFormat;const mt=nt-1-pe.padInfo.top,kt=Xe-1-pe.padInfo.left,gt="channelsLast"===ne,St=fe.strides[0],xt=gt?fe.strides[1]:fe.strides[2],It=gt?fe.strides[2]:1,Et=gt?1:fe.strides[1],Mt=Z[0],Dt=gt?Z[1]:Z[2],Lt=gt?Z[2]:1,Pt=gt?1:Z[1];for(let Gt=0;Gt<Ge;++Gt)for(let Jt=0;Jt<ct;++Jt)for(let nn=0;nn<lt;++nn){const Kt=nn-mt,pn=Math.max(0,Math.ceil(Kt/vt)),kn=Math.min(ot,(nt+Kt)/vt);for(let Cn=0;Cn<st;++Cn){const hn=Cn-kt,xn=Math.max(0,Math.ceil(hn/wt)),_n=Math.min(bt,(Xe+hn)/wt);let Vr=0;for(let zr=pn;zr<kn;++zr){const pr=zr*vt-Kt;for(let jn=xn;jn<_n;++jn){const ao=Mt*Gt+Dt*zr+Lt*jn,Wr=Me*(nt-1-pr)+$e*(Xe-1-(jn*wt-hn))+Oe*Jt;for(let Ms=0;Ms<at;++Ms){Vr+=le[ao+Pt*Ms]*_e[Wr+Ms]}}}ae[St*Gt+xt*nn+It*Cn+Et*Jt]=Vr}}return s.makeTensorInfo(fe.shape,fe.dtype,fe.values)}};const ma={kernelName:n.Conv3D,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r,filter:v}=A,{strides:C,pad:V,dilations:O}=N;h([r,v],"conv3d");const z=n.backend_util.computeConv3DInfo(r.shape,v.shape,C,O,V),{filterDepth:U,filterHeight:G,filterWidth:Z,dilationDepth:ne,dilationHeight:pe,dilationWidth:fe,padInfo:ae}=z,le=ae.front,_e=ae.left,Me=ae.top,$e=new n.TensorBuffer(z.outShape,r.dtype),Oe=s.data.get(r.dataId).values,Ge=s.data.get(v.dataId).values,nt=$e.values,Xe=n.util.computeStrides(r.shape),ct=n.util.computeStrides(v.shape);for(let lt=0;lt<z.batchSize;++lt){const st=lt*Xe[0],at=lt*$e.strides[0];for(let ot=0;ot<z.outDepth;++ot){const bt=at+ot*$e.strides[1],vt=ot*z.strideDepth-le;for(let wt=0;wt<U;++wt){const mt=vt+wt*ne;if(mt<0||mt>=z.inDepth)continue;const kt=wt*ct[0],gt=st+mt*Xe[1];for(let St=0;St<z.outHeight;++St){const xt=bt+St*$e.strides[2],It=St*z.strideHeight-Me;for(let Et=0;Et<G;++Et){const Mt=It+Et*pe;if(Mt<0||Mt>=z.inHeight)continue;const Dt=kt+Et*ct[1],Lt=gt+Mt*Xe[2];for(let Pt=0;Pt<z.outWidth;++Pt){const Gt=xt+Pt*z.outChannels,Jt=Pt*z.strideWidth-_e;for(let nn=0;nn<Z;++nn){const Kt=Jt+nn*fe;if(Kt<0||Kt>=z.inWidth)continue;const pn=Dt+nn*ct[2],kn=Lt+Kt*z.inChannels;let Cn=pn;for(let hn=0;hn<z.inChannels;++hn){const xn=Oe[kn+hn];for(let _n=0;_n<z.outChannels;++_n)nt[Gt+_n]+=xn*Ge[Cn+_n];Cn+=z.outChannels}}}}}}}}return s.makeTensorInfo($e.shape,$e.dtype,$e.values)}};const ga={kernelName:n.Conv3DBackpropFilterV2,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r,dy:v}=A,{strides:C,pad:V,filterShape:O}=N;h([r,v],"conv3dBackpropFilterV2");const z=n.util.computeStrides(r.shape),U=n.util.computeStrides(v.shape),G=n.backend_util.computeConv3DInfo(r.shape,O,C,1,V),Z=G.strideDepth,ne=G.strideHeight,pe=G.strideWidth,fe=G.filterDepth,ae=G.filterHeight,le=G.filterWidth,_e=new n.TensorBuffer(G.filterShape,"float32"),Me=_e.values,[$e,Oe,Ge,nt]=_e.strides,Xe=s.data.get(v.dataId).values,[ct,lt,st,at]=U,ot=s.data.get(r.dataId).values,[bt,vt,wt,mt]=z,kt=G.padInfo.front,gt=G.padInfo.left,St=G.padInfo.top;for(let xt=0;xt<fe;++xt){const It=Math.max(0,Math.ceil((kt-xt)/Z)),Et=Math.min(G.outDepth,(G.inDepth+kt-xt)/Z),Mt=xt*$e;for(let Dt=0;Dt<ae;++Dt){const Lt=Math.max(0,Math.ceil((St-Dt)/ne)),Pt=Math.min(G.outHeight,(G.inHeight+St-Dt)/ne),Gt=Dt*Oe+Mt;for(let Jt=0;Jt<le;++Jt){const nn=Math.max(0,Math.ceil((gt-Jt)/pe)),Kt=Math.min(G.outWidth,(G.inWidth+gt-Jt)/pe),pn=Jt*Ge+Gt;for(let kn=0;kn<G.inChannels;++kn){const Cn=kn*nt+pn;for(let hn=0;hn<G.outChannels;++hn){let xn=0;for(let _n=0;_n<G.batchSize;++_n){const Vr=_n*bt,zr=_n*ct;for(let pr=It;pr<Et;++pr){const jn=(xt+pr*Z-kt)*vt+Vr,ao=pr*lt+zr;for(let Wr=Lt;Wr<Pt;++Wr){const Ms=(Dt+Wr*ne-St)*wt+jn,Cs=Wr*st+ao;for(let Ba=nn;Ba<Kt;++Ba){const Ta=Ba*at+Cs;xn+=ot[(Jt+Ba*pe-gt)*mt+Ms+kn]*Xe[Ta+hn]}}}}Me[Cn+hn]=xn}}}}}return s.makeTensorInfo(_e.shape,_e.dtype,_e.values)}};const rr={kernelName:n.Conv3DBackpropInputV2,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{dy:r,filter:v}=A,{pad:C,strides:V,inputShape:O}=N;h([r],"conv3dBackpropInputV2");const z=n.util.computeStrides(r.shape),U=n.util.computeStrides(v.shape),G=n.backend_util.computeConv3DInfo(O,v.shape,V,1,C),Z=new n.TensorBuffer(G.inShape,"float32"),ne=Z.values,[pe,fe,ae,le]=Z.strides,_e=s.data.get(r.dataId).values,[Me,$e,Oe,Ge]=z,nt=s.data.get(v.dataId).values,[Xe,ct,lt,st]=U,{batchSize:at,filterDepth:ot,filterHeight:bt,filterWidth:vt,inChannels:wt,inDepth:mt,inHeight:kt,inWidth:gt,outChannels:St,outDepth:xt,outHeight:It,outWidth:Et,strideDepth:Mt,strideHeight:Dt,strideWidth:Lt}=G,Pt=ot-1-G.padInfo.front,Gt=bt-1-G.padInfo.top,Jt=vt-1-G.padInfo.left;for(let nn=0;nn<at;++nn)for(let Kt=0;Kt<wt;++Kt)for(let pn=0;pn<mt;++pn){const kn=pn-Pt,Cn=Math.max(0,Math.ceil(kn/Mt)),hn=Math.min(xt,(ot+kn)/Mt);for(let xn=0;xn<kt;++xn){const _n=xn-Gt,Vr=Math.max(0,Math.ceil(_n/Dt)),zr=Math.min(It,(bt+_n)/Dt);for(let pr=0;pr<gt;++pr){const jn=pr-Jt,ao=Math.max(0,Math.ceil(jn/Lt)),Wr=Math.min(Et,(vt+jn)/Lt);let Ms=0;for(let Cs=Cn;Cs<hn;++Cs){const Ba=Cs*Mt-kn;for(let Ta=Vr;Ta<zr;++Ta){const Bu=Ta*Dt-_n;for(let So=ao;So<Wr;++So){const Lu=Me*nn+$e*Cs+Oe*Ta+Ge*So,Pu=Xe*(ot-1-Ba)+ct*(bt-1-Bu)+lt*(vt-1-(So*Lt-jn))+st*Kt;for(let To=0;To<St;++To){Ms+=_e[Lu+To]*nt[Pu+To]}}}}ne[pe*nn+fe*pn+ae*xn+le*pr+Kt]=Ms}}}return s.makeTensorInfo(Z.shape,Z.dtype,Z.values)}},Ss=o(n.Cos,S=>Math.cos(S)),Ts={kernelName:n.Cos,backendName:"cpu",kernelFunc:Ss},Wa=o(n.Cosh,S=>Math.cosh(S)),Ua={kernelName:n.Cosh,backendName:"cpu",kernelFunc:Wa};const qa={kernelName:n.CropAndResize,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{image:r,boxes:v,boxInd:C}=A,{cropSize:V,method:O,extrapolationValue:z}=N,[U,G,Z,ne]=r.shape,pe=v.shape[0],[fe,ae]=V,le=(0,n.buffer)([pe,fe,ae,ne],"float32"),_e=s.data.get(v.dataId).values,Me=s.data.get(C.dataId).values,$e=s.data.get(r.dataId).values,Oe=n.util.computeStrides(r.shape),Ge=n.util.computeStrides(le.shape);for(let nt=0;nt<pe;nt++){const Xe=4*nt,ct=_e[Xe],lt=_e[Xe+1],st=_e[Xe+2],at=_e[Xe+3],ot=Me[nt];if(ot>=U)continue;const bt=fe>1?(st-ct)*(G-1)/(fe-1):0,vt=ae>1?(at-lt)*(Z-1)/(ae-1):0;for(let wt=0;wt<fe;wt++){const mt=fe>1?ct*(G-1)+wt*bt:.5*(ct+st)*(G-1);if(mt<0||mt>G-1)for(let kt=0;kt<ae;kt++)for(let gt=0;gt<ne;gt++){const St=gt+kt*Ge[2]+wt*Ge[1]+nt*Ge[0];le.values[St]=z}else if("bilinear"===O){const kt=Math.floor(mt),gt=Math.ceil(mt),St=mt-kt;for(let xt=0;xt<ae;xt++){const It=ae>1?lt*(Z-1)+xt*vt:.5*(lt+at)*(Z-1);if(It<0||It>Z-1){for(let Lt=0;Lt<ne;Lt++){const Pt=Lt+xt*Ge[2]+wt*Ge[1]+nt*Ge[0];le.values[Pt]=z}continue}const Et=Math.floor(It),Mt=Math.ceil(It),Dt=It-Et;for(let Lt=0;Lt<ne;Lt++){let Pt=Lt+Et*Oe[2]+kt*Oe[1]+ot*Oe[0];const Gt=$e[Pt];Pt=Lt+Mt*Oe[2]+kt*Oe[1]+ot*Oe[0];const Jt=$e[Pt];Pt=Lt+Et*Oe[2]+gt*Oe[1]+ot*Oe[0];const nn=$e[Pt];Pt=Lt+Mt*Oe[2]+gt*Oe[1]+ot*Oe[0];const Kt=Gt+(Jt-Gt)*Dt,pn=nn+($e[Pt]-nn)*Dt;Pt=Lt+xt*Ge[2]+wt*Ge[1]+nt*Ge[0],le.values[Pt]=Kt+(pn-Kt)*St}}}else for(let kt=0;kt<ae;++kt){const gt=ae>1?lt*(Z-1)+kt*vt:.5*(lt+at)*(Z-1);if(gt<0||gt>Z-1){for(let It=0;It<ne;It++){const Et=It+kt*Ge[2]+wt*Ge[1]+nt*Ge[0];le.values[Et]=z}continue}const St=Math.round(gt),xt=Math.round(mt);for(let It=0;It<ne;It++){const Et=It+St*Oe[2]+xt*Oe[1]+ot*Oe[0],Mt=It+kt*Ge[2]+wt*Ge[1]+nt*Ge[0];le.values[Mt]=$e[Et]}}}}return s.makeTensorInfo(le.shape,le.dtype,le.values)}};const Ha={kernelName:n.Cumsum,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{axis:v,exclusive:C,reverse:V}=N;h(r,"cumsum");const O=n.backend_util.getAxesPermutation([v],r.shape.length);let z=r;null!=O&&(z=$n({inputs:{x:r},backend:s,attrs:{perm:O}}));const U=n.backend_util.getInnerMostAxes(1,r.shape.length)[0];if(U!==z.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${z.shape.length-1} but got axis=${U}`);const G=(0,n.upcastType)(z.dtype,"int32"),Z=n.util.makeZerosTypedArray(n.util.sizeFromShape(z.shape),G),ne=s.data.get(z.dataId).values,pe=z.shape[z.shape.length-1],fe=V?(le,_e)=>le+pe-_e-1:(le,_e)=>le+_e;for(let le=0;le<ne.length;le+=pe)for(let _e=0;_e<pe;_e++){const Me=fe(le,_e);if(0===_e)Z[Me]=C?0:ne[Me];else{const $e=fe(le,_e-1);Z[Me]=C?ne[$e]+Z[$e]:ne[Me]+Z[$e]}}const ae=s.makeTensorInfo(z.shape,G,Z);if(null!=O){const le=$n({inputs:{x:ae},backend:s,attrs:{perm:n.backend_util.getUndoAxesPermutation(O)}});return s.disposeIntermediateTensorInfo(ae),s.disposeIntermediateTensorInfo(z),le}return ae}};const ja={kernelName:n.DenseBincount,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r,weights:v}=A,{size:C,binaryOutput:V}=N;if(1===r.shape.length){const O=Q(s.data.get(r.dataId).values,s.data.get(v.dataId).values,v.dtype,v.shape,C);return s.makeTensorInfo([C],v.dtype,O)}if(2===r.shape.length){const O=oe(s.bufferSync(r),s.bufferSync(v),C,V);return s.makeTensorInfo(O.shape,v.dtype,O.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}};const Ga={kernelName:n.DepthToSpace,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{blockSize:v,dataFormat:C}=N;n.util.assert("NHWC"===C,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${C}`),n.util.assert(v>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${v}`);const V=r.shape[0],O=r.shape[1],z=r.shape[2],U=r.shape[3],G=O*v,Z=z*v,ne=U/(v*v),pe=s.data.get(r.dataId).values,fe=new Float32Array(V*G*Z*ne);let ae=0;for(let le=0;le<V;++le)for(let _e=0;_e<G;++_e){const Me=Math.floor(_e/v),$e=_e%v;for(let Oe=0;Oe<Z;++Oe){const Ge=Math.floor(Oe/v),nt=($e*v+Oe%v)*ne;for(let Xe=0;Xe<ne;++Xe){const ct=Xe+nt+U*(Ge+z*(Me+O*le));fe[ae++]=pe[ct]}}}return s.makeTensorInfo([V,G,Z,ne],r.dtype,fe)}};function $a(S){const{inputs:A,backend:s,attrs:N}=S,{x:r,filter:v}=A,{strides:C,pad:V,dilations:O,dimRoundingMode:z}=N;h([r,v],"depthwiseConv2DNative");const U=n.util.computeStrides(r.shape),G=n.util.computeStrides(v.shape);let Z=O;null==Z&&(Z=[1,1]),n.util.assert(n.backend_util.eitherStridesOrDilationsAreOne(C,Z),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${C} and dilations '${Z}'`);const ne=n.backend_util.computeConv2DInfo(r.shape,v.shape,C,Z,V,z,true),{filterHeight:pe,filterWidth:fe,dilationHeight:ae,dilationWidth:le,padInfo:_e}=ne,Me=_e.left,$e=_e.top,Oe=ne.outChannels/ne.inChannels,Ge=new n.TensorBuffer(ne.outShape,r.dtype),nt=s.data.get(r.dataId).values,Xe=s.data.get(v.dataId).values,ct=Ge.values;for(let lt=0;lt<ne.batchSize;++lt){const st=lt*U[0],at=lt*Ge.strides[0];for(let ot=0;ot<ne.outHeight;++ot){const bt=at+ot*Ge.strides[1],vt=ot*ne.strideHeight-$e;for(let wt=0;wt<pe;++wt){const mt=vt+wt*ae;if(mt<0||mt>=ne.inHeight)continue;const kt=wt*G[0],gt=st+mt*U[1];for(let St=0;St<ne.outWidth;++St){const xt=bt+St*Ge.strides[2],It=St*ne.strideWidth-Me;for(let Et=0;Et<fe;++Et){const Mt=It+Et*le;if(Mt<0||Mt>=ne.inWidth)continue;const Dt=kt+Et*G[1],Lt=gt+Mt*ne.inChannels;let Pt=xt,Gt=Dt;for(let Jt=0;Jt<ne.inChannels;++Jt){const nn=nt[Lt+Jt];for(let Kt=0;Kt<Oe;++Kt)ct[Pt+Kt]+=nn*Xe[Gt+Kt];Pt+=Oe,Gt+=Oe}}}}}}return s.makeTensorInfo(Ge.shape,Ge.dtype,Ge.values)}const Ka={kernelName:n.DepthwiseConv2dNative,backendName:"cpu",kernelFunc:$a};const ya={kernelName:n.DepthwiseConv2dNativeBackpropFilter,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r,dy:v}=A,{strides:C,dilations:V,pad:O,dimRoundingMode:z,filterShape:U}=N;h([r,v],"depthwiseConv2dNativeBackpropFilter");const G=n.backend_util.computeConv2DInfo(r.shape,U,C,V,O,z,true),{strideHeight:Z,strideWidth:ne,filterHeight:pe,filterWidth:fe}=G,ae=new n.TensorBuffer(G.filterShape,"float32"),le=G.padInfo.left,_e=G.padInfo.top,Me=G.outChannels/G.inChannels,$e=s.data.get(r.dataId).values,Oe=new n.TensorBuffer(r.shape,r.dtype,$e),Ge=s.data.get(v.dataId).values,nt=new n.TensorBuffer(v.shape,v.dtype,Ge);for(let Xe=0;Xe<pe;++Xe){const ct=Math.max(0,Math.ceil((_e-Xe)/Z)),lt=Math.min(G.outHeight,(G.inHeight+_e-Xe)/Z);for(let st=0;st<fe;++st){const at=Math.max(0,Math.ceil((le-st)/ne)),ot=Math.min(G.outWidth,(G.inWidth+le-st)/ne);for(let bt=0;bt<G.outChannels;++bt){const vt=Math.trunc(bt/Me),wt=bt%Me;let mt=0;for(let kt=0;kt<G.batchSize;++kt)for(let gt=ct;gt<lt;++gt){const St=Xe+gt*Z-_e;for(let xt=at;xt<ot;++xt){const It=st+xt*ne-le;mt+=Oe.get(kt,St,It,vt)*nt.get(kt,gt,xt,bt)}}ae.set(mt,Xe,st,vt,wt)}}}return s.makeTensorInfo(ae.shape,ae.dtype,ae.values)}};const Xa={kernelName:n.DepthwiseConv2dNativeBackpropInput,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{dy:r,filter:v}=A,{strides:C,dilations:V,pad:O,dimRoundingMode:z,inputShape:U}=N;h([r,v],"depthwiseConv2DNativeBackpropInput");const G=n.util.computeStrides(r.shape),Z=n.util.computeStrides(v.shape),ne=n.backend_util.computeConv2DInfo(U,v.shape,C,V,O,z,true),pe=new n.TensorBuffer(ne.inShape,"float32"),fe=pe.values,[ae,le,_e]=pe.strides,Me=s.data.get(r.dataId).values,[$e,Oe,Ge]=G,nt=s.data.get(v.dataId).values,[Xe,ct,lt]=Z,{batchSize:st,filterHeight:at,filterWidth:ot,inChannels:bt,inHeight:vt,inWidth:wt,outChannels:mt,outHeight:kt,outWidth:gt,strideHeight:St,strideWidth:xt}=ne,It=at-1-ne.padInfo.top,Et=ot-1-ne.padInfo.left,Mt=mt/bt;for(let Dt=0;Dt<st;++Dt)for(let Lt=0;Lt<bt;++Lt)for(let Pt=0;Pt<vt;++Pt){const Gt=Pt-It,Jt=Math.max(0,Math.ceil(Gt/St)),nn=Math.min(kt,(at+Gt)/St);for(let Kt=0;Kt<wt;++Kt){const pn=Kt-Et,kn=Math.max(0,Math.ceil(pn/xt)),Cn=Math.min(gt,(ot+pn)/xt);let hn=0;for(let xn=Jt;xn<nn;++xn){const _n=xn*St-Gt;for(let Vr=kn;Vr<Cn;++Vr){const zr=$e*Dt+Oe*xn+Ge*Vr,pr=Xe*(at-1-_n)+ct*(ot-1-(Vr*xt-pn))+lt*Lt;for(let jn=0;jn<Mt;++jn){hn+=Me[zr+(Lt*Mt+jn)]*nt[pr+jn]}}}fe[ae*Dt+le*Pt+_e*Kt+Lt]=hn}}return s.makeTensorInfo(pe.shape,pe.dtype,pe.values)}};const Is={kernelName:n.Diag,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s}=S,{x:N}=A,r=n.util.sizeFromShape(N.shape),v=s.data.get(N.dataId).values,C=(0,n.buffer)([r,r],N.dtype),V=C.values;for(let z=0;z<v.length;z++)V[z*r+z]=v[z];const O=[...N.shape,...N.shape];return s.makeTensorInfo(O,C.dtype,C.values)}},Qs={kernelName:n.Dilation2D,backendName:"cpu",kernelFunc:({inputs:S,backend:A,attrs:s})=>{const{x:N,filter:r}=S,{strides:v,pad:C,dilations:V}=s,O=A,z=O.data.get(N.dataId).values,U=N.shape.length,G=O.data.get(r.dataId).values,Z=r.shape.length,{batchSize:ne,inHeight:pe,inWidth:fe,inChannels:ae,outHeight:le,outWidth:_e,padInfo:Me,strideHeight:$e,strideWidth:Oe,filterHeight:Ge,filterWidth:nt,dilationHeight:Xe,dilationWidth:ct,outShape:lt}=n.backend_util.computeDilation2DInfo(N.shape,r.shape,v,C,"NHWC",V),st=n.util.sizeFromShape(lt),at=lt.length,ot=n.util.getArrayFromDType(N.dtype,st);for(let bt=0;bt<ne;++bt)for(let vt=0;vt<le;++vt){const wt=vt*$e-Me.top;for(let mt=0;mt<_e;++mt){const kt=mt*Oe-Me.left;for(let gt=0;gt<ae;++gt){let St=Number.MIN_SAFE_INTEGER;for(let xt=0;xt<Ge;++xt){const It=wt+xt*Xe;if(It>=0&&It<pe)for(let Et=0;Et<nt;++Et){const Mt=kt+Et*ct;if(Mt>=0&&Mt<fe){const Dt=n.util.locToIndex([bt,It,Mt,gt],U,n.util.computeStrides(N.shape)),Lt=n.util.locToIndex([xt,Et,gt],Z,n.util.computeStrides(r.shape)),Pt=z[Dt]+G[Lt];Pt>St&&(St=Pt)}}}ot[n.util.locToIndex([bt,vt,mt,gt],at,n.util.computeStrides(lt))]=St}}}return{dataId:O.write(n.util.toTypedArray(ot,N.dtype),lt,N.dtype),shape:lt,dtype:N.dtype}}},ba={kernelName:n.Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:({inputs:S,backend:A,attrs:s})=>{const{x:N,filter:r,dy:v}=S,{strides:C,pad:V,dilations:O}=s,z=A,U=n.util.toNestedArray(N.shape,z.data.get(N.dataId).values),G=n.util.toNestedArray(r.shape,z.data.get(r.dataId).values),{batchSize:Z,inHeight:ne,inWidth:pe,inChannels:fe,outHeight:ae,outWidth:le,padInfo:_e,strideHeight:Me,strideWidth:$e,filterHeight:Oe,filterWidth:Ge,dilationHeight:nt,dilationWidth:Xe,outShape:ct}=n.backend_util.computeDilation2DInfo(N.shape,r.shape,C,V,"NHWC",O);n.util.assert(v.rank===ct.length,()=>`Error in ${n.Dilation2DBackpropFilter}, dy must have the same rank as output ${ct.length}, but got ${v.rank}`);const lt=n.util.toNestedArray(ct,z.data.get(v.dataId).values),st=n.util.makeZerosNestedTypedArray(r.shape,r.dtype);for(let at=0;at<Z;++at)for(let ot=0;ot<ae;++ot){const bt=ot*Me-_e.top;for(let vt=0;vt<le;++vt){const wt=vt*$e-_e.left;for(let mt=0;mt<fe;++mt){let kt=Number.MIN_SAFE_INTEGER,gt=0,St=0;for(let xt=0;xt<Oe;++xt){const It=bt+xt*nt;if(It>=0&&It<ne)for(let Et=0;Et<Ge;++Et){const Mt=wt+Et*Xe;if(Mt>=0&&Mt<pe){const Dt=U[at][It][Mt][mt]+G[xt][Et][mt];Dt>kt&&(kt=Dt,gt=xt,St=Et)}}}st[gt][St][mt]+=lt[at][ot][vt][mt]}}}return{dataId:z.write(n.util.toTypedArray(st,N.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Za={kernelName:n.Dilation2DBackpropInput,backendName:"cpu",kernelFunc:({inputs:S,backend:A,attrs:s})=>{const{x:N,filter:r,dy:v}=S,{strides:C,pad:V,dilations:O}=s,z=A,U=n.util.toNestedArray(N.shape,z.data.get(N.dataId).values),G=n.util.toNestedArray(r.shape,z.data.get(r.dataId).values),{batchSize:Z,inHeight:ne,inWidth:pe,inChannels:fe,outHeight:ae,outWidth:le,padInfo:_e,strideHeight:Me,strideWidth:$e,filterHeight:Oe,filterWidth:Ge,dilationHeight:nt,dilationWidth:Xe,outShape:ct}=n.backend_util.computeDilation2DInfo(N.shape,r.shape,C,V,"NHWC",O);n.util.assert(v.rank===ct.length,()=>`Error in ${n.Dilation2DBackpropInput}, dy must have the same rank as output ${ct.length}, but got ${v.rank}`);const lt=n.util.toNestedArray(ct,z.data.get(v.dataId).values),st=n.util.makeZerosNestedTypedArray(N.shape,N.dtype);for(let at=0;at<Z;++at)for(let ot=0;ot<ae;++ot){const bt=ot*Me-_e.top;for(let vt=0;vt<le;++vt){const wt=vt*$e-_e.left;for(let mt=0;mt<fe;++mt){let kt=Number.MIN_SAFE_INTEGER,gt=bt<0?0:bt,St=wt<0?0:wt;for(let xt=0;xt<Oe;++xt){const It=bt+xt*nt;if(It>=0&&It<ne)for(let Et=0;Et<Ge;++Et){const Mt=wt+Et*Xe;if(Mt>=0&&Mt<pe){const Dt=U[at][It][Mt][mt]+G[xt][Et][mt];Dt>kt&&(kt=Dt,gt=It,St=Mt)}}}st[at][gt][St][mt]+=lt[at][ot][vt][mt]}}}return{dataId:z.write(n.util.toTypedArray(st,N.dtype),N.shape,N.dtype),shape:N.shape,dtype:N.dtype}}};function Es(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{axis:v,keepDims:C}=N;let V;h(r,"sum"),V="bool"===r.dtype?re({inputs:{x:r},backend:s,attrs:{dtype:"int32"}}):W({inputs:{x:r},backend:s});const O=V.shape.length,z=n.util.parseAxisParam(v,V.shape),U=n.backend_util.getAxesPermutation(z,O);let G=z,Z=V;null!=U&&(Z=$n({inputs:{x:V},backend:s,attrs:{perm:U}}),G=n.backend_util.getInnerMostAxes(G.length,O)),n.backend_util.assertAxesAreInnerMostDims("sum",G,Z.shape.length);const[ne,pe]=n.backend_util.computeOutAndReduceShapes(Z.shape,G);let fe=y(s,ne,n.backend_util.upcastType(Z.dtype,"int32"));const ae=n.util.sizeFromShape(pe),le=s.data.get(fe.dataId).values,_e=s.data.get(Z.dataId).values;for(let Me=0;Me<le.length;++Me){const $e=Me*ae;let Oe=0;for(let Ge=0;Ge<ae;++Ge)Oe+=_e[$e+Ge];le[Me]=Oe}if(C){const Me=fe;fe=cn({inputs:{x:fe},backend:s,attrs:{shape:n.backend_util.expandShapeToKeepDim(fe.shape,z)}}),s.disposeIntermediateTensorInfo(Me)}return s.disposeIntermediateTensorInfo(V),null!=U&&s.disposeIntermediateTensorInfo(Z),fe}const As={kernelName:n.Sum,backendName:"cpu",kernelFunc:Es};const ka={kernelName:n.Einsum,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{equation:r}=N,v=A,{allDims:C,summedDims:V,idDims:O}=n.backend_util.decodeEinsumEquation(r,v.length);n.backend_util.checkEinsumDimSizes(C.length,O,v);const{path:z,steps:U}=n.backend_util.getEinsumComputePath(V,O),G=U.length;let Z=null,ne=C.length;const pe=[];for(let fe=0;fe<G;++fe){for(const ae of U[fe]){const{permutationIndices:le,expandDims:_e}=n.backend_util.getEinsumPermutation(ne,O[ae]);let Me;n.backend_util.isIdentityPermutation(le)?Me=v[ae]:(Me=$n({inputs:{x:v[ae]},backend:s,attrs:{perm:le}}),pe.push(Me));const $e=Me.shape.slice();for(let Oe=0;Oe<_e.length;++Oe)$e.splice(_e[Oe],0,1);n.util.arraysEqual(Me.shape,$e)||(Me=cn({inputs:{x:Me},backend:s,attrs:{shape:$e}}),pe.push(Me)),null===Z?Z=Me:(Z=Jn({inputs:{a:Me,b:Z},backend:s}),pe.push(Z))}fe<G-1&&(z[fe]>=0&&(Z=Es({inputs:{x:Z},backend:s,attrs:{axis:z[fe]-(C.length-ne),keepDims:false}}),pe.push(Z)),ne--)}for(const fe of pe)fe!==Z&&s.disposeIntermediateTensorInfo(fe);return Z}};const wa={kernelName:n.EluGrad,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s}=S,{dy:N,y:r}=A;h([N,r],"eluGrad");const v=new Float32Array(n.util.sizeFromShape(r.shape)),C=s.data.get(r.dataId).values,V=s.data.get(N.dataId).values;for(let O=0;O<C.length;++O){const z=C[O];v[O]=z>=1?V[O]:V[O]*(z+1)}return s.makeTensorInfo(r.shape,"float32",v)}},Qa=n.backend_util.ERF_P,Ja=n.backend_util.ERF_A1,Da=n.backend_util.ERF_A2,Ya=n.backend_util.ERF_A3,eo=n.backend_util.ERF_A4,to=n.backend_util.ERF_A5,Fa=o(n.Erf,S=>{const A=Math.sign(S),s=Math.abs(S),N=1/(1+Qa*s);return A*(1-((((to*N+eo)*N+Ya)*N+Da)*N+Ja)*N*Math.exp(-s*s))}),va={kernelName:n.Erf,backendName:"cpu",kernelFunc:Fa};function Js(S){const{inputs:A,backend:s,attrs:N}=S,{input:r}=A,{dim:v}=N,C=r.shape.length,V=r.shape.slice();let O=v;return v<0&&(n.util.assert(-(C+1)<=v,()=>`Axis must be in the interval [${-(C+1)}, ${C}]`),O=C+v+1),V.splice(O,0,1),cn({inputs:{x:r},backend:s,attrs:{shape:V}})}const no={kernelName:n.ExpandDims,backendName:"cpu",kernelFunc:Js},ro=T((S,A)=>S/A),Ys=ve(n.RealDiv,ro),ea={kernelName:n.RealDiv,backendName:"cpu",kernelFunc:Ys};function Oa(S,A,s){const N=S.shape,r=N[0],v=N[1],C=s.data.get(S.dataId),V=C.complexTensorInfos.real,O=C.complexTensorInfos.imag,z=[r,v],U=n.util.sizeFromShape(z),G=n.util.getTypedArrayFromDType("float32",U),Z=n.util.getTypedArrayFromDType("float32",U);for(let ae=0;ae<r;ae++){const le=Dn({inputs:{x:V},backend:s,attrs:{begin:[ae,0],size:[1,v]}}),_e=Dn({inputs:{x:O},backend:s,attrs:{begin:[ae,0],size:[1,v]}}),Me=c({inputs:{real:le,imag:_e},backend:s}),{real:$e,imag:Oe}=so(Me,A,s),Ge=n.backend_util.mergeRealAndImagArrays($e,Oe);for(let nt=0;nt<v;nt++){const Xe=n.backend_util.getComplexWithIndex(Ge,nt);G[ae*v+nt]=Xe.real,Z[ae*v+nt]=Xe.imag}s.disposeIntermediateTensorInfo(le),s.disposeIntermediateTensorInfo(_e),s.disposeIntermediateTensorInfo(Me)}const ne=s.makeTensorInfo(z,"float32",G),pe=s.makeTensorInfo(z,"float32",Z),fe=c({inputs:{real:ne,imag:pe},backend:s});return s.disposeIntermediateTensorInfo(ne),s.disposeIntermediateTensorInfo(pe),fe}function so(S,A,s){const N=n.util.sizeFromShape(S.shape),r=s.data.get(S.dataId),v=s.data.get(r.complexTensorInfos.real.dataId).values,C=s.data.get(r.complexTensorInfos.imag.dataId).values;if(0==((V=N)&V-1)){const O=Na(v,C,N,A,s),z=[S.shape[0],S.shape[1]];if(A){const U=s.makeTensorInfo(z,"float32",O.real),G=s.makeTensorInfo(z,"float32",O.imag),Z=s.makeTensorInfo([],"float32",n.util.createScalarValue(N,"float32")),ne=W({inputs:{x:Z},backend:s}),pe=ea.kernelFunc({inputs:{a:U,b:Z},backend:s}),fe=ea.kernelFunc({inputs:{a:G,b:ne},backend:s}),ae=s.data.get(pe.dataId).values,le=s.data.get(fe.dataId).values;return s.disposeIntermediateTensorInfo(U),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(Z),s.disposeIntermediateTensorInfo(ne),s.disposeIntermediateTensorInfo(pe),s.disposeIntermediateTensorInfo(fe),{real:ae,imag:le}}return O}{const O=function(z,U,G){const Z=new Float32Array(2*U);for(let ne=0;ne<U;ne++){let pe=0,fe=0;for(let ae=0;ae<U;ae++){const le=n.backend_util.exponent(ne*ae,U,G),_e=n.backend_util.getComplexWithIndex(z,ae);pe+=_e.real*le.real-_e.imag*le.imag,fe+=_e.real*le.imag+_e.imag*le.real}G&&(pe/=U,fe/=U),n.backend_util.assignToTypedArray(Z,pe,fe,ne)}return Z}(n.backend_util.mergeRealAndImagArrays(v,C),N,A);return n.backend_util.splitRealAndImagArrays(O)}var V}function Na(S,A,s,N,r){if(1===s)return{real:S,imag:A};const v=n.backend_util.mergeRealAndImagArrays(S,A),C=s/2,V=n.backend_util.complexWithEvenIndex(v),O=V.real,z=V.imag,U=[O.length],G=r.makeTensorInfo(U,"float32",O),Z=r.makeTensorInfo(U,"float32",z),ne=c({inputs:{real:G,imag:Z},backend:r}),pe=n.backend_util.complexWithOddIndex(v),fe=pe.real,ae=pe.imag,le=[fe.length],_e=r.makeTensorInfo(le,"float32",fe),Me=r.makeTensorInfo(le,"float32",ae),$e=c({inputs:{real:_e,imag:Me},backend:r}),Oe=Na(O,z,C,N,r),Ge=Oe.real,nt=Oe.imag,Xe=[Ge.length],ct=r.makeTensorInfo(Xe,"float32",Ge),lt=r.makeTensorInfo(Xe,"float32",nt),st=c({inputs:{real:ct,imag:lt},backend:r}),at=Na(fe,ae,C,N,r),ot=at.real,bt=at.imag,vt=[ot.length],wt=r.makeTensorInfo(vt,"float32",ot),mt=r.makeTensorInfo(vt,"float32",bt),kt=c({inputs:{real:wt,imag:mt},backend:r}),gt=n.backend_util.exponents(s,N),St=[gt.real.length],xt=r.makeTensorInfo(St,"float32",gt.real),It=r.makeTensorInfo(St,"float32",gt.imag),Et=c({inputs:{real:xt,imag:It},backend:r}),Mt=Jn({inputs:{a:Et,b:kt},backend:r}),Dt=P({inputs:{a:st,b:Mt},backend:r}),Lt=Kn({inputs:{a:st,b:Mt},backend:r}),Pt=R({inputs:{input:Dt},backend:r}),Gt=R({inputs:{input:Lt},backend:r}),Jt=Ar({inputs:{input:Dt},backend:r}),nn=Ar({inputs:{input:Lt},backend:r}),Kt=Pn({inputs:[Pt,Gt],backend:r,attrs:{axis:0}}),pn=Pn({inputs:[Jt,nn],backend:r,attrs:{axis:0}}),kn=r.data.get(Kt.dataId).values,Cn=r.data.get(pn.dataId).values;return r.disposeIntermediateTensorInfo(G),r.disposeIntermediateTensorInfo(Z),r.disposeIntermediateTensorInfo(ne),r.disposeIntermediateTensorInfo(_e),r.disposeIntermediateTensorInfo(Me),r.disposeIntermediateTensorInfo($e),r.disposeIntermediateTensorInfo(ct),r.disposeIntermediateTensorInfo(lt),r.disposeIntermediateTensorInfo(st),r.disposeIntermediateTensorInfo(wt),r.disposeIntermediateTensorInfo(mt),r.disposeIntermediateTensorInfo(kt),r.disposeIntermediateTensorInfo(xt),r.disposeIntermediateTensorInfo(It),r.disposeIntermediateTensorInfo(Et),r.disposeIntermediateTensorInfo(Mt),r.disposeIntermediateTensorInfo(Dt),r.disposeIntermediateTensorInfo(Lt),r.disposeIntermediateTensorInfo(Pt),r.disposeIntermediateTensorInfo(Jt),r.disposeIntermediateTensorInfo(Gt),r.disposeIntermediateTensorInfo(nn),r.disposeIntermediateTensorInfo(Kt),r.disposeIntermediateTensorInfo(pn),{real:kn,imag:Cn}}const xa={kernelName:n.FFT,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s}=S,{input:N}=A,r=n.util.sizeFromShape(N.shape),v=N.shape[N.shape.length-1],C=cn({inputs:{x:N},backend:s,attrs:{shape:[r/v,v]}}),V=Oa(C,false,s),O=cn({inputs:{x:V},backend:s,attrs:{shape:N.shape}});return s.disposeIntermediateTensorInfo(C),s.disposeIntermediateTensorInfo(V),O}};function ta(S){const{backend:A,attrs:s}=S,{shape:N,value:r,dtype:v}=s,C=v||n.util.inferDtype(r),V=n.util.getArrayFromDType(C,n.util.sizeFromShape(N));return function(O,z,U){O.fill(z)}(V,r),A.makeTensorInfo(N,C,V)}const Mr={kernelName:n.Fill,backendName:"cpu",kernelFunc:ta};const B={kernelName:n.FlipLeftRight,backendName:"cpu",kernelFunc:({inputs:S,attrs:A,backend:s})=>{const{image:N}=S,r=s,v=n.util.getTypedArrayFromDType(N.dtype,n.util.sizeFromShape(N.shape)),[C,V,O,z]=N.shape,U=r.data.get(N.dataId).values;for(let G=0;G<C;G++){const Z=G*O*V*z;for(let ne=0;ne<V;ne++){const pe=ne*(O*z);for(let fe=0;fe<O;fe++){const ae=fe*z;for(let le=0;le<z;le++){const _e=Math.round(O-fe-1),Me=Z+pe+ae+le;let $e=U[Me];if(_e>=0&&_e<O){$e=U[Z+pe+_e*z+le]}v[Me]=$e}}}}return{dataId:r.write(v,N.shape,N.dtype),shape:N.shape,dtype:N.dtype}}},d=T((S,A)=>Math.floor(S/A)),D=ve(n.FloorDiv,d,null,"int32"),H={kernelName:n.FloorDiv,backendName:"cpu",kernelFunc:D};const j={kernelName:n.FusedConv2D,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r,filter:v,bias:C,preluActivationWeights:V}=A,{strides:O,pad:z,dataFormat:U,dilations:G,dimRoundingMode:Z,activation:ne,leakyreluAlpha:pe}=N;let fe=Xs({inputs:{x:r,filter:v},backend:s,attrs:{strides:O,pad:z,dataFormat:U,dilations:G,dimRoundingMode:Z}});if(C){const ae=fe;fe=P({inputs:{a:fe,b:C},backend:s}),s.disposeIntermediateTensorInfo(ae)}if(ne){const ae=fe;fe=Tr(s,fe,ne,V,pe),s.disposeIntermediateTensorInfo(ae)}return fe}};const de={kernelName:n.FusedDepthwiseConv2D,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r,filter:v,bias:C,preluActivationWeights:V}=A,{strides:O,pad:z,dataFormat:U,dilations:G,dimRoundingMode:Z,activation:ne,leakyreluAlpha:pe}=N;let fe=$a({inputs:{x:r,filter:v},backend:s,attrs:{strides:O,pad:z,dilations:G,dimRoundingMode:Z}});if(C){const ae=fe;fe=P({inputs:{a:fe,b:C},backend:s}),s.disposeIntermediateTensorInfo(ae)}if(ne){const ae=fe;fe=Tr(s,fe,ne,V,pe),s.disposeIntermediateTensorInfo(ae)}return fe}};const xe={kernelName:n.GatherNd,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s}=S,{params:N,indices:r}=A,v=n.util.sizeFromShape(N.shape),C=r.shape,V=C[C.length-1],[O,z,U,G]=n.backend_util.prepareAndValidate(N,r);if(0===z)return s.makeTensorInfo(O,N.dtype,[]);const Z=Ut(s.data.get(r.dataId).values,s.bufferSync(N),N.dtype,z,V,U,G,N.shape,v);return s.makeTensorInfo(O,N.dtype,Z.values)}};const Te={kernelName:n.GatherV2,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r,indices:v}=A,{axis:C,batchDims:V}=N;h([r,v],"gatherV2");let O=V;null==V&&(O=0);const z=n.util.sizeFromShape(v.shape),U=n.util.parseAxisParam(C,r.shape)[0],G=n.backend_util.segment_util.collectGatherOpShapeInfo(r,v,U,O),Z=cn({inputs:{x:r},backend:s,attrs:{shape:[G.batchSize,G.outerSize,G.dimSize,G.sliceSize]}}),ne=cn({inputs:{x:v},backend:s,attrs:{shape:[G.batchSize,z/G.batchSize]}}),pe=[G.batchSize,G.outerSize,z/G.batchSize,G.sliceSize],fe=s.bufferSync(ne),ae=Wt(s.bufferSync(Z),fe,pe);return s.disposeIntermediateTensorInfo(Z),s.disposeIntermediateTensorInfo(ne),s.makeTensorInfo(G.outputShape,ae.dtype,ae.values)}};const Je={kernelName:n.IFFT,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s}=S,{input:N}=A,r=n.util.sizeFromShape(N.shape),v=N.shape[N.shape.length-1],C=cn({inputs:{x:N},backend:s,attrs:{shape:[r/v,v]}}),V=Oa(C,true,s),O=cn({inputs:{x:V},backend:s,attrs:{shape:N.shape}});return s.disposeIntermediateTensorInfo(C),s.disposeIntermediateTensorInfo(V),O}},it=o(n.IsFinite,S=>Number.isFinite(S)?1:0,"bool"),ut={kernelName:n.IsFinite,backendName:"cpu",kernelFunc:it},Ue=o(n.IsInf,S=>Math.abs(S)===1/0?1:0,"bool"),ee={kernelName:n.IsInf,backendName:"cpu",kernelFunc:Ue},l=o(n.IsNan,S=>Number.isNaN(S)?1:0,"bool"),M={kernelName:n.IsNan,backendName:"cpu",kernelFunc:l};const X={kernelName:n.LinSpace,backendName:"cpu",kernelFunc:function(S){const{backend:A,attrs:s}=S,{start:N,stop:r,num:v}=s,C=an(N,r,v);return A.makeTensorInfo([C.length],"float32",C)}},we=o(n.Log1p,S=>Math.log1p(S)),me={kernelName:n.Log1p,backendName:"cpu",kernelFunc:we},He=T((S,A)=>S&&A),Re=ve(n.LogicalAnd,He,null,"bool"),pt={kernelName:n.LogicalAnd,backendName:"cpu",kernelFunc:Re},_=o(n.LogicalNot,S=>S?0:1,"bool"),E={kernelName:n.LogicalNot,backendName:"cpu",kernelFunc:_},$=T((S,A)=>S||A),Ee=ve(n.LogicalOr,$,null,"bool"),Le={kernelName:n.LogicalOr,backendName:"cpu",kernelFunc:Ee};const Ze={kernelName:n.LRN,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{depthRadius:v,bias:C,alpha:V,beta:O}=N;h(r,"LRN");const z=r.shape[3],U=z-1,G=s.data.get(r.dataId).values,Z=n.util.sizeFromShape(r.shape),ne=new Float32Array(Z);function pe(fe){const ae=fe%z;let le=fe-ae+Math.max(0,ae-v);const _e=fe-ae+Math.min(ae+v,U);let Me=0;for(;le<=_e;le++){const $e=G[le];Me+=$e*$e}return Me}for(let fe=0;fe<Z;fe++){const ae=pe(fe),le=G[fe]*Math.pow(C+V*ae,-O);ne[fe]=le}return s.makeTensorInfo(r.shape,r.dtype,ne)}};const qe={kernelName:n.LRNGrad,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r,y:v,dy:C}=A,{depthRadius:V,bias:O,alpha:z,beta:U}=N;h(C,"LRNGrad");const G=n.util.sizeFromShape(C.shape),Z=C.shape[3],ne=s.data.get(C.dataId).values,pe=s.data.get(r.dataId).values,fe=s.data.get(v.dataId).values,ae=new Float32Array(G),le=G;for(let _e=0;_e<le;_e++){const Me=_e%Z,$e=_e-Me+Math.max(0,Me-V),Oe=_e-Me+Math.min(Z,Me+V+1);let Ge=0;for(let nt=$e;nt<Oe;nt++)Ge+=Math.pow(pe[nt],2);Ge=z*Ge+O;for(let nt=$e;nt<Oe;nt++){let Xe=-2*z*U*pe[nt]*fe[_e]/Ge;_e===nt&&(Xe+=Math.pow(Ge,-U)),Xe*=ne[_e],ae[nt]+=Xe}}return s.makeTensorInfo(C.shape,r.dtype,ae)}};function ht(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{reductionIndices:v,keepDims:C}=N,V=s;let O=r.shape;const z=O.length,U=n.util.parseAxisParam(v,O);let G=U;const Z=n.backend_util.getAxesPermutation(G,z);let ne=V.data.get(r.dataId).values;if(null!=Z){const Me=new Array(z);for(let $e=0;$e<Me.length;$e++)Me[$e]=O[Z[$e]];ne=Gr(ne,O,r.dtype,Z,Me),G=n.backend_util.getInnerMostAxes(G.length,z),O=Me}h(r,"max"),n.backend_util.assertAxesAreInnerMostDims("max",G,z);const[pe,fe]=n.backend_util.computeOutAndReduceShapes(O,G),ae=jt(ne,n.util.sizeFromShape(fe),pe,r.dtype),le=V.write(ae,pe,r.dtype);let _e=pe;if(C){_e=n.backend_util.expandShapeToKeepDim(pe,U)}return{dataId:le,shape:_e,dtype:r.dtype}}const At={kernelName:n.Max,backendName:"cpu",kernelFunc:ht};const rn={kernelName:n.MaxPool,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A;h(r,"maxPool");const{filterSize:v,strides:C,pad:V,dimRoundingMode:O}=N;n.util.assert(n.backend_util.eitherStridesOrDilationsAreOne(C,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${C} and dilations '1'`);const z=n.backend_util.computePool2DInfo(r.shape,v,C,1,V,O);let U;if(1===z.filterWidth&&1===z.filterHeight&&n.util.arraysEqual(z.inShape,z.outShape))U=W({inputs:{x:r},backend:s});else{const G=s.data.get(r.dataId).values,Z=n.util.computeStrides(r.shape),ne=as(G,r.shape,r.dtype,Z,z,"max");U=s.makeTensorInfo(z.outShape,r.dtype,ne.values)}return U}};const ln={kernelName:n.MaxPool3D,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{filterSize:v,strides:C,pad:V,dimRoundingMode:O,dataFormat:z}=N;h(r,"maxPool3d");const U=n.backend_util.computePool3DInfo(r.shape,v,C,1,V,O,z),G=vr(s.data.get(r.dataId).values,r.shape,r.dtype,n.util.computeStrides(r.shape),U,"max");return s.makeTensorInfo(G.shape,"float32",G.values)}};const _a={kernelName:n.MaxPool3DGrad,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{dy:r,input:v}=A,{filterSize:C,strides:V,pad:O,dimRoundingMode:z}=N;h([r,v],"maxPool3DGrad");const U=n.backend_util.computePool3DInfo(v.shape,C,V,1,O,z),G=function(lt,st){const at=(0,n.buffer)(st.outShape,"int32"),ot=st.strideDepth,bt=st.strideHeight,vt=st.strideWidth,wt=st.dilationDepth,mt=st.dilationHeight,kt=st.dilationWidth,gt=st.effectiveFilterDepth,St=st.effectiveFilterHeight,xt=st.effectiveFilterWidth,It=st.padInfo.front,Et=st.padInfo.top,Mt=st.padInfo.left;for(let Dt=0;Dt<st.batchSize;++Dt)for(let Lt=0;Lt<st.inChannels;++Lt)for(let Pt=0;Pt<st.outDepth;++Pt){const Gt=Pt*ot-It;let Jt=Gt;for(;Jt<0;)Jt+=wt;const nn=Math.min(st.inDepth,gt+Gt);for(let Kt=0;Kt<st.outHeight;++Kt){const pn=Kt*bt-Et;let kn=pn;for(;kn<0;)kn+=mt;const Cn=Math.min(st.inHeight,St+pn);for(let hn=0;hn<st.outWidth;++hn){const xn=hn*vt-Mt;let _n=xn;for(;_n<0;)_n+=kt;const Vr=Math.min(st.inWidth,xt+xn);let zr=Number.NEGATIVE_INFINITY,pr=-1;for(let jn=Jt;jn<nn;jn+=wt){const ao=jn-Gt;for(let Wr=kn;Wr<Cn;Wr+=mt){const Ms=Wr-pn;for(let Cs=_n;Cs<Vr;Cs+=kt){const Ba=Cs-xn,Ta=lt.get(Dt,jn,Wr,Cs,Lt);Ta>=zr&&(zr=Ta,pr=ao*St*xt+Ms*St+Ba)}}}at.set(pr,Dt,Pt,Kt,hn,Lt)}}}return at}(s.bufferSync(v),U),Z=U.strideDepth,ne=U.strideHeight,pe=U.strideWidth,fe=U.dilationDepth,ae=U.dilationHeight,le=U.dilationWidth,_e=U.effectiveFilterDepth,Me=U.effectiveFilterHeight,$e=U.effectiveFilterWidth,Oe=_e-1-U.padInfo.front,Ge=$e-1-U.padInfo.left,nt=Me-1-U.padInfo.top,Xe=(0,n.buffer)(v.shape,"float32"),ct=s.bufferSync(r);for(let lt=0;lt<U.batchSize;++lt)for(let st=0;st<U.inChannels;++st)for(let at=0;at<U.inDepth;++at)for(let ot=0;ot<U.inHeight;++ot)for(let bt=0;bt<U.inWidth;++bt){const vt=at-Oe,wt=ot-nt,mt=bt-Ge;let kt=0;for(let gt=0;gt<_e;gt+=fe){const St=(vt+gt)/Z;if(!(St<0||St>=U.outDepth||Math.floor(St)!==St))for(let xt=0;xt<Me;xt+=ae){const It=(wt+xt)/ne;if(!(It<0||It>=U.outHeight||Math.floor(It)!==It))for(let Et=0;Et<$e;Et+=le){const Mt=(mt+Et)/pe;if(Mt<0||Mt>=U.outWidth||Math.floor(Mt)!==Mt)continue;const Dt=_e*Me*$e-1-G.get(lt,St,It,Mt,st)===gt*Me*$e+xt*$e+Et?1:0;if(0===Dt)continue;kt+=ct.get(lt,St,It,Mt,st)*Dt}}}Xe.set(kt,lt,at,ot,bt,st)}return s.makeTensorInfo(Xe.shape,Xe.dtype,Xe.values)}};const na={kernelName:n.MaxPoolGrad,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{dy:r,input:v,output:C}=A,V=v;h([v,C],"maxPoolGrad");const{filterSize:O,strides:z,pad:U,dimRoundingMode:G}=N,Z=n.backend_util.computePool2DInfo(V.shape,O,z,1,U,G),ne=s.data.get(V.dataId).values,pe=(0,n.buffer)(Z.outShape,V.dtype,wr(ne,V.shape,V.dtype,Z).values),fe=Z.strideHeight,ae=Z.strideWidth,le=Z.dilationHeight,_e=Z.dilationWidth,Me=Z.effectiveFilterHeight,$e=Z.effectiveFilterWidth,Oe=$e-1-Z.padInfo.left,Ge=Me-1-Z.padInfo.top,nt=(0,n.buffer)(V.shape,"float32"),Xe=s.data.get(r.dataId).values,ct=(0,n.buffer)(r.shape,"float32",Xe);for(let lt=0;lt<Z.batchSize;++lt)for(let st=0;st<Z.inChannels;++st)for(let at=0;at<Z.inHeight;++at)for(let ot=0;ot<Z.inWidth;++ot){const bt=at-Ge,vt=ot-Oe;let wt=0;for(let mt=0;mt<Me;mt+=le){const kt=(bt+mt)/fe;if(!(kt<0||kt>=Z.outHeight||Math.floor(kt)!==kt))for(let gt=0;gt<$e;gt+=_e){const St=(vt+gt)/ae;if(St<0||St>=Z.outWidth||Math.floor(St)!==St)continue;const xt=Me*$e-1-pe.get(lt,kt,St,st)===mt*$e+gt?1:0;if(0===xt)continue;wt+=ct.get(lt,kt,St,st)*xt}}nt.set(wt,lt,at,ot,st)}return s.makeTensorInfo(nt.shape,nt.dtype,nt.values)}};const Sa={kernelName:n.MaxPoolWithArgmax,backendName:"cpu",kernelFunc:({inputs:S,attrs:A,backend:s})=>{const{x:N}=S,{filterSize:r,strides:v,pad:C,includeBatchInIndex:V}=A,O=s;h(N,"MaxPoolWithArgmax");const z=O.data.get(N.dataId).values,U=n.backend_util.computePool2DInfo(N.shape,r,v,[1,1],C),[G,Z]=function(fe,ae,le,_e,Me){const $e=as(fe,0,le,n.util.computeStrides(ae),Me,"max"),Oe=wr(fe,ae,le,Me,true,_e);return[$e.values,Oe.values]}(z,N.shape,N.dtype,V,U),ne=O.write(G,U.outShape,N.dtype),pe=O.write(Z,U.outShape,N.dtype);return[{dataId:ne,shape:U.outShape,dtype:N.dtype},{dataId:pe,shape:U.outShape,dtype:"int32"}]}};const fo={kernelName:n.Mean,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{axis:v,keepDims:C}=N,V=n.util.parseAxisParam(v,r.shape),O=n.backend_util.computeOutAndReduceShapes(r.shape,V)[1],z=n.util.sizeFromShape(O),U=[],G=s.makeTensorInfo([],"float32",new Float32Array([z]));U.push(G);const Z=re({inputs:{x:r},backend:s,attrs:{dtype:"float32"}});U.push(Z);const ne=Ys({inputs:{a:Z,b:G},backend:s});U.push(ne);const pe=Es({inputs:{x:ne},backend:s,attrs:{axis:v,keepDims:C}});return U.forEach(fe=>s.disposeIntermediateTensorInfo(fe)),pe}};const zo={kernelName:n.Min,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{axis:v,keepDims:C}=N;h(r,"min");const V=n.util.parseAxisParam(v,r.shape);let O=V;const z=n.backend_util.getAxesPermutation(O,r.shape.length);let U=r;null!=z&&(U=$n({inputs:{x:r},backend:s,attrs:{perm:z}}),O=n.backend_util.getInnerMostAxes(O.length,r.shape.length)),n.backend_util.assertAxesAreInnerMostDims("min",O,U.shape.length);const[G,Z]=n.backend_util.computeOutAndReduceShapes(U.shape,O),ne=n.util.sizeFromShape(Z),pe=n.util.makeZerosTypedArray(n.util.sizeFromShape(G),U.dtype),fe=s.data.get(U.dataId).values;for(let le=0;le<pe.length;++le){const _e=le*ne;let Me=fe[_e];for(let $e=0;$e<ne;++$e){const Oe=fe[_e+$e];(Number.isNaN(Oe)||Oe<Me)&&(Me=Oe)}pe[le]=Me}null!=z&&s.disposeIntermediateTensorInfo(U);const ae=s.makeTensorInfo(G,U.dtype,pe);if(C){const le=cn({inputs:{x:ae},backend:s,attrs:{shape:n.backend_util.expandShapeToKeepDim(G,V)}});return s.disposeIntermediateTensorInfo(ae),le}return ae}};const Wo={kernelName:n.MirrorPad,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{paddings:v,mode:C}=N;h(r,"mirrorPad");const V=v.map((_e,Me)=>_e[0]+r.shape[Me]+_e[1]),O=v.map(_e=>_e[0]),z=v.map((_e,Me)=>_e[0]+r.shape[Me]),U="reflect"===C?0:1,G=s.data.get(r.dataId).values,Z=r.shape.length,ne=n.util.computeStrides(r.shape),pe=n.util.sizeFromShape(V),fe=V.length,ae=n.util.computeStrides(V),le=n.util.getTypedArrayFromDType(r.dtype,pe);for(let _e=0;_e<pe;_e++){let Me=n.util.indexToLoc(_e,fe,ae);for(let Oe=0;Oe<fe;Oe++)Me[Oe]<O[Oe]?Me[Oe]=2*O[Oe]-Me[Oe]-U:Me[Oe]>=z[Oe]&&(Me[Oe]=2*(z[Oe]-1)-Me[Oe]+U);Me=Me.map((Oe,Ge)=>Oe-O[Ge]);const $e=n.util.locToIndex(Me,Z,ne);le[_e]=G[$e]}return{dataId:s.write(le,V,r.dtype),shape:V,dtype:r.dtype}}},Uo=T((S,A)=>{const s=S%A;return S<0&&A<0||S>=0&&A>=0?s:(s+A)%A}),qo=ve(n.Mod,Uo),ge={kernelName:n.Mod,backendName:"cpu",kernelFunc:qo};var he=e(6377);function ce(S){const{inputs:A,backend:s,attrs:N}=S,{logits:r}=A,{dim:v}=N,C=r.shape.length;let V=v;if(-1===V&&(V=C-1),V!==C-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${C} and dim was ${V}`);const O=n.util.parseAxisParam([V],r.shape),z=ht({inputs:{x:r},backend:s,attrs:{reductionIndices:O,keepDims:false}}),U=n.backend_util.expandShapeToKeepDim(z.shape,O),G=cn({inputs:{x:z},backend:s,attrs:{shape:U}}),Z=Kn({inputs:{a:r,b:G},backend:s}),ne=Nt({inputs:{x:Z},backend:s}),pe=Es({inputs:{x:ne},backend:s,attrs:{axis:O,keepDims:false}}),fe=cn({inputs:{x:pe},backend:s,attrs:{shape:U}}),ae=Ys({inputs:{a:ne,b:fe},backend:s});return s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(Z),s.disposeIntermediateTensorInfo(ne),s.disposeIntermediateTensorInfo(pe),s.disposeIntermediateTensorInfo(fe),ae}const ye={kernelName:n.Softmax,backendName:"cpu",kernelFunc:ce};const Ne={kernelName:n.Multinomial,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{logits:r}=A,{numSamples:v,seed:C,normalized:V}=N;h(r,"multinomial");const O=V?r:ce({inputs:{logits:r},backend:s,attrs:{dim:-1}}),z=O.shape[0],U=O.shape[1],G=s.data.get(O.dataId).values,Z=[z,v],ne=n.util.makeZerosTypedArray(n.util.sizeFromShape(Z),"int32");for(let pe=0;pe<z;++pe){const fe=pe*U,ae=new Float32Array(U-1);ae[0]=G[fe];for(let Me=1;Me<ae.length;++Me)ae[Me]=ae[Me-1]+G[fe+Me];const le=he.alea(C.toString()),_e=pe*v;for(let Me=0;Me<v;++Me){const $e=le();ne[_e+Me]=ae.length;for(let Oe=0;Oe<ae.length;Oe++)if($e<ae[Oe]){ne[_e+Me]=Oe;break}}}return V||s.disposeIntermediateTensorInfo(O),s.makeTensorInfo(Z,"int32",ne)}},Se=n.kernel_impls.nonMaxSuppressionV3Impl;const Ae={kernelName:n.NonMaxSuppressionV3,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{boxes:r,scores:v}=A,{maxOutputSize:C,iouThreshold:V,scoreThreshold:O}=N;h(r,"NonMaxSuppression");const z=s.data.get(r.dataId).values,U=s.data.get(v.dataId).values,{selectedIndices:G}=Se(z,U,C,V,O);return s.makeTensorInfo([G.length],"int32",new Int32Array(G))}},Pe=n.kernel_impls.nonMaxSuppressionV4Impl;const et={kernelName:n.NonMaxSuppressionV4,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{boxes:r,scores:v}=A,{maxOutputSize:C,iouThreshold:V,scoreThreshold:O,padToMaxOutputSize:z}=N;h(r,"NonMaxSuppressionPadded");const U=s.data.get(r.dataId).values,G=s.data.get(v.dataId).values,{selectedIndices:Z,validOutputs:ne}=Pe(U,G,C,V,O,z);return[s.makeTensorInfo([Z.length],"int32",new Int32Array(Z)),s.makeTensorInfo([],"int32",new Int32Array([ne]))]}},je=n.kernel_impls.nonMaxSuppressionV5Impl;const ft={kernelName:n.NonMaxSuppressionV5,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{boxes:r,scores:v}=A,{maxOutputSize:C,iouThreshold:V,scoreThreshold:O,softNmsSigma:z}=N;h(r,"NonMaxSuppressionWithScore");const U=s.data.get(r.dataId).values,G=s.data.get(v.dataId).values,Z=C,ne=V,pe=O,fe=z,{selectedIndices:ae,selectedScores:le}=je(U,G,Z,ne,pe,fe);return[s.makeTensorInfo([ae.length],"int32",new Int32Array(ae)),s.makeTensorInfo([le.length],"float32",new Float32Array(le))]}};const Tt={kernelName:n.OneHot,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{indices:r}=A,{depth:v,onValue:C,offValue:V}=N;h(r,"oneHot");const O=n.util.sizeFromShape(r.shape),z=new Float32Array(O*v);z.fill(V);const U=s.data.get(r.dataId).values;for(let G=0;G<O;++G)U[G]>=0&&U[G]<v&&(z[G*v+U[G]]=C);return s.makeTensorInfo([...r.shape,v],"int32",z)}};function Vt(S){const{inputs:A,backend:s}=S,{x:N}=A;if("string"===N.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===N.dtype){const r=R({inputs:{input:N},backend:s}),v=Vt({inputs:{x:r},backend:s}),C=Ar({inputs:{input:N},backend:s}),V=Vt({inputs:{x:C},backend:s}),O=c({inputs:{real:v,imag:V},backend:s});return s.disposeIntermediateTensorInfo(r),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(C),s.disposeIntermediateTensorInfo(V),O}return ta({backend:s,attrs:{shape:N.shape,value:0,dtype:N.dtype}})}const bn={kernelName:n.ZerosLike,backendName:"cpu",kernelFunc:Vt};const dn={kernelName:n.OnesLike,backendName:"cpu",kernelFunc:function S(A){const{inputs:s,backend:N}=A,{x:r}=s;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const v=R({inputs:{input:r},backend:N}),C=S({inputs:{x:v},backend:N}),V=Ar({inputs:{input:r},backend:N}),O=Vt({inputs:{x:V},backend:N}),z=c({inputs:{real:C,imag:O},backend:N});return N.disposeIntermediateTensorInfo(v),N.disposeIntermediateTensorInfo(C),N.disposeIntermediateTensorInfo(V),N.disposeIntermediateTensorInfo(O),z}return ta({backend:N,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function Qt(S){const{inputs:A,backend:s,attrs:N}=S,{axis:r}=N;if(1===A.length)return Js({inputs:{input:A[0]},backend:s,attrs:{dim:r}});const v=A[0].shape,C=A[0].dtype;A.forEach(z=>{n.util.assertShapesMatch(v,z.shape,"All tensors passed to stack must have matching shapes"),n.util.assert(C===z.dtype,()=>"All tensors passed to stack must have matching dtypes")});const V=[],O=Pn({inputs:A.map(z=>{const U=Js({inputs:{input:z},backend:s,attrs:{dim:r}});return V.push(U),U}),backend:s,attrs:{axis:r}});return V.forEach(z=>s.disposeIntermediateTensorInfo(z)),O}const Rn={kernelName:n.Pack,backendName:"cpu",kernelFunc:Qt};const Zn={kernelName:n.PadV2,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{paddings:v,constantValue:C}=N;h(r,"pad");const V=v.map((le,_e)=>le[0]+r.shape[_e]+le[1]),O=v.map(le=>le[0]),z=s.data.get(r.dataId).values,U=n.util.sizeFromShape(r.shape),G=r.shape.length,Z=n.util.computeStrides(r.shape),ne=n.util.sizeFromShape(V),pe=V.length,fe=n.util.computeStrides(V),ae=n.util.getTypedArrayFromDType(r.dtype,ne);0!==C&&ae.fill(C);for(let le=0;le<U;le++){const _e=n.util.indexToLoc(le,G,Z).map((Me,$e)=>Me+O[$e]);ae[n.util.locToIndex(_e,pe,fe)]=z[le]}return{dataId:s.write(ae,V,r.dtype),shape:V,dtype:r.dtype}}},Vn=T((S,A)=>Math.pow(S,A)),Cr=ve(n.Pow,Vn),zn={kernelName:n.Pow,backendName:"cpu",kernelFunc:Cr};const Wn={kernelName:n.Range,backendName:"cpu",kernelFunc:function(S){const{backend:A,attrs:s}=S,{start:N,stop:r,dtype:v,step:C}=s,V=Kr(N,r,C,v);return A.makeTensorInfo([V.length],v,V)}},qn=o(n.Reciprocal,S=>1/S),xr={kernelName:n.Reciprocal,backendName:"cpu",kernelFunc:qn};const Hn={kernelName:n.ResizeBilinear,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{images:r}=A,{alignCorners:v,halfPixelCenters:C,size:V}=N;h(r,"resizeBilinear");const O=n.util.computeStrides(r.shape),[z,U]=V,[G,Z,ne,pe]=r.shape,fe=s.data.get(r.dataId).values,ae=new Float32Array(n.util.sizeFromShape([G,z,U,pe])),le=[v&&z>1?Z-1:Z,v&&U>1?ne-1:ne],_e=[v&&z>1?z-1:z,v&&U>1?U-1:U];let Me=0;const $e=le[0]/_e[0],Oe=le[1]/_e[1];for(let Ge=0;Ge<G;Ge++)for(let nt=0;nt<z;nt++){let Xe;Xe=C?$e*(nt+.5)-.5:$e*nt;const ct=Math.max(0,Math.floor(Xe)),lt=Xe-ct,st=Math.min(Z-1,Math.ceil(Xe)),at=Ge*O[0]+ct*O[1],ot=Ge*O[0]+st*O[1];for(let bt=0;bt<U;bt++){let vt;vt=C?Oe*(bt+.5)-.5:Oe*bt;const wt=Math.max(0,Math.floor(vt)),mt=vt-wt,kt=Math.min(ne-1,Math.ceil(vt)),gt=at+wt*O[2],St=ot+wt*O[2],xt=at+kt*O[2],It=ot+kt*O[2];for(let Et=0;Et<pe;Et++){const Mt=fe[gt+Et],Dt=fe[St+Et],Lt=Mt+(fe[xt+Et]-Mt)*mt,Pt=Lt+(Dt+(fe[It+Et]-Dt)*mt-Lt)*lt;ae[Me++]=Pt}}}return s.makeTensorInfo([G,z,U,pe],"float32",ae)}};const sr={kernelName:n.ResizeBilinearGrad,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{images:r,dy:v}=A,{alignCorners:C}=N;h([v,r],"resizeBilinearGrad");const V=n.util.computeStrides(r.shape),[O,z,U,G]=r.shape,[,Z,ne]=v.shape,pe=new Float32Array(O*z*U*G),fe=[C&&Z>1?z-1:z,C&&ne>1?U-1:U],ae=[C&&Z>1?Z-1:Z,C&&ne>1?ne-1:ne],le=fe[0]/ae[0],_e=fe[1]/ae[1],Me=s.data.get(v.dataId).values;let $e=0;for(let Oe=0;Oe<O;Oe++){const Ge=Oe*V[0];for(let nt=0;nt<Z;nt++){const Xe=nt*le,ct=Math.floor(Xe),lt=Math.min(Math.ceil(Xe),z-1),st=Ge+ct*V[1],at=Ge+lt*V[1],ot=Xe-ct,bt=1-ot;for(let vt=0;vt<ne;vt++){const wt=vt*_e,mt=Math.floor(wt),kt=Math.min(Math.ceil(wt),U-1),gt=wt-mt,St=1-gt,xt=st+mt*V[2],It=st+kt*V[2],Et=at+mt*V[2],Mt=at+kt*V[2],Dt=bt*St,Lt=bt*gt,Pt=ot*St,Gt=ot*gt;for(let Jt=0;Jt<G;Jt++){const nn=Me[$e++];pe[xt+Jt]+=nn*Dt,pe[It+Jt]+=nn*Lt,pe[Et+Jt]+=nn*Pt,pe[Mt+Jt]+=nn*Gt}}}}return s.makeTensorInfo([O,U,z,G],"float32",pe)}};const mo={kernelName:n.ResizeNearestNeighbor,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{images:r}=A,{alignCorners:v,halfPixelCenters:C,size:V}=N;h(r,"resizeNearestNeighbor");const O=n.util.computeStrides(r.shape),[z,U]=V,[G,Z,ne,pe]=r.shape,fe=s.data.get(r.dataId).values,ae=new Float32Array(G*z*U*pe),le=[v&&z>1?Z-1:Z,v&&U>1?ne-1:ne],_e=[v&&z>1?z-1:z,v&&U>1?U-1:U],Me=le[0]/_e[0],$e=le[1]/_e[1];let Oe=0;for(let Ge=0;Ge<G;Ge++){const nt=Ge*O[0];for(let Xe=0;Xe<z;Xe++){const ct=C?Me*(Xe+.5):Me*Xe;let lt=Math.min(Z-1,v?Math.round(ct):Math.floor(ct));C&&(lt=Math.max(0,lt));const st=nt+lt*O[1];for(let at=0;at<U;at++){const ot=C?$e*(at+.5):$e*at;let bt=Math.min(ne-1,v?Math.round(ot):Math.floor(ot));C&&(bt=Math.max(0,bt));const vt=st+bt*O[2];for(let wt=0;wt<pe;wt++){const mt=fe[vt+wt];ae[Oe++]=mt}}}}return s.makeTensorInfo([G,z,U,pe],r.dtype,ae)}};const go={kernelName:n.ResizeNearestNeighborGrad,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{images:r,dy:v}=A,{alignCorners:C}=N;h([v,r],"resizeNearestNeighborGrad");const V=n.util.computeStrides(r.shape),O=n.util.computeStrides(v.shape),[z,U,G,Z]=r.shape,[,ne,pe]=v.shape,fe=new Float32Array(z*U*G*Z),ae=s.data.get(v.dataId).values,le=[C&&ne>1?U-1:U,C&&pe>1?G-1:G],_e=[C&&ne>1?ne-1:ne,C&&pe>1?pe-1:pe],Me=le[0]/_e[0],$e=le[1]/_e[1],Oe=1/Me,Ge=1/$e,nt=2*Math.ceil(Oe)+2,Xe=2*Math.ceil(Ge)+2;for(let ct=0;ct<z;ct++){const lt=ct*V[0];for(let st=0;st<U;st++){const at=lt+st*V[1],ot=Math.floor(st*Oe),bt=Math.floor(ot-nt/2);for(let vt=0;vt<G;vt++){const wt=at+vt*V[2],mt=Math.floor(vt*Ge),kt=Math.floor(mt-Xe/2);for(let gt=0;gt<Z;gt++){let St=0;for(let xt=0;xt<nt;xt++){const It=xt+bt;if(It<0||It>=ne)continue;const Et=lt+It*O[1],Mt=It*Me;if(st===Math.min(U-1,C?Math.round(Mt):Math.floor(Mt)))for(let Dt=0;Dt<Xe;Dt++){const Lt=Dt+kt;if(Lt<0||Lt>=pe)continue;const Pt=Et+Lt*O[2],Gt=Lt*$e;vt===Math.min(G-1,C?Math.round(Gt):Math.floor(Gt))&&(St+=ae[Pt+gt])}}fe[wt+gt]=St}}}}return s.makeTensorInfo(r.shape,r.dtype,fe)}};const yo={kernelName:n.Reverse,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{dims:v}=N;h(r,"reverse");const C=r.shape.length,V=n.util.parseAxisParam(v,r.shape);if(0===C)return W({inputs:{x:r},backend:s});const O=new n.TensorBuffer(r.shape,r.dtype),z=s.bufferSync(r);for(let U=0;U<O.size;U++){const G=O.indexToLoc(U),Z=G.slice();V.forEach(ne=>Z[ne]=r.shape[ne]-1-Z[ne]),O.set(z.get(...Z),...G)}return s.makeTensorInfo(O.shape,O.dtype,O.values)}},_r={kernelName:n.RotateWithOffset,backendName:"cpu",kernelFunc:({inputs:S,attrs:A,backend:s})=>{const{image:N}=S,{radians:r,fillValue:v,center:C}=A,V=s,O=n.util.getTypedArrayFromDType(N.dtype,n.util.sizeFromShape(N.shape)),[z,U,G,Z]=N.shape,[ne,pe]=n.backend_util.getImageCenter(C,U,G),fe=Math.sin(r),ae=Math.cos(r),le=V.data.get(N.dataId).values;for(let _e=0;_e<z;_e++){const Me=_e*G*U*Z;for(let $e=0;$e<U;$e++){const Oe=$e*(G*Z);for(let Ge=0;Ge<G;Ge++){const nt=Ge*Z;for(let Xe=0;Xe<Z;Xe++){const ct=[z,$e,Ge,Xe],lt=ct[2],st=ct[1];let at=(lt-ne)*ae-(st-pe)*fe,ot=(lt-ne)*fe+(st-pe)*ae;at=Math.round(at+ne),ot=Math.round(ot+pe);let bt=v;if("number"!=typeof v&&(bt=3===Xe?255:v[Xe]),at>=0&&at<G&&ot>=0&&ot<U){bt=le[Me+ot*(G*Z)+at*Z+Xe]}O[Me+Oe+nt+Xe]=bt}}}}return{dataId:V.write(O,N.shape,N.dtype),shape:N.shape,dtype:N.dtype}}},ls=o(n.Round,S=>{const A=Math.floor(S);return S-A<.5?Math.floor(S):S-A>.5?Math.ceil(S):A%2==0?A:A+1}),_o={kernelName:n.Round,backendName:"cpu",kernelFunc:ls};function ii(S,A,s,N,r,v,C,V,O,z){const U=[N/r,r],G=S.values,Z=A.values;if(0===N)return(0,n.buffer)(s,A.dtype);const ne=(0,n.buffer)(U,A.dtype);ne.values.fill(O);for(let pe=0;pe<v;pe++){const fe=[];let ae=0;for(let le=0;le<C;le++){const _e=G[pe*C+le];fe.push(_e),ae+=_e*V[le]}if(ae<0||ae>=N/r)throw new Error(`Invalid indices: ${fe} does not index into ${s}`);for(let le=0;le<r;le++)z?ne.values[ae*r+le]+=Z[pe*r+le]:ne.values[ae*r+le]=0===A.rank?Z[0]:Z[pe*r+le]}return ne}const Xi={kernelName:n.ScatterNd,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{indices:r,updates:v}=A,{shape:C}=N,{sliceRank:V,numUpdates:O,sliceSize:z,strides:U,outputSize:G}=n.backend_util.calculateShapes(v,r,C),Z=ii(s.bufferSync(r),s.bufferSync(v),C,G,z,O,V,U,0,true);return s.makeTensorInfo(C,Z.dtype,Z.values)}};const Zi={kernelName:n.Select,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s}=S,{condition:N,t:r,e:v}=A;h([N,r,v],"select");const C=N.shape.length,V=s.data.get(N.dataId).values,O=s.data.get(r.dataId).values,z=s.data.get(v.dataId).values,U=(0,n.upcastType)(r.dtype,v.dtype),G=n.util.makeZerosTypedArray(n.util.sizeFromShape(r.shape),U);let Z=0;const ne=0===C||C>1||1===r.shape.length?1:n.util.sizeFromShape(r.shape.slice(1));for(let pe=0;pe<V.length;pe++)for(let fe=0;fe<ne;fe++)1===V[pe]?G[Z++]=O[pe]:G[Z++]=z[pe];return s.makeTensorInfo(r.shape,U,G)}},Qi=n.backend_util.SELU_SCALEALPHA,Ji=n.backend_util.SELU_SCALE,Yi=o(n.Selu,S=>S>=0?Ji*S:Qi*(Math.exp(S)-1)),eu={kernelName:n.Selu,backendName:"cpu",kernelFunc:Yi},tu=o(n.Sign,S=>S<0?-1:S>0?1:0),nu={kernelName:n.Sign,backendName:"cpu",kernelFunc:tu},ru=o(n.Sin,S=>Math.sin(S)),su={kernelName:n.Sin,backendName:"cpu",kernelFunc:ru},au=o(n.Sinh,S=>Math.sinh(S)),ou={kernelName:n.Sinh,backendName:"cpu",kernelFunc:au},ui=Math.log(11920928955078125e-23)+2,iu=o(n.Softplus,S=>{const A=S>-ui,s=S<ui,N=Math.exp(S);let r;return r=s?N:A?S:Math.log(1+N),r}),uu={kernelName:n.Softplus,backendName:"cpu",kernelFunc:iu};const lu={kernelName:n.SpaceToBatchND,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{blockShape:v,paddings:C}=N;h([r],"spaceToBatchND");const V=n.util.sizeFromShape(v),O=[[0,0]];O.push(...C);for(let ae=1+v.length;ae<r.shape.length;++ae)O.push([0,0]);const z=Zn.kernelFunc({inputs:{x:r},backend:s,attrs:{paddings:O,constantValue:0}}),U=n.backend_util.getReshaped(z.shape,v,V,false),G=n.backend_util.getPermuted(U.length,v.length,false),Z=n.backend_util.getReshapedPermuted(z.shape,v,V,false),ne=cn({inputs:{x:z},backend:s,attrs:{shape:U}}),pe=$n({inputs:{x:ne},backend:s,attrs:{perm:G}}),fe=cn({inputs:{x:pe},backend:s,attrs:{shape:Z}});return s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(ne),s.disposeIntermediateTensorInfo(pe),fe}};const cu={kernelName:n.SparseFillEmptyRows,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s}=S,{indices:N,values:r,denseShape:v,defaultValue:C}=A;if(1!==v.shape.length)throw new Error(`Dense shape must be a vector, saw:
        ${v.shape}`);if(2!==N.shape.length)throw new Error(`Indices must be a matrix, saw:
        ${N.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(0!==C.shape.length)throw new Error(`Default value must be a scalar, saw:
        ${C.shape}`);const V=s.data.get(N.dataId).values,O=s.data.get(r.dataId).values,z=s.data.get(v.dataId).values,U=s.data.get(C.dataId).values[0],[G,Z,ne,pe,fe]=Ps(V,N.shape,N.dtype,O,r.dtype,z,U);return[s.makeTensorInfo(Z,N.dtype,G),s.makeTensorInfo([Z[0]],r.dtype,ne),s.makeTensorInfo([pe.length],"bool",new Uint8Array(pe.map(ae=>Number(ae)))),s.makeTensorInfo([fe.length],N.dtype,new Int32Array(fe))]}};const du={kernelName:n.SparseReshape,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s}=S,{inputIndices:N,inputShape:r,newShape:v}=A;if(2!==N.shape.length)throw new Error(`Input indices should be a matrix but received shape
        ${N.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(1!==v.shape.length)throw new Error(`Target shape should be a vector but received shape ${v.shape}`);const C=Array.from(s.data.get(r.dataId).values),V=s.data.get(N.dataId).values,O=Array.from(s.data.get(v.dataId).values),[z,U,G]=ms(V,N.shape,N.dtype,C,O);return[s.makeTensorInfo(U,N.dtype,z),s.makeTensorInfo([G.length],v.dtype,new Int32Array(G))]}};const hu={kernelName:n.SparseSegmentMean,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s}=S,{data:N,indices:r,segmentIds:v}=A;if(N.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(1!==v.shape.length)throw new Error(`Segment ids should be a vector but received shape
          ${v.shape}`);const C=s.data.get(N.dataId).values,V=s.data.get(r.dataId).values,O=s.data.get(v.dataId).values,[z,U]=gr(C,N.shape,N.dtype,V,O,true);return s.makeTensorInfo(U,N.dtype,z)}};const pu={kernelName:n.SparseSegmentSum,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s}=S,{data:N,indices:r,segmentIds:v}=A;if(N.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(1!==v.shape.length)throw new Error(`Segment ids should be a vector but received shape
         ${v.shape}`);const C=s.data.get(N.dataId).values,V=s.data.get(r.dataId).values,O=s.data.get(v.dataId).values,[z,U]=gr(C,N.shape,N.dtype,V,O);return s.makeTensorInfo(U,N.dtype,z)}};const fu={kernelName:n.SparseToDense,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{sparseIndices:r,sparseValues:v,defaultValue:C}=A,{outputShape:V}=N,{sliceRank:O,numUpdates:z,sliceSize:U,strides:G,outputSize:Z}=n.backend_util.calculateShapes(v,r,V),ne=ii(s.bufferSync(r),s.bufferSync(v),V,Z,U,z,O,G,s.data.get(C.dataId).values[0],false);return s.makeTensorInfo(V,ne.dtype,ne.values)}};const mu={kernelName:n.SplitV,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{numOrSizeSplits:v,axis:C}=N,V=n.util.parseAxisParam(C,r.shape)[0],O=n.backend_util.prepareSplitSize(r,v,V),z=new Array(r.shape.length).fill(0),U=r.shape.slice();return O.map(G=>{const Z=[...U];Z[V]=G;const ne=Dn({inputs:{x:r},backend:s,attrs:{begin:z,size:Z}});return z[V]+=G,ne})}},gu={kernelName:n.Square,backendName:"cpu",kernelFunc:({inputs:S,backend:A})=>{const{x:s}=S,N=A;h(s,"square");const r=N.data.get(s.dataId).values,v=new Float32Array(r.length);for(let C=0;C<r.length;++C){const V=r[C];v[C]=V*V}return{dataId:N.write(v,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},yu=o(n.Step,(S,A)=>{const s=A;return isNaN(S)?NaN:S>0?1:s.alpha}),bu={kernelName:n.Step,backendName:"cpu",kernelFunc:yu};const ku={kernelName:n.StridedSlice,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{begin:v,end:C,strides:V,beginMask:O,endMask:z,ellipsisMask:U,newAxisMask:G,shrinkAxisMask:Z}=N;h(r,"stridedSlice");const{nonStrided:ne,$begin:pe,$strides:fe,size:ae,newShape:le,outShape:_e}=n.slice_util.sliceInfo(r.shape,v,C,V,O,z,U,G,Z),Me=cn({inputs:{x:r},backend:s,attrs:{shape:le}});let $e;if(ne){const Ge=Dn({inputs:{x:Me},backend:s,attrs:{begin:pe,size:ae}});$e=cn({inputs:{x:Ge},backend:s,attrs:{shape:_e}}),s.disposeIntermediateTensorInfo(Ge)}else if(_e.some(Ge=>0===Ge))$e=s.makeTensorInfo(_e,r.dtype,[]);else{const Ge=Jr(_e,s.bufferSync(Me),fe,pe);$e=s.makeTensorInfo(Ge.shape,Ge.dtype,Ge.values)}const Oe=cn({inputs:{x:$e},backend:s,attrs:{shape:_e}});return s.disposeIntermediateTensorInfo(Me),s.disposeIntermediateTensorInfo($e),Oe}};const wu={kernelName:n.StringNGrams,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{separator:r,nGramWidths:v,leftPad:C,rightPad:V,padWidth:O,preserveShortSequences:z}=N,{data:U,dataSplits:G}=A,Z=s.data.get(U.dataId).values,ne=s.data.get(G.dataId).values,[pe,fe]=Rs(Z,ne,r,v,C,V,O,z);return[s.makeTensorInfo([pe.length],"string",pe),s.makeTensorInfo(G.shape,"int32",fe)]}};const vu={kernelName:n.StringSplit,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{skipEmpty:r}=N,{input:v,delimiter:C}=A;if("string"!==v.dtype)throw new Error("Input must be of datatype string");if(1!==v.shape.length)throw new Error(`Input must be a vector, got shape: ${v.shape}`);if(0!==C.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${C.shape}`);const V=s.data.get(v.dataId).values,O=s.data.get(C.dataId).values[0],[z,U,G]=zs(V,O,r),Z=U.length;return[s.makeTensorInfo([Z,2],"int32",z),s.makeTensorInfo([Z],"string",U),s.makeTensorInfo([2],"int32",new Int32Array(G))]}};const Nu={kernelName:n.StringToHashBucketFast,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{numBuckets:r}=N,{input:v}=A;if("string"!==v.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const C=gs(s.data.get(v.dataId).values,r);return s.makeTensorInfo(v.shape,"int32",C)}},xu=o(n.Tan,S=>Math.tan(S)),_u={kernelName:n.Tan,backendName:"cpu",kernelFunc:xu},Su=o(n.Tanh,S=>Math.tanh(S)),Tu={kernelName:n.Tanh,backendName:"cpu",kernelFunc:Su};const Iu={kernelName:n.Tile,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{reps:v}=N;h(r,"tile");const C=ys(s.bufferSync(r),v);return s.makeTensorInfo(C.shape,C.dtype,C.values)}};const Eu={kernelName:n.TopK,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r}=A,{k:v,sorted:C}=N;h(r,"topk");const V=s.data.get(r.dataId).values,[O,z]=bs(V,r.shape,r.dtype,v,C);return[s.makeTensorInfo(O.shape,O.dtype,O.values),s.makeTensorInfo(z.shape,z.dtype,z.values)]}};const Au={kernelName:n.Transform,backendName:"cpu",kernelFunc:function(S){const{inputs:A,attrs:s,backend:N}=S,{image:r,transforms:v}=A,{interpolation:C,fillMode:V,fillValue:O,outputShape:z}=s,[U,G,Z,ne]=r.shape,[pe,fe]=null!=z?z:[G,Z],ae=[U,pe,fe,ne],le=n.util.computeStrides(r.shape),_e=le[0],Me=le[1],$e=le[2],Oe=n.util.getTypedArrayFromDType(r.dtype,n.util.sizeFromShape(ae));Oe.fill(O);const Ge=N.data.get(r.dataId).values,nt=N.data.get(v.dataId).values;for(let Xe=0;Xe<U;++Xe){const ct=1===v.shape[0]?nt:nt.subarray(8*Xe,8*Xe+8);for(let lt=0;lt<pe;++lt)for(let st=0;st<fe;++st)for(let at=0;at<ne;++at){let ot;const bt=ct[6]*st+ct[7]*lt+1;if(0===bt)continue;const vt=(ct[0]*st+ct[1]*lt+ct[2])/bt,wt=(ct[3]*st+ct[4]*lt+ct[5])/bt,mt=li(vt,Z,V),kt=li(wt,G,V);switch(C){case"nearest":ot=Mu(Ge,G,Z,_e,Me,$e,Xe,kt,mt,at,O);break;case"bilinear":ot=Cu(Ge,G,Z,_e,Me,$e,Xe,kt,mt,at,O);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${C}`)}Oe[Xe*_e+lt*Me+st*$e+at]=ot}return N.makeTensorInfo(ae,r.dtype,Oe)}return{dataId:N.write(Oe,ae,r.dtype),shape:r.shape,dtype:r.dtype}}};function li(S,A,s){switch(s){case"reflect":return function(N,r){let v=N;if(v<0)if(r<=1)v=0;else{const C=2*r;v<C&&(v=C*Math.trunc(-v/C)+v),v=v<-r?v+C:-v-1}else if(v>r-1)if(r<=1)v=0;else{const C=2*r;v-=C*Math.trunc(v/C),v>=r&&(v=C-v-1)}return n.util.clamp(0,v,r-1)}(S,A);case"wrap":return function(N,r){let v=N;if(v<0)if(r<=1)v=0;else{const C=r-1;v+=r*(Math.trunc(-v/C)+1)}else if(v>r-1)if(r<=1)v=0;else{const C=r-1;v-=r*Math.trunc(v/C)}return n.util.clamp(0,v,r-1)}(S,A);case"nearest":return function(N,r){return n.util.clamp(0,N,r-1)}(S,A);case"constant":default:return function(N,r){return N}(S)}}function bo(S,A,s,N,r,v,C,V,O,z,U){return 0<=V&&V<A&&0<=O&&O<s?S[C*N+V*r+O*v+z]:U}function Mu(S,A,s,N,r,v,C,V,O,z,U){return bo(S,A,s,N,r,v,C,Math.round(V),Math.round(O),z,U)}function Cu(S,A,s,N,r,v,C,V,O,z,U){const G=Math.floor(V),Z=Math.floor(O),ne=G+1,pe=Z+1;return(ne-V)*((pe-O)*bo(S,A,s,N,r,v,C,G,Z,z,U)+(O-Z)*bo(S,A,s,N,r,v,C,G,pe,z,U))+(V-G)*((pe-O)*bo(S,A,s,N,r,v,C,ne,Z,z,U)+(O-Z)*bo(S,A,s,N,r,v,C,ne,pe,z,U))}const $u={kernelName:n.Unique,backendName:"cpu",kernelFunc:function(S){const{inputs:A,attrs:s,backend:N}=S,{axis:r}=s,{x:v}=A;h(v,"unique");const C=N.data.get(v.dataId).values,{outputValues:V,outputShape:O,indices:z}=ks(C,r,v.shape,v.dtype);return[N.makeTensorInfo(O,v.dtype,V),N.makeTensorInfo([z.length],"int32",z)]}};const Du={kernelName:n.Unpack,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{value:r}=A;let{axis:v}=N;v<0&&(v+=r.shape.length);const C=r.shape.length,V=r.shape[v],O=new Array(C-1);let z=0;for(let ne=0;ne<C;ne++)ne!==v&&(O[z++]=r.shape[ne]);const U=new Array(C).fill(0),G=r.shape.slice();G[v]=1;const Z=new Array(V);for(let ne=0;ne<Z.length;ne++){U[v]=ne;const pe=Dn({inputs:{x:r},backend:s,attrs:{begin:U,size:G}});Z[ne]=cn({inputs:{x:pe},backend:s,attrs:{shape:O}}),s.disposeIntermediateTensorInfo(pe)}return Z}};const Fu={kernelName:n.UnsortedSegmentSum,backendName:"cpu",kernelFunc:function(S){const{inputs:A,backend:s,attrs:N}=S,{x:r,segmentIds:v}=A,{numSegments:C}=N;h(r,"unsortedSegmentSum");const V=[],O=[],z=r.shape.length-v.shape.length;let U=v;for(let Z=0;Z<z;++Z){const ne=Js({inputs:{input:U},backend:s,attrs:{dim:Z+1}});U=ne,O.push(ne)}for(let Z=0;Z<C;++Z){const ne=n.util.createScalarValue(Z,"int32"),pe=s.makeTensorInfo([],"int32",ne),fe=rt({inputs:{a:pe,b:U},backend:s}),ae=re({inputs:{x:fe},backend:s,attrs:{dtype:"float32"}}),le=Jn({inputs:{a:ae,b:r},backend:s}),_e=Es({inputs:{x:le},backend:s,attrs:{axis:0,keepDims:false}});V.push(_e),O.push(pe),O.push(fe),O.push(ae),O.push(le),O.push(_e)}const G=Qt({inputs:V,backend:s,attrs:{axis:0}});return O.forEach(Z=>s.disposeIntermediateTensorInfo(Z)),G}},Ou=[la,I,da,qs,f,ha,Hs,xs,Bt,on,Zt,Xn,br,Pr,un,pa,js,Rr,hr,Lr,os,is,us,Ie,J,ze,Er,p,Ca,Ks,Nr,Zs,_s,ga,rr,ma,Ts,Ua,qa,Ha,ja,Ga,Ka,ya,Xa,Is,Qs,Za,ba,ea,ka,Ws,wa,Qe,va,$t,no,zt,xa,Mr,B,qt,H,j,de,xe,Te,Y,We,L,Je,fa,ut,ee,M,Us,dt,fn,X,Xt,me,pt,E,Le,Ze,qe,An,rn,ln,_a,na,Sa,At,fo,zo,wn,Wo,ge,Ne,Hr,Ds,Ae,et,ft,jr,Tt,dn,Rn,Zn,zn,Br,Bs,Wn,K,xr,cr,ua,rs,Hn,sr,mo,go,yo,_r,_o,ps,Xi,Zi,eu,Ls,nu,su,ou,Sr,ye,uu,lu,cu,du,hu,pu,fu,mu,Ce,gu,yr,bu,ku,wu,vu,Nu,es,As,_u,Tu,Iu,Eu,Fs,Au,$u,Du,Fu,bn];for(const S of Ou)(0,n.registerKernel)(S)},4933:(b,u,e)=>{e.r(u),e.d(u,{GraphModel:()=>it,deregisterOp:()=>se,loadGraphModel:()=>ut,registerOp:()=>Q,version_converter:()=>Ue});var g={};e.r(g),e.d(g,{json:()=>rt});var n={};e.r(n),e.d(n,{json:()=>Qe});var h={};e.r(h),e.d(h,{json:()=>tt});var i={};e.r(i),e.d(i,{json:()=>Nt});var w={};e.r(w),e.d(w,{json:()=>$t});var k={};e.r(k),e.d(k,{json:()=>Ct});var I={};e.r(I),e.d(I,{json:()=>Ot});var T={};e.r(T),e.d(T,{json:()=>zt});var c={};e.r(c),e.d(c,{json:()=>Ht});var p={};e.r(p),e.d(p,{json:()=>tn});var y={};e.r(y),e.d(y,{json:()=>qt});var W={};e.r(W),e.d(W,{json:()=>Ut});var L={};e.r(L),e.d(L,{json:()=>Wt});var R={};e.r(R),e.d(R,{json:()=>Be});var K={};e.r(K),e.d(K,{json:()=>Fe});var re={};e.r(re),e.d(re,{json:()=>Y});var J={};e.r(J),e.d(J,{json:()=>be});var ve={};e.r(ve),e.d(ve,{json:()=>ke});var ue={};e.r(ue),e.d(ue,{json:()=>We});var ie,F,P=e(5363);!function(ee){ee[ee.DT_INVALID=0]="DT_INVALID",ee[ee.DT_FLOAT=1]="DT_FLOAT",ee[ee.DT_DOUBLE=2]="DT_DOUBLE",ee[ee.DT_INT32=3]="DT_INT32",ee[ee.DT_UINT8=4]="DT_UINT8",ee[ee.DT_INT16=5]="DT_INT16",ee[ee.DT_INT8=6]="DT_INT8",ee[ee.DT_STRING=7]="DT_STRING",ee[ee.DT_COMPLEX64=8]="DT_COMPLEX64",ee[ee.DT_INT64=9]="DT_INT64",ee[ee.DT_BOOL=10]="DT_BOOL",ee[ee.DT_QINT8=11]="DT_QINT8",ee[ee.DT_QUINT8=12]="DT_QUINT8",ee[ee.DT_QINT32=13]="DT_QINT32",ee[ee.DT_BFLOAT16=14]="DT_BFLOAT16",ee[ee.DT_FLOAT_REF=101]="DT_FLOAT_REF",ee[ee.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",ee[ee.DT_INT32_REF=103]="DT_INT32_REF",ee[ee.DT_UINT8_REF=104]="DT_UINT8_REF",ee[ee.DT_INT16_REF=105]="DT_INT16_REF",ee[ee.DT_INT8_REF=106]="DT_INT8_REF",ee[ee.DT_STRING_REF=107]="DT_STRING_REF",ee[ee.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",ee[ee.DT_INT64_REF=109]="DT_INT64_REF",ee[ee.DT_BOOL_REF=110]="DT_BOOL_REF",ee[ee.DT_QINT8_REF=111]="DT_QINT8_REF",ee[ee.DT_QUINT8_REF=112]="DT_QUINT8_REF",ee[ee.DT_QINT32_REF=113]="DT_QINT32_REF",ee[ee.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(ie||(ie={})),function(ee){!function(l){l[l.LEGACY=0]="LEGACY",l[l.V1=1]="V1",l[l.V2=2]="V2"}(ee.CheckpointFormatVersion||(ee.CheckpointFormatVersion={}))}(F||(F={}));const f={};function Q(ee,l){const M={tfOpName:ee,category:"custom",inputs:[],attrs:[],customExecutor:l};f[ee]=M}function oe(ee){return f[ee]}function se(ee){delete f[ee]}function o(ee,l,M,X,we){const me=l.inputParams[ee];if(me&&void 0!==me.inputIndexStart){const Re=me.inputIndexStart,pt=0===me.inputIndexEnd?void 0:void 0===me.inputIndexEnd?Re+1:me.inputIndexEnd;if("tensor"===me.type)return te(l.inputNames[me.inputIndexStart],M,X,we);if("tensors"===me.type){return l.inputNames.slice(Re,pt).map($=>te($,M,X,we))}const _=te(l.inputNames.slice(Re)[0],M,X,we),E=_.dataSync();return"number"===me.type?E[0]:P.util.toNestedArray(_.shape,E)}const He=l.attrParams[ee];return He&&He.value}function te(ee,l,M,X){const[we,me]=ze(ee);if(null!=X){const Re=X.getHashTableHandleByName(we);if(null!=Re)return Re}const He=M.currentContextIds.find(Re=>!!l[Ve(we,Re)]);return void 0!==He?l[Ve(we,He)][me]:void 0}function De(ee,l){const[M,X,we]=ze(ee);return[Ve(M,l&&l.currentContextId),X,we]}function Ve(ee,l){return l?`${ee}-${l}`:ee}function ze(ee){const l=ee.split(":");if(1===l.length)return[ee,0,void 0];const M=l[0],X=3===l.length?l[1]:void 0;return[M,Number(l[l.length-1]),X]}function Ke(ee,l,M){let X=o("pad",ee,l,M);if("explicit"===X){X=o("explicitPaddings",ee,l,M);const we=[[0,0],[0,0],[0,0],[0,0]];for(let me=0;me<4;me++)we[me][0]=X[2*me],we[me][1]=X[2*me+1];return we}return X}function Ye(ee){return ee.kept?ee:(0,P.clone)(ee)}const rt=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]}],Qe=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:true}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:true}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:true},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]}],tt=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:true}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],Nt=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:true},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:true},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:true}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],$t=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:true},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:true},{tfName:"T",name:"T",type:"number",notSupported:true}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:true},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:true}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Ct=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:true},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]}],Ot=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],zt=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:true},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Ht=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:true},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:true}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:true},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:true}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:true},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:true}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:true},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:true}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],tn=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],qt=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]}],Ut=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:false},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:false},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:false},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:false},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:false},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:false},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:false},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:false},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],Wt=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:true,notSupported:true}]}],Be=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Fe=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:true}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:true}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:false,notSupported:true}]}],Y=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],be=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:true}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:true}]}],ke=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],We=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:true},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class yt{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const l=[].concat(...[g,n,h,i,w,k,I,T,c,p,y,W,L,R,K,re,J,ve,ue].map(M=>M.json));this.opMappers=l.reduce((M,X)=>(M[X.tfOpName]=X,M),{})}transformGraph(l,M={}){const X=l.node,we=[],me=[],He=[],Re=X.reduce((qe,ht)=>(qe[ht.name]=this.mapNode(ht),ht.op.startsWith("Placeholder")?we.push(qe[ht.name]):"Const"===ht.op?me.push(qe[ht.name]):null!=ht.input&&0!==ht.input.length||He.push(qe[ht.name]),qe),{});let pt=[];const _=[];let E={},$={};null!=M&&(E=this.mapSignatureEntries(M.inputs),$=this.mapSignatureEntries(M.outputs));const Ee=Object.keys(Re);Ee.forEach(qe=>{const ht=Re[qe];ht.inputNames.forEach((At,rn)=>{const[ln,,_a]=De(At),na=Re[ln];if(null!=na.outputs){const Sa=na.outputs.indexOf(_a);if(-1!==Sa){const fo=`${ln}:${Sa}`;ht.inputNames[rn]=fo}}ht.inputs.push(na),na.children.push(ht)})}),0===Object.keys($).length?Ee.forEach(qe=>{const ht=Re[qe];0===ht.children.length&&_.push(ht)}):Object.keys($).forEach(qe=>{const[ht]=De(qe),At=Re[ht];null!=At&&(At.signatureKey=$[qe],_.push(At))}),Object.keys(E).length>0?Object.keys(E).forEach(qe=>{const[ht]=De(qe),At=Re[ht];At&&(At.signatureKey=E[qe],pt.push(At))}):pt=we;let Le={};null!=l.library&&null!=l.library.function&&(Le=l.library.function.reduce((qe,ht)=>(qe[ht.signature.name]=this.mapFunction(ht),qe),{}));const Ze={nodes:Re,inputs:pt,outputs:_,weights:me,placeholders:we,signature:M,functions:Le};return He.length>0&&(Ze.initNodes=He),Ze}mapSignatureEntries(l){return Object.keys(l||{}).reduce((M,X)=>(M[l[X].name]=X,M),{})}mapNode(l){const M=oe(l.op)||this.opMappers[l.op]||{};null==l.attr&&(l.attr={});const X={name:l.name,op:l.op,category:M.category,inputNames:(l.input||[]).map(we=>we.startsWith("^")?we.substr(1):we),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:l.attr,outputs:M.outputs};return null!=M.inputs&&(X.inputParams=M.inputs.reduce((we,me)=>(we[me.name]={type:me.type,inputIndexStart:me.start,inputIndexEnd:me.end},we),{})),null!=M.attrs&&(X.attrParams=M.attrs.reduce((we,me)=>{const He=me.type;let Re;switch(me.type){case"string":Re=dt(l.attr,me.tfName,me.defaultValue),void 0===Re&&me.tfDeprecatedName&&(Re=dt(l.attr,me.tfDeprecatedName,me.defaultValue));break;case"string[]":Re=yn(l.attr,me.tfName,me.defaultValue),void 0===Re&&me.tfDeprecatedName&&(Re=yn(l.attr,me.tfDeprecatedName,me.defaultValue));break;case"number":Re=Yt(l.attr,me.tfName,me.defaultValue||0),void 0===Re&&me.tfDeprecatedName&&(Re=Yt(l.attr,me.tfDeprecatedName,me.defaultValue));break;case"number[]":Re=Nn(l.attr,me.tfName,me.defaultValue),void 0===Re&&me.tfDeprecatedName&&(Re=Nn(l.attr,me.tfDeprecatedName,me.defaultValue));break;case"bool":Re=Ft(l.attr,me.tfName,me.defaultValue),void 0===Re&&me.tfDeprecatedName&&(Re=Ft(l.attr,me.tfDeprecatedName,me.defaultValue));break;case"bool[]":Re=vn(l.attr,me.tfName,me.defaultValue),void 0===Re&&me.tfDeprecatedName&&(Re=vn(l.attr,me.tfDeprecatedName,me.defaultValue));break;case"shape":Re=jt(l.attr,me.tfName,me.defaultValue),void 0===Re&&me.tfDeprecatedName&&(Re=jt(l.attr,me.tfDeprecatedName,me.defaultValue));break;case"shape[]":Re=An(l.attr,me.tfName,me.defaultValue),void 0===Re&&me.tfDeprecatedName&&(Re=An(l.attr,me.tfDeprecatedName,me.defaultValue));break;case"dtype":Re=gn(l.attr,me.tfName,me.defaultValue),void 0===Re&&me.tfDeprecatedName&&(Re=gn(l.attr,me.tfDeprecatedName,me.defaultValue));break;case"dtype[]":Re=Rt(l.attr,me.tfName,me.defaultValue),void 0===Re&&me.tfDeprecatedName&&(Re=Rt(l.attr,me.tfDeprecatedName,me.defaultValue));break;case"func":Re=an(l.attr,me.tfName,me.defaultValue),void 0===Re&&me.tfDeprecatedName&&(Re=an(l.attr,me.tfDeprecatedName,me.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${me.type} for op: ${l.op}`)}return we[me.name]={value:Re,type:He},we},{})),X}mapFunction(l){const M=l.nodeDef,X=[];let we={};null!=M&&(we=M.reduce((_,E)=>(_[E.name]=this.mapNode(E),"Const"===E.op&&X.push(_[E.name]),_),{}));const me=[],He=[];l.signature.inputArg.forEach(_=>{const[E]=De(_.name),$={name:E,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:fn(_.type),type:"dtype"}},children:[]};$.signatureKey=_.name,me.push($),we[E]=$});Object.keys(we).forEach(_=>{const E=we[_];E.inputNames.forEach(($,Ee)=>{const[Le,,Ze]=De($),qe=we[Le];if(null!=qe.outputs){const ht=qe.outputs.indexOf(Ze);if(-1!==ht){const At=`${Le}:${ht}`;E.inputNames[Ee]=At}}E.inputs.push(qe),qe.children.push(E)})});const Re=l.ret;l.signature.outputArg.forEach(_=>{const[E,$]=De(Re[_.name]),Ee=we[E];null!=Ee&&(Ee.defaultOutput=$,He.push(Ee))});const pt=this.mapArgsToSignature(l);return{nodes:we,inputs:me,outputs:He,weights:X,placeholders:[],signature:pt}}mapArgsToSignature(l){return{methodName:l.signature.name,inputs:l.signature.inputArg.reduce((M,X)=>(M[X.name]=this.mapArgToTensorInfo(X),M),{}),outputs:l.signature.outputArg.reduce((M,X)=>(M[X.name]=this.mapArgToTensorInfo(X,l.ret),M),{})}}mapArgToTensorInfo(l,M){let X=l.name;return null!=M&&(X=M[X]),{name:X,dtype:l.type}}}function _t(ee,l){const M=Array.isArray(ee)?String.fromCharCode.apply(null,ee):function(X){const we=(0,P.env)().global;if(void 0!==we.atob)return we.atob(X);if("undefined"!=typeof Buffer)return new Buffer(X,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(ee);return l?M:M.toLowerCase()}function dt(ee,l,M,X=false){const we=ee[l];return null!=we?_t(we.s,X):M}function Ft(ee,l,M){const X=ee[l];return X?X.b:M}function Yt(ee,l,M){const X=ee[l]||{},we=null!=X.i?X.i:null!=X.f?X.f:M;return"number"==typeof we?we:parseInt(we,10)}function fn(ee){switch("string"==typeof ee&&(ee=ie[ee]),ee){case ie.DT_FLOAT:return"float32";case ie.DT_INT32:case ie.DT_INT64:case ie.DT_INT8:case ie.DT_UINT8:return"int32";case ie.DT_BOOL:return"bool";case ie.DT_DOUBLE:return"float32";case ie.DT_STRING:return"string";default:return null}}function an(ee,l,M){const X=ee[l];return X&&X.func?X.func.name:M}function gn(ee,l,M){const X=ee[l];return X&&X.type?fn(X.type):M}function Rt(ee,l,M){const X=ee[l];return X&&X.list&&X.list.type?X.list.type.map(we=>fn(we)):M}function Xt(ee){if(!ee.unknownRank)return null!=ee.dim?ee.dim.map(l=>"number"==typeof l.size?l.size:parseInt(l.size,10)):[]}function jt(ee,l,M){const X=ee[l];return X&&X.shape?Xt(X.shape):M}function Nn(ee,l,M){const X=ee[l];return X?((X.list.f&&X.list.f.length?X.list.f:X.list.i)||[]).map(we=>"number"==typeof we?we:parseInt(we,10)):M}function yn(ee,l,M,X=false){const we=ee[l];return we&&we.list&&we.list.s?we.list.s.map(me=>_t(me,X)):M}function An(ee,l,M){const X=ee[l];return X&&X.list&&X.list.shape?X.list.shape.map(we=>Xt(we)):M}function vn(ee,l,M){const X=ee[l];return X&&X.list&&X.list.b?X.list.b:M}class Tn{constructor(l,M,X){this.node=l,this.tensorMap=M,this.context=X,this.inputs=[],this.attrs={},this.inputs=l.inputNames.map(we=>this.getInput(we)),null!=l.rawAttrs&&(this.attrs=Object.keys(l.rawAttrs).reduce((we,me)=>(we[me]=this.getAttr(me),we),{}))}getInput(l){return te(l,this.tensorMap,this.context)}getAttr(l,M){const X=this.node.rawAttrs[l];if(null!=X.tensor)return te(l,this.tensorMap,this.context);if(null!=X.i||null!=X.f)return Yt(this.node.rawAttrs,l,M);if(null!=X.s)return dt(this.node.rawAttrs,l,M);if(null!=X.b)return Ft(this.node.rawAttrs,l,M);if(null!=X.shape)return jt(this.node.rawAttrs,l,M);if(null!=X.type)return gn(this.node.rawAttrs,l,M);if(null!=X.list){if(null!=X.list.i||null!=X.list.f)return Nn(this.node.rawAttrs,l,M);if(null!=X.list.s)return yn(this.node.rawAttrs,l,M);if(null!=X.list.shape)return An(this.node.rawAttrs,l,M);if(null!=X.list.b)return vn(this.node.rawAttrs,l,M);if(null!=X.list.type)return Rt(this.node.rawAttrs,l,M)}return M}}var wn=e(6407),Mn=e(3135),fr=e(5228),Jn=e(4841),Hr=e(1274),ir=e(9322),Ds=e(9165),hs=e(827),ur=e(4513),jr=e(632),Gr=e(3453),$n=e(5265);var Fs=e(6235),Os=e(7839),Bs=e(1470),Kr=e(2421),Xr=e(1891),Zr=e(7037),ps=e(9812),oa=e(369),mr=e(6825),Ls=e(1661),fs=e(173),Dn=e(2699),Sr=e(3233),Ps=e(4650),ms=e(4842),gr=e(3426),Dr=e(6943),sn=e(2597),Ce=e(7474),Gn=e(4386),Qr=e(7370),yr=e(9036),Jr=e(766),ia=e(7409),Rs=e(7809),Vs=e(5503),zs=e(625),gs=e(9331),Fr=e(4434),Yr=e(3254),Kn=e(3694),es=e(3261),ys=e(248),lr=e(1869),ts=e(1173),bs=e(2279),ks=e(3582),Or=e(2634),ns=e(9451),Ws=e(9133),ws=e(8151),Us=e(6230);function Un(ee,l,M=""){if("number"!=typeof ee&&"number"!=typeof l){P.util.assert(ee.length===l.length,()=>M+` Shapes ${ee} and ${l} must match`);for(let X=0;X<ee.length;X++){const we=ee[X],me=l[X];P.util.assert(we<0||me<0||we===me,()=>M+` Shapes ${ee} and ${l} must match`)}}}function vs(ee){return"number"!=typeof ee&&!ee.some(l=>l<0)}function Br(ee,l,M){let X=nr(ee,M);const we=!vs(X);if(we&&0===l.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${X}`);if(we&&l.forEach(me=>{X=nr(me.shape,X)}),!vs(X))throw new Error(`Non-fully-defined elementShape: ${X}`);return X}function nr(ee,l){if("number"==typeof ee)return l;if("number"==typeof l)return ee;if(ee.length!==l.length)throw new Error(`Incompatible ranks during merge: ${ee} vs. ${l}`);const M=[];for(let X=0;X<ee.length;++X){const we=ee[X],me=l[X];if(we>=0&&me>=0&&we!==me)throw new Error(`Incompatible shape during merge: ${ee} vs. ${l}`);M[X]=we>=0?we:me}return M}class cr{constructor(l,M,X,we,me,He,Re){this.name=l,this.dtype=M,this.maxSize=X,this.elementShape=we,this.identicalElementShapes=me,this.dynamicSize=He,this.clearAfterRead=Re,this.tensors=[],this.closed_=false,this.idTensor=(0,P.scalar)(0),(0,P.keep)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(l){this.tensors.forEach(M=>{null!=l&&l.has(M.tensor.id)||M.tensor.dispose()}),this.tensors=[],this.closed_=true,this.idTensor.dispose()}size(){return this.tensors.length}read(l){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(l<0||l>=this.size())throw new Error(`Tried to read from index ${l}, but array size is: ${this.size()}`);const M=this.tensors[l];if(M.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${l} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(M.cleared=true),M.read=true,M.tensor}readMany(l){return l.map(M=>this.read(M))}write(l,M){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(l<0||!this.dynamicSize&&l>=this.maxSize)throw new Error(`Tried to write to index ${l}, but array is not resizeable and size is: ${this.maxSize}`);const X=this.tensors[l]||{};if(M.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${l},
          because the value dtype is ${M.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=M.shape),Un(this.elementShape,M.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${l}.`),X.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${l}, because it has already been read.`);if(X.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${l}, because it has already been written.`);X.tensor=M,(0,P.keep)(M),X.written=true,this.tensors[l]=X}writeMany(l,M){if(l.length!==M.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${l.length} is not the same as tensors size: ${M.length}.`);l.forEach((X,we)=>this.write(X,M[we]))}gather(l,M){if(M&&M!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${M}`);if(l)l=l.slice(0,this.size());else{l=[];for(let we=0;we<this.size();we++)l.push(we)}if(0===l.length)return(0,P.tensor)([],[0].concat(this.elementShape));const X=this.readMany(l);return Un(this.elementShape,X[0].shape,"TensorArray shape mismatch: "),(0,P.stack)(X,0)}concat(l){if(l&&l!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${l}`);if(0===this.size())return(0,P.tensor)([],[0].concat(this.elementShape));const M=[];for(let we=0;we<this.size();we++)M.push(we);const X=this.readMany(M);return Un(this.elementShape,X[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${X[0].shape})`),(0,P.concat)(X,0)}scatter(l,M){if(M.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${M.dtype}`);if(l.length!==M.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${l.length} vs. ${M.shape[0]}`);const X=Math.max(...l);if(!this.dynamicSize&&X>=this.maxSize)throw new Error(`Max index must be < array size (${X}  vs. ${this.maxSize})`);this.writeMany(l,(0,P.unstack)(M,0))}split(l,M){if(M.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${M.dtype}`);let X=0;const we=l.map(pt=>(X+=pt,X));if(X!==M.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${X}, and tensor's shape is: ${M.shape}`);if(!this.dynamicSize&&l.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${l.length}), and the TensorArray is not marked as dynamically resizeable`);const me=0===X?0:M.size/X,He=[];(0,P.tidy)(()=>{M=(0,P.reshape)(M,[1,X,me]);for(let pt=0;pt<l.length;++pt){const _=[0,0===pt?0:we[pt-1],0],E=[1,l[pt],me];He[pt]=(0,P.reshape)((0,P.slice)(M,_,E),this.elementShape)}return He});const Re=[];for(let pt=0;pt<l.length;pt++)Re[pt]=pt;this.writeMany(Re,He)}}class Fn{constructor(l,M,X,we=-1){this.tensors=l,this.elementShape=M,this.elementDtype=X,null!=l&&l.forEach(me=>{if(X!==me.dtype)throw new Error(`Invalid data types; op elements ${X}, but list elements ${me.dtype}`);Un(M,me.shape,"TensorList shape mismatch: "),(0,P.keep)(me)}),this.idTensor=(0,P.scalar)(0),this.maxNumElements=we,(0,P.keep)(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Fn([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(l){this.tensors.forEach(M=>{null!=l&&l.has(M.id)||M.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(l,M,X=-1){if(M!==this.elementDtype)throw new Error(`Invalid data types; op elements ${M}, but list elements ${this.elementDtype}`);if(-1!==X&&this.tensors.length!==X)throw new Error(`Operation expected a list with ${X} elements but got a list with ${this.tensors.length} elements.`);Un(l,this.elementShape,"TensorList shape mismatch: ");const we=Br(this.elementShape,this.tensors,l);return(0,P.tidy)(()=>{const me=this.tensors.map(He=>(0,P.reshape)(He,we));return(0,P.stack)(me,0)})}popBack(l,M){if(M!==this.elementDtype)throw new Error(`Invalid data types; op elements ${M}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const X=Br(this.elementShape,this.tensors,l),we=this.tensors.pop();return Un(we.shape,l,"TensorList shape mismatch: "),(0,P.reshape)(we,X)}pushBack(l){if(l.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${l.dtype}, but list elements ${this.elementDtype}`);if(Un(l.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");(0,P.keep)(l),this.tensors.push(l)}resize(l){if(l<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${l}`);if(-1!==this.maxNumElements&&l>this.maxNumElements)throw new Error(`TensorListResize input size ${l} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=l}getItem(l,M,X){if(X!==this.elementDtype)throw new Error(`Invalid data types; op elements ${X}, but list elements ${this.elementDtype}`);if(l<0||l>this.tensors.length)throw new Error(`Trying to access element ${l} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[l])throw new Error(`element at index ${l} is null.`);Un(this.tensors[l].shape,M,"TensorList shape mismatch: ");const we=Br(this.elementShape,this.tensors,M);return(0,P.reshape)(this.tensors[l],we)}setItem(l,M){if(M.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${M.dtype}, but list elements ${this.elementDtype}`);if(l<0||-1!==this.maxNumElements&&l>=this.maxNumElements)throw new Error(`Trying to set element ${l} in a list with max ${this.maxNumElements} elements.`);Un(this.elementShape,M.shape,"TensorList shape mismatch: "),(0,P.keep)(M),this.tensors[l]=M}gather(l,M,X){if(M!==this.elementDtype)throw new Error(`Invalid data types; op elements ${M}, but list elements ${this.elementDtype}`);Un(this.elementShape,X,"TensorList shape mismatch: "),l=l.slice(0,this.size());const we=Br(this.elementShape,this.tensors,X);return 0===l.length?(0,P.tensor)([],[0].concat(we)):(0,P.tidy)(()=>{const me=l.map(He=>(0,P.reshape)(this.tensors[He],we));return(0,P.stack)(me,0)})}concat(l,M){if(l&&l!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${l}`);Un(this.elementShape,M,"TensorList shape mismatch: ");const X=Br(this.elementShape,this.tensors,M);return 0===this.size()?(0,P.tensor)([],[0].concat(X)):(0,P.tidy)(()=>{const we=this.tensors.map(me=>(0,P.reshape)(me,X));return(0,P.concat)(we,0)})}}const ua=async(ee,l,M)=>{switch(ee.op){case"If":case"StatelessIf":{const X=o("thenBranch",ee,l,M),we=o("elseBranch",ee,l,M),me=o("cond",ee,l,M),He=o("args",ee,l,M);return(await me.data())[0]?M.functionMap[X].executeFunctionAsync(He,M.tensorArrayMap,M.tensorListMap):M.functionMap[we].executeFunctionAsync(He,M.tensorArrayMap,M.tensorListMap)}case"While":case"StatelessWhile":{const X=o("body",ee,l,M),we=o("cond",ee,l,M),me=o("args",ee,l,M),He=await M.functionMap[we].executeFunctionAsync(me,M.tensorArrayMap,M.tensorListMap),Re=me.map(E=>E.id);let pt=await He[0].data();He.forEach(E=>{E.kept||-1!==Re.indexOf(E.id)||E.dispose()});let _=me;for(;pt[0];){const E=_;_=await M.functionMap[X].executeFunctionAsync(_,M.tensorArrayMap,M.tensorListMap);const $=_.map(Le=>Le.id);E.forEach(Le=>{Le.kept||-1!==Re.indexOf(Le.id)||-1!==$.indexOf(Le.id)||Le.dispose()});const Ee=await M.functionMap[we].executeFunctionAsync(_,M.tensorArrayMap,M.tensorListMap);pt=await Ee[0].data(),Ee.forEach(Le=>{Le.kept||-1!==Re.indexOf(Le.id)||-1!==$.indexOf(Le.id)||Le.dispose()})}return _}case"LoopCond":return[Ye(o("pred",ee,l,M))];case"Switch":{const X=o("pred",ee,l,M);let we=o("data",ee,l,M);return we.kept||(we=Ye(we)),(await X.data())[0]?[void 0,we]:[we,void 0]}case"Merge":{const X=ee.inputNames.find(we=>void 0!==te(we,l,M));if(X){return[Ye(te(X,l,M))]}return}case"Enter":{const X=o("frameName",ee,l,M),we=o("tensor",ee,l,M);return M.enterFrame(X),[Ye(we)]}case"Exit":{const X=o("tensor",ee,l,M);return M.exitFrame(),[Ye(X)]}case"NextIteration":{const X=o("tensor",ee,l,M);return M.nextIteration(),[Ye(X)]}case"TensorArrayV3":{const X=o("size",ee,l,M),we=o("dtype",ee,l,M),me=o("elementShape",ee,l,M),He=o("dynamicSize",ee,l,M),Re=o("clearAfterRead",ee,l,M),pt=o("identicalElementShapes",ee,l,M),_=o("name",ee,l,M),E=new cr(_,we,X,me,pt,He,Re);return M.addTensorArray(E),[E.idTensor,(0,P.scalar)(1)]}case"TensorArrayWriteV3":{const X=o("tensorArrayId",ee,l,M),we=o("index",ee,l,M),me=o("tensor",ee,l,M),He=M.getTensorArray(X.id);return He.write(we,me),[He.idTensor]}case"TensorArrayReadV3":{const X=o("tensorArrayId",ee,l,M),we=o("index",ee,l,M);return[M.getTensorArray(X.id).read(we)]}case"TensorArrayGatherV3":{const X=o("tensorArrayId",ee,l,M),we=o("indices",ee,l,M),me=o("dtype",ee,l,M);return[M.getTensorArray(X.id).gather(we,me)]}case"TensorArrayScatterV3":{const X=o("tensorArrayId",ee,l,M),we=o("indices",ee,l,M),me=o("tensor",ee,l,M),He=M.getTensorArray(X.id);return He.scatter(we,me),[He.idTensor]}case"TensorArrayConcatV3":{const X=o("tensorArrayId",ee,l,M),we=M.getTensorArray(X.id),me=o("dtype",ee,l,M);return[we.concat(me)]}case"TensorArraySplitV3":{const X=o("tensorArrayId",ee,l,M),we=o("tensor",ee,l,M),me=o("lengths",ee,l,M),He=M.getTensorArray(X.id);return He.split(me,we),[He.idTensor]}case"TensorArraySizeV3":{const X=o("tensorArrayId",ee,l,M),we=M.getTensorArray(X.id);return[(0,P.scalar)(we.size(),"int32")]}case"TensorArrayCloseV3":{const X=o("tensorArrayId",ee,l,M),we=M.getTensorArray(X.id);return we.clearAndClose(),[we.idTensor]}case"TensorListSetItem":{const X=o("tensorListId",ee,l,M),we=o("index",ee,l,M),me=o("tensor",ee,l,M),He=M.getTensorList(X.id);return He.setItem(we,me),[He.idTensor]}case"TensorListGetItem":{const X=o("tensorListId",ee,l,M),we=o("index",ee,l,M),me=o("elementShape",ee,l,M),He=o("elementDType",ee,l,M);return[M.getTensorList(X.id).getItem(we,me,He)]}case"TensorListScatterV2":case"TensorListScatter":{const X=o("indices",ee,l,M),we=function(me,He,Re,pt){if(He.length!==me.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${He.length} vs. ${me.shape[0]}`);const _=Math.max(...He);if(null!=pt&&-1!==pt&&_>=pt)throw new Error(`Max index must be < array size (${_}  vs. ${pt})`);const E=new Fn([],Re,me.dtype,pt),$=(0,P.unstack)(me,0);return He.forEach((Ee,Le)=>{E.setItem(Ee,$[Le])}),E}(o("tensor",ee,l,M),X,o("elementShape",ee,l,M),o("numElements",ee,l,M));return M.addTensorList(we),[we.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const X=o("elementShape",ee,l,M),we=o("elementDType",ee,l,M);let me;me="TensorListReserve"===ee.op?"numElements":"maxNumElements";const He=function(Re,pt,_){return new Fn([],Re,pt,_)}(X,we,o(me,ee,l,M));return M.addTensorList(He),[He.idTensor]}case"TensorListGather":{const X=o("tensorListId",ee,l,M),we=o("indices",ee,l,M),me=o("elementShape",ee,l,M),He=o("elementDType",ee,l,M);return[M.getTensorList(X.id).gather(we,He,me)]}case"TensorListStack":{const X=o("tensorListId",ee,l,M),we=o("elementShape",ee,l,M),me=o("elementDType",ee,l,M),He=o("numElements",ee,l,M);return[M.getTensorList(X.id).stack(we,me,He)]}case"TensorListFromTensor":{const X=function(we,me,He){const Re=we.dtype;if(we.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${we.shape}`);if(we.dtype!==He)throw new Error(`Invalid data types; op elements ${we.dtype}, but list elements ${He}`);Un(we.shape.slice(1),me,"TensorList shape mismatch: ");const pt=(0,P.unstack)(we);return new Fn(pt,me,Re)}(o("tensor",ee,l,M),o("elementShape",ee,l,M),o("elementDType",ee,l,M));return M.addTensorList(X),[X.idTensor]}case"TensorListConcat":{const X=o("tensorListId",ee,l,M),we=M.getTensorList(X.id),me=o("dtype",ee,l,M),He=o("elementShape",ee,l,M);return[we.concat(me,He)]}case"TensorListPushBack":{const X=o("tensorListId",ee,l,M),we=o("tensor",ee,l,M),me=M.getTensorList(X.id);return me.pushBack(we),[me.idTensor]}case"TensorListPopBack":{const X=o("tensorListId",ee,l,M),we=o("elementShape",ee,l,M),me=o("elementDType",ee,l,M);return[M.getTensorList(X.id).popBack(we,me)]}case"TensorListSplit":{const X=o("tensor",ee,l,M),we=o("elementShape",ee,l,M),me=function(He,Re,pt){let _=0;const E=Re.map(qe=>(_+=qe,_));if(_!==He.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${_}, and tensor's shape is: ${He.shape}`);const $=nr(He.shape.slice(1),pt),Ee=0===_?0:He.size/_,Le=(0,P.tidy)(()=>{const qe=[];He=(0,P.reshape)(He,[1,_,Ee]);for(let ht=0;ht<Re.length;++ht){const At=[0,0===ht?0:E[ht-1],0],rn=[1,Re[ht],Ee];qe[ht]=(0,P.reshape)((0,P.slice)(He,At,rn),$)}return He.dispose(),qe}),Ze=new Fn([],pt,He.dtype,Re.length);for(let qe=0;qe<Le.length;qe++)Ze.setItem(qe,Le[qe]);return Ze}(X,o("lengths",ee,l,M),we);return M.addTensorList(me),[me.idTensor]}default:throw TypeError(`Node type ${ee.op} is not implemented`)}};var Tr=e(1355),cn=e(4794),rs=e(2277),ss=e(1405),Lr=e(4718),la=e(473),ca=e(5176),da=e(1174),Ns=e(6877),qs=e(1749),ha=e(5020),Hs=e(557);function xs(ee,l,M){const[X,we]=o("fusedOps",ee,l,M),me="biasadd"===X,He=!me,Re="prelu"===we,pt="fusedbatchnorm"===X,_=o("numArgs",ee,l,M);if(me){if(Re&&2!==_)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!Re&&me&&1!==_)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(pt)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const E=o("strides",ee,l,M),$=Ke(ee,l,M),Ee=o("dataFormat",ee,l,M).toUpperCase(),Le=o("dilations",ee,l,M);let[Ze,qe]=o("args",ee,l,M);He&&(qe=Ze,Ze=void 0);return{stride:E,pad:$,dataFormat:Ee,dilations:Le,biasArg:Ze,preluArg:qe,activationFunc:we,leakyreluAlpha:o("leakyreluAlpha",ee,l,M)}}var Bt=e(4006),on=e(4135),Yn=e(686),Zt=e(6708),Ir=e(4917),Xn=e(7846),er=e(5002),br=e(7245),kr=e(3596),dr=e(9640),Pr=e(6577);var Ln=e(4885),un=e(2271),as=e(6380),wr=e(6567);function vr(ee,l,M){return{boxes:o("boxes",ee,l,M),scores:o("scores",ee,l,M),maxOutputSize:o("maxOutputSize",ee,l,M),iouThreshold:o("iouThreshold",ee,l,M),scoreThreshold:o("scoreThreshold",ee,l,M),softNmsSigma:o("softNmsSigma",ee,l,M)}}var pa=e(3243),js=e(9608);var Rr=e(6092),hr=e(9494);class os{constructor(l,M){this.keyDType=l,this.valueDType=M,this.handle=(0,P.scalar)(0),this.tensorMap=new Map,(0,P.keep)(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(l=>l.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return hr.i(this.size(),"int32")}async import(l,M){this.checkKeyAndValueTensor(l,M);const X=await l.data();return this.tensorMap.forEach(we=>we.dispose()),this.tensorMap.clear(),(0,P.tidy)(()=>{const we=(0,P.unstack)(M),me=X.length,He=we.length;P.util.assert(me===He,()=>`The number of elements doesn't match, keys has ${me} elements, the values has ${He} elements.`);for(let Re=0;Re<me;Re++){const pt=X[Re],_=we[Re];(0,P.keep)(_),this.tensorMap.set(pt,_)}return this.handle})}async find(l,M){this.checkKeyAndValueTensor(l,M);const X=await l.data();return(0,P.tidy)(()=>{const we=[];for(let me=0;me<X.length;me++){const He=X[me],Re=this.findWithDefault(He,M);we.push(Re)}return(0,P.stack)(we)})}findWithDefault(l,M){const X=this.tensorMap.get(l);return null!=X?X:M}checkKeyAndValueTensor(l,M){if(l.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${l.dtype}`);if(M.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${M.dtype}`)}}var is=e(6477),us=e(6500),Ie=e(636),Gs=e(7630),Er=e(6573),Ca=e(624),Ar=e(2856),fa=e(8651),Pn=e(5750),Ks=e(5912);var Xs=e(8687),_s=e(4653),Nr=e(9065);var Zs=e(7505),ma=e(9648),ga=e(682),rr=e(1510),Ss=e(9758);var Ts=e(3307),Wa=e(5130),Ua=e(5735),qa=e(5475),Ha=e(781),ja=e(2998),Ga=e(47),$a=e(7394),Ka=e(7405),ya=e(3865),Xa=e(5746);var Is=e(6884),Qs=e(4926),ba=e(7486),Za=e(2676),Es=e(5158),As=e(9590),ka=e(4968),wa=e(2991),Qa=e(4136),Ja=e(7501),Da=e(8644),Ya=e(3100),eo=e(7494);var to=e(7020),Fa=e(8447),va=e(3710),Js=e(4415);var no=e(1300),ro=e(1483),Ys=e(9682),ea=e(7918),Oa=e(8441),so=e(9112),Na=e(8247),xa=e(8194);function ta(ee,l,M,X){const we=((me,He,Re)=>{switch(me.category){case"arithmetic":return P.tidy(()=>((_,E,$)=>{switch(_.op){case"BiasAdd":case"AddV2":case"Add":return[wn.I(o("a",_,E,$),o("b",_,E,$))];case"AddN":return[Mn.Q(o("tensors",_,E,$))];case"FloorMod":case"Mod":return[fr.w(o("a",_,E,$),o("b",_,E,$))];case"Mul":return[Jn.d(o("a",_,E,$),o("b",_,E,$))];case"RealDiv":case"Div":return[Hr.h(o("a",_,E,$),o("b",_,E,$))];case"DivNoNan":return[ir.N(o("a",_,E,$),o("b",_,E,$))];case"FloorDiv":return[Ds.q(o("a",_,E,$),o("b",_,E,$))];case"Sub":return[hs.l(o("a",_,E,$),o("b",_,E,$))];case"Minimum":return[ur.L(o("a",_,E,$),o("b",_,E,$))];case"Maximum":return[jr.g(o("a",_,E,$),o("b",_,E,$))];case"Pow":return[Gr.s(o("a",_,E,$),o("b",_,E,$))];case"SquaredDifference":return[$n.$(o("a",_,E,$),o("b",_,E,$))];default:throw TypeError(`Node type ${_.op} is not implemented`)}})(me,He,Re));case"basic_math":return P.tidy(()=>((_,E,$)=>{switch(_.op){case"Abs":case"ComplexAbs":return[Fs.W(o("x",_,E,$))];case"Acos":return[Os.K(o("x",_,E,$))];case"Acosh":return[Bs._(o("x",_,E,$))];case"Asin":return[Kr.Z(o("x",_,E,$))];case"Asinh":return[Xr.V(o("x",_,E,$))];case"Atan":return[Zr.z(o("x",_,E,$))];case"Atan2":return[ps.f(o("x",_,E,$),o("y",_,E,$))];case"Atanh":return[oa.C(o("x",_,E,$))];case"Ceil":return[mr.m(o("x",_,E,$))];case"Complex":return[Ls.P(o("real",_,E,$),o("imag",_,E,$))];case"Cos":return[fs.m(o("x",_,E,$))];case"Cosh":return[Dn.f(o("x",_,E,$))];case"Elu":return[Sr.p(o("x",_,E,$))];case"Erf":return[Ps.q(o("x",_,E,$))];case"Exp":return[ms.Q(o("x",_,E,$))];case"Expm1":return[gr.t(o("x",_,E,$))];case"Floor":return[Dr.G(o("x",_,E,$))];case"Log":return[sn.c(o("x",_,E,$))];case"Log1p":return[Ce.K(o("x",_,E,$))];case"Imag":return[Gn.a(o("x",_,E,$))];case"Neg":return[Qr.W(o("x",_,E,$))];case"Reciprocal":return[yr.M(o("x",_,E,$))];case"Real":return[Jr.k(o("x",_,E,$))];case"Relu":return[ia.U(o("x",_,E,$))];case"Round":return[Rs.N(o("x",_,E,$))];case"Selu":return[Vs.U(o("x",_,E,$))];case"Sigmoid":return[zs.X(o("x",_,E,$))];case"Sin":return[gs.O(o("x",_,E,$))];case"Sign":return[Fr.X(o("x",_,E,$))];case"Sinh":return[Yr.R(o("x",_,E,$))];case"Softplus":return[Kn.W(o("x",_,E,$))];case"Sqrt":return[es._(o("x",_,E,$))];case"Square":return[ys.h(o("x",_,E,$))];case"Tanh":return[lr.A(o("x",_,E,$))];case"Tan":return[ts.O(o("x",_,E,$))];case"ClipByValue":return[bs.i(o("x",_,E,$),o("clipValueMin",_,E,$),o("clipValueMax",_,E,$))];case"Relu6":return[ks.b(o("x",_,E,$))];case"Rsqrt":return[Or.b(te(_.inputNames[0],E,$))];case"Prod":return[ns.W(o("x",_,E,$),o("axes",_,E,$))];case"LeakyRelu":return[Ws.h(o("x",_,E,$),o("alpha",_,E,$))];case"Prelu":return[ws.A(o("x",_,E,$),o("alpha",_,E,$))];case"IsNan":return[Us.i(te(_.inputNames[0],E,$))];default:throw TypeError(`Node type ${_.op} is not implemented`)}})(me,He,Re));case"control":return ua(me,He,Re);case"convolution":return P.tidy(()=>((_,E,$)=>{switch(_.op){case"Conv1D":{const Ee=o("stride",_,E,$),Le=o("pad",_,E,$),Ze=o("dataFormat",_,E,$).toUpperCase(),qe=o("dilation",_,E,$);return[Tr.P(o("x",_,E,$),o("filter",_,E,$),Ee,Le,Ze,qe)]}case"Conv2D":{const Ee=o("strides",_,E,$),Le=Ke(_,E,$),Ze=o("dataFormat",_,E,$).toUpperCase(),qe=o("dilations",_,E,$);return[cn.T(o("x",_,E,$),o("filter",_,E,$),[Ee[1],Ee[2]],Le,Ze,[qe[1],qe[2]])]}case"_FusedConv2D":{const{stride:Ee,pad:Le,dataFormat:Ze,dilations:qe,biasArg:ht,preluArg:At,activationFunc:rn,leakyreluAlpha:ln}=xs(_,E,$);return[rs.conv2d({x:o("x",_,E,$),filter:o("filter",_,E,$),strides:[Ee[1],Ee[2]],pad:Le,dataFormat:Ze,dilations:[qe[1],qe[2]],bias:ht,activation:rn,preluActivationWeights:At,leakyreluAlpha:ln})]}case"FusedDepthwiseConv2dNative":{const{stride:Ee,pad:Le,dataFormat:Ze,dilations:qe,biasArg:ht,preluArg:At,activationFunc:rn,leakyreluAlpha:ln}=xs(_,E,$);return[rs.depthwiseConv2d({x:o("x",_,E,$),filter:o("filter",_,E,$),strides:[Ee[1],Ee[2]],pad:Le,dataFormat:Ze,dilations:[qe[1],qe[2]],bias:ht,activation:rn,preluActivationWeights:At,leakyreluAlpha:ln})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const Ee=o("outputShape",_,E,$),Le=o("strides",_,E,$),Ze=Ke(_,E,$);return[ss.b(o("x",_,E,$),o("filter",_,E,$),Ee,[Le[1],Le[2]],Ze)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const Ee=o("strides",_,E,$),Le=Ke(_,E,$),Ze=o("dilations",_,E,$),qe=o("dataFormat",_,E,$).toUpperCase();return[Lr.B(o("input",_,E,$),o("filter",_,E,$),[Ee[1],Ee[2]],Le,qe,[Ze[1],Ze[2]])]}case"Conv3D":{const Ee=o("strides",_,E,$),Le=o("pad",_,E,$),Ze=o("dataFormat",_,E,$).toUpperCase(),qe=o("dilations",_,E,$);return[la.p(o("x",_,E,$),o("filter",_,E,$),[Ee[1],Ee[2],Ee[3]],Le,Ze,[qe[1],qe[2],qe[3]])]}case"AvgPool":{const Ee=o("strides",_,E,$),Le=o("pad",_,E,$),Ze=o("kernelSize",_,E,$);return[ca.w(o("x",_,E,$),[Ze[1],Ze[2]],[Ee[1],Ee[2]],Le)]}case"MaxPool":{const Ee=o("strides",_,E,$),Le=o("pad",_,E,$),Ze=o("kernelSize",_,E,$);return[da._(o("x",_,E,$),[Ze[1],Ze[2]],[Ee[1],Ee[2]],Le)]}case"MaxPoolWithArgmax":{const Ee=o("strides",_,E,$),Le=o("pad",_,E,$),Ze=o("kernelSize",_,E,$),qe=o("includeBatchInIndex",_,E,$),{result:ht,indexes:At}=Ns.I(o("x",_,E,$),[Ze[1],Ze[2]],[Ee[1],Ee[2]],Le,qe);return[ht,At]}case"AvgPool3D":{const Ee=o("strides",_,E,$),Le=o("pad",_,E,$),Ze=o("kernelSize",_,E,$);return[qs.u(o("x",_,E,$),[Ze[1],Ze[2],Ze[3]],[Ee[1],Ee[2],Ee[3]],Le)]}case"MaxPool3D":{const Ee=o("strides",_,E,$),Le=o("pad",_,E,$),Ze=o("kernelSize",_,E,$);return[ha.Y(o("x",_,E,$),[Ze[1],Ze[2],Ze[3]],[Ee[1],Ee[2],Ee[3]],Le)]}case"Dilation2D":{const Ee=o("strides",_,E,$),Le=o("pad",_,E,$),Ze=o("dilations",_,E,$),qe=Ee[1],ht=Ee[2],At=Ze[1],rn=Ze[2];return[Hs.W(o("x",_,E,$),o("filter",_,E,$),[qe,ht],Le,[At,rn],"NHWC")]}default:throw TypeError(`Node type ${_.op} is not implemented`)}})(me,He,Re));case"creation":return P.tidy(()=>((_,E,$)=>{switch(_.op){case"Fill":{const Ee=o("shape",_,E,$),Le=o("dtype",_,E,$),Ze=o("value",_,E,$);return[Bt.h(Ee,Ze,Le)]}case"LinSpace":{const Ee=o("start",_,E,$),Le=o("stop",_,E,$),Ze=o("num",_,E,$);return[on.S(Ee,Le,Ze)]}case"Multinomial":{const Ee=o("logits",_,E,$),Le=o("numSamples",_,E,$),Ze=o("seed",_,E,$);return[Yn.S(Ee,Le,Ze)]}case"OneHot":{const Ee=o("indices",_,E,$),Le=o("depth",_,E,$),Ze=o("onValue",_,E,$),qe=o("offValue",_,E,$);return[Zt.l(Ee,Le,Ze,qe)]}case"Ones":return[Ir.i(o("shape",_,E,$),o("dtype",_,E,$))];case"OnesLike":return[Xn.J(o("x",_,E,$))];case"RandomUniform":return[er.L(o("shape",_,E,$),o("minval",_,E,$),o("maxval",_,E,$),o("dtype",_,E,$))];case"Range":{const Ee=o("start",_,E,$),Le=o("stop",_,E,$),Ze=o("step",_,E,$);return[br.w(Ee,Le,Ze,o("dtype",_,E,$))]}case"TruncatedNormal":{const Ee=o("shape",_,E,$),Le=o("mean",_,E,$),Ze=o("stdDev",_,E,$),qe=o("seed",_,E,$);return[kr.X(Ee,Le,Ze,o("dtype",_,E,$),qe)]}case"Zeros":return[dr.l(o("shape",_,E,$),o("dtype",_,E,$))];case"ZerosLike":return[Pr.P(o("x",_,E,$))];default:throw TypeError(`Node type ${_.op} is not implemented`)}})(me,He,Re));case"dynamic":return(async(_,E,$)=>{switch(_.op){case"NonMaxSuppressionV5":{const{boxes:Ee,scores:Le,maxOutputSize:Ze,iouThreshold:qe,scoreThreshold:ht,softNmsSigma:At}=vr(_,E,$),rn=await Ln.BHj.nonMaxSuppressionWithScoreAsync(Ee,Le,Ze,qe,ht,At);return[rn.selectedIndices,rn.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:Ee,scores:Le,maxOutputSize:Ze,iouThreshold:qe,scoreThreshold:ht}=vr(_,E,$),At=o("padToMaxOutputSize",_,E,$),rn=await Ln.BHj.nonMaxSuppressionPaddedAsync(Ee,Le,Ze,qe,ht,At);return[rn.selectedIndices,rn.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:Ee,scores:Le,maxOutputSize:Ze,iouThreshold:qe,scoreThreshold:ht}=vr(_,E,$);return[await Ln.BHj.nonMaxSuppressionAsync(Ee,Le,Ze,qe,ht)]}case"Where":{const Ee=un.p(o("condition",_,E,$),"bool"),Le=[await as.i(Ee)];return Ee.dispose(),Le}case"ListDiff":return wr.O(o("x",_,E,$),o("y",_,E,$));default:throw TypeError(`Node type ${_.op} is not implemented`)}})(me,He,Re);case"evaluation":return P.tidy(()=>((_,E,$)=>{switch(_.op){case"TopKV2":{const Ee=o("x",_,E,$),Le=o("k",_,E,$),Ze=o("sorted",_,E,$),qe=pa.h(Ee,Le,Ze);return[qe.values,qe.indices]}case"Unique":{const Ee=o("x",_,E,$),Le=js.T(Ee);return[Le.values,Le.indices]}case"UniqueV2":{const Ee=o("x",_,E,$),Le=o("axis",_,E,$),Ze=js.T(Ee,Le);return[Ze.values,Ze.indices]}default:throw TypeError(`Node type ${_.op} is not implemented`)}})(me,He,Re));case"image":return P.tidy(()=>((_,E,$)=>{switch(_.op){case"ResizeBilinear":{const Ee=o("images",_,E,$),Le=o("size",_,E,$),Ze=o("alignCorners",_,E,$),qe=o("halfPixelCenters",_,E,$);return[Ln.BHj.resizeBilinear(Ee,[Le[0],Le[1]],Ze,qe)]}case"ResizeNearestNeighbor":{const Ee=o("images",_,E,$),Le=o("size",_,E,$),Ze=o("alignCorners",_,E,$),qe=o("halfPixelCenters",_,E,$);return[Ln.BHj.resizeNearestNeighbor(Ee,[Le[0],Le[1]],Ze,qe)]}case"CropAndResize":{const Ee=o("image",_,E,$),Le=o("boxes",_,E,$),Ze=o("boxInd",_,E,$),qe=o("cropSize",_,E,$),ht=o("method",_,E,$),At=o("extrapolationValue",_,E,$);return[Ln.BHj.cropAndResize(Ee,Le,Ze,qe,ht,At)]}default:throw TypeError(`Node type ${_.op} is not implemented`)}})(me,He,Re));case"graph":return P.tidy(()=>((_,E,$)=>{switch(_.op){case"Const":return E[_.name];case"PlaceholderWithDefault":const Ee=o("default",_,E,$);return[te(_.name,E,$)||Ee];case"Placeholder":return[te(_.name,E,$)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":return[Ye(o("x",_,E,$))];case"IdentityN":return o("x",_,E,$).map(At=>Ye(At));case"Snapshot":return[Ye(o("x",_,E,$))];case"Shape":return[Rr.R(o("x",_,E,$).shape,"int32")];case"ShapeN":return o("x",_,E,$).map(At=>Rr.R(At.shape));case"Size":return[hr.i(o("x",_,E,$).size,"int32")];case"Rank":return[hr.i(o("x",_,E,$).rank,"int32")];case"NoOp":return[hr.i(1)];case"Print":const Le=o("x",_,E,$),Ze=o("data",_,E,$),qe=o("message",_,E,$),ht=o("summarize",_,E,$);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(qe);for(let At=0;At<Ze.length;At++)console.log(Array.prototype.slice.call(Ze[At].dataSync()).slice(0,ht));return[Le];default:throw TypeError(`Node type ${_.op} is not implemented`)}})(me,He,Re));case"logical":return P.tidy(()=>((_,E,$)=>{switch(_.op){case"Equal":return[is.D(o("a",_,E,$),o("b",_,E,$))];case"NotEqual":return[us.Q(o("a",_,E,$),o("b",_,E,$))];case"Greater":return[Ie.p(o("a",_,E,$),o("b",_,E,$))];case"GreaterEqual":return[Gs.b(o("a",_,E,$),o("b",_,E,$))];case"Less":return[Er.d(o("a",_,E,$),o("b",_,E,$))];case"LessEqual":return[Ca.z(o("a",_,E,$),o("b",_,E,$))];case"LogicalAnd":return[Ar.H(o("a",_,E,$),o("b",_,E,$))];case"LogicalNot":return[fa.h(o("a",_,E,$))];case"LogicalOr":return[Pn.K(o("a",_,E,$),o("b",_,E,$))];case"Select":case"SelectV2":return[Ks.a(o("condition",_,E,$),o("a",_,E,$),o("b",_,E,$))];default:throw TypeError(`Node type ${_.op} is not implemented`)}})(me,He,Re));case"matrices":return P.tidy(()=>((_,E,$)=>{switch(_.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[Xs.O(o("a",_,E,$),o("b",_,E,$),o("transposeA",_,E,$),o("transposeB",_,E,$))];case"Einsum":return[_s.W(o("equation",_,E,$),...o("tensors",_,E,$))];case"Transpose":return[Nr.p(o("x",_,E,$),o("perm",_,E,$))];case"_FusedMatMul":const[Ee,Le]=o("fusedOps",_,E,$),Ze="biasadd"===Ee,qe="prelu"===Le,ht=o("numArgs",_,E,$),At=o("leakyreluAlpha",_,E,$);if(Ze){if(qe&&2!==ht)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!qe&&1!==ht)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[rn,ln]=o("args",_,E,$);return[rs.matMul({a:o("a",_,E,$),b:o("b",_,E,$),transposeA:o("transposeA",_,E,$),transposeB:o("transposeB",_,E,$),bias:rn,activation:Le,preluActivationWeights:ln,leakyreluAlpha:At})];default:throw TypeError(`Node type ${_.op} is not implemented`)}})(me,He,Re));case"normalization":return P.tidy(()=>((_,E,$)=>{switch(_.op){case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[Zs.t(o("x",_,E,$),o("mean",_,E,$),o("variance",_,E,$),o("offset",_,E,$),o("scale",_,E,$),o("epsilon",_,E,$))];case"LRN":return[ma.G(o("x",_,E,$),o("radius",_,E,$),o("bias",_,E,$),o("alpha",_,E,$),o("beta",_,E,$))];case"Softmax":return[ga.X(o("x",_,E,$))];case"LogSoftmax":return[rr.C(o("x",_,E,$))];case"SparseToDense":return[Ss.e(o("sparseIndices",_,E,$),o("outputShape",_,E,$),o("sparseValues",_,E,$),o("defaultValue",_,E,$))];default:throw TypeError(`Node type ${_.op} is not implemented`)}})(me,He,Re));case"reduction":return P.tidy(()=>((_,E,$)=>{switch(_.op){case"Max":{const qe=o("axis",_,E,$),ht=o("keepDims",_,E,$);return[Ts.F(o("x",_,E,$),qe,ht)]}case"Mean":{const qe=o("axis",_,E,$),ht=o("keepDims",_,E,$);return[Wa.J(o("x",_,E,$),qe,ht)]}case"Min":{const qe=o("axis",_,E,$),ht=o("keepDims",_,E,$);return[Ua.V(o("x",_,E,$),qe,ht)]}case"Sum":{const qe=o("axis",_,E,$),ht=o("keepDims",_,E,$);return[qa.S(o("x",_,E,$),qe,ht)]}case"All":{const qe=o("axis",_,E,$),ht=o("keepDims",_,E,$);return[Ha.$(o("x",_,E,$),qe,ht)]}case"Any":{const qe=o("axis",_,E,$),ht=o("keepDims",_,E,$);return[ja.Y(o("x",_,E,$),qe,ht)]}case"ArgMax":{const qe=o("axis",_,E,$);return[Ga.N(o("x",_,E,$),qe)]}case"ArgMin":{const qe=o("axis",_,E,$);return[$a.v(o("x",_,E,$),qe)]}case"Prod":{const qe=o("axis",_,E,$),ht=o("keepDims",_,E,$);return[ns.W(o("x",_,E,$),qe,ht)]}case"Cumsum":{const qe=o("axis",_,E,$),ht=o("exclusive",_,E,$),At=o("reverse",_,E,$);return[Ka.z(o("x",_,E,$),qe,ht,At)]}case"Bincount":const Ee=o("x",_,E,$),Le=o("weights",_,E,$),Ze=o("size",_,E,$);return[ya.y(Ee,Le,Ze)];case"DenseBincount":{const qe=o("x",_,E,$),ht=o("weights",_,E,$),At=o("size",_,E,$),rn=o("binaryOutput",_,E,$);return[Xa.p(qe,ht,At,rn)]}default:throw TypeError(`Node type ${_.op} is not implemented`)}})(me,He,Re));case"slice_join":return P.tidy(()=>((_,E,$)=>{switch(_.op){case"ConcatV2":case"Concat":{const Ee=o("n",_,E,$),Le=o("axis",_,E,$);let Ze=o("tensors",_,E,$);return Ze=Ze.slice(0,Ee),[Is.z(Ze,Le)]}case"Gather":{const Ee=o("x",_,E,$),Le=o("indices",_,E,$);return[Qs.I(Ee,un.p(Le,"int32"),0)]}case"GatherV2":{const Ee=o("axis",_,E,$),Le=o("batchDims",_,E,$),Ze=o("x",_,E,$),qe=o("indices",_,E,$);return[Qs.I(Ze,un.p(qe,"int32"),Ee,Le)]}case"Reverse":{const Ee=o("dims",_,E,$),Le=[];for(let qe=0;qe<Ee.length;qe++)Ee[qe]&&Le.push(qe);const Ze=o("x",_,E,$);return[ba.G(Ze,Le)]}case"ReverseV2":{const Ee=o("axis",_,E,$),Le=o("x",_,E,$);return[ba.G(Le,Ee)]}case"Slice":{const Ee=o("begin",_,E,$),Le=o("size",_,E,$);return[Za.t(o("x",_,E,$),Ee,Le)]}case"StridedSlice":{const Ee=o("begin",_,E,$),Le=o("end",_,E,$),Ze=o("strides",_,E,$),qe=o("beginMask",_,E,$),ht=o("endMask",_,E,$),At=o("ellipsisMask",_,E,$),rn=o("newAxisMask",_,E,$),ln=o("shrinkAxisMask",_,E,$),_a=o("x",_,E,$);return[Es.N(_a,Ee,Le,Ze,qe,ht,At,rn,ln)]}case"Pack":return(0,P.tidy)(()=>{const Ee=o("axis",_,E,$),Le=o("tensors",_,E,$),Ze=Le[0].shape,qe=As.L(Le[0]).shape,ht=Le.map(At=>{const rn=P.util.arraysEqual(At.shape,Ze);if(!rn&&!P.util.arraysEqual(As.L(At).shape,qe))throw new Error("the input tensors shape does not match");return rn?At:ka.X(At,Ze)});return[wa.k(ht,Ee)]});case"Unpack":{const Ee=o("axis",_,E,$),Le=o("tensor",_,E,$);return Qa.H(Le,Ee)}case"Tile":{const Ee=o("reps",_,E,$);return[Ja.G(o("x",_,E,$),Ee)]}case"Split":case"SplitV":{const Ee=o("axis",_,E,$),Le=o("numOrSizeSplits",_,E,$),Ze=o("x",_,E,$);return Da.V(Ze,Le,Ee)}case"ScatterNd":{const Ee=o("indices",_,E,$),Le=o("values",_,E,$),Ze=o("shape",_,E,$);return[Ya.s(Ee,Le,Ze)]}case"GatherNd":{const Ee=o("x",_,E,$),Le=o("indices",_,E,$);return[eo.d(Ee,Le)]}case"SparseToDense":{const Ee=o("sparseIndices",_,E,$),Le=o("outputShape",_,E,$),Ze=o("sparseValues",_,E,$),qe=o("defaultValue",_,E,$);return[Ss.e(Ee,Ze,Le,Ze.dtype===qe.dtype?qe:un.p(qe,Ze.dtype))]}default:throw TypeError(`Node type ${_.op} is not implemented`)}})(me,He,Re));case"sparse":return P.tidy(()=>((_,E,$)=>{switch(_.op){case"SparseFillEmptyRows":{const{outputIndices:Ee,outputValues:Le,emptyRowIndicator:Ze,reverseIndexMap:qe}=Ln.rVs.sparseFillEmptyRows(o("indices",_,E,$),o("values",_,E,$),o("denseShape",_,E,$),o("defaultValue",_,E,$));return[Ee,Le,Ze,qe]}case"SparseReshape":{const{outputIndices:Ee,outputShape:Le}=Ln.rVs.sparseReshape(o("inputIndices",_,E,$),o("inputShape",_,E,$),o("newShape",_,E,$));return[Ee,Le]}case"SparseSegmentMean":return[Ln.rVs.sparseSegmentMean(o("data",_,E,$),o("indices",_,E,$),o("segmentIds",_,E,$))];case"SparseSegmentSum":return[Ln.rVs.sparseSegmentSum(o("data",_,E,$),o("indices",_,E,$),o("segmentIds",_,E,$))];default:throw TypeError(`Node type ${_.op} is not implemented`)}})(me,He,Re));case"spectral":return P.tidy(()=>((_,E,$)=>{switch(_.op){case"FFT":return[to.k(o("x",_,E,$))];case"IFFT":return[Fa.S(o("x",_,E,$))];case"RFFT":return[va.Q(o("x",_,E,$))];case"IRFFT":return[Js.w(o("x",_,E,$))];default:throw TypeError(`Node type ${_.op} is not implemented`)}})(me,He,Re));case"string":return P.tidy(()=>((_,E,$)=>{switch(_.op){case"StringNGrams":{const{nGrams:Ee,nGramsSplits:Le}=Ln.Z_8.stringNGrams(o("data",_,E,$),o("dataSplits",_,E,$),o("separator",_,E,$),o("nGramWidths",_,E,$),o("leftPad",_,E,$),o("rightPad",_,E,$),o("padWidth",_,E,$),o("preserveShortSequences",_,E,$));return[Ee,Le]}case"StringSplit":{const{indices:Ee,values:Le,shape:Ze}=Ln.Z_8.stringSplit(o("input",_,E,$),o("delimiter",_,E,$),o("skipEmpty",_,E,$));return[Ee,Le,Ze]}case"StringToHashBucketFast":return[Ln.Z_8.stringToHashBucketFast(o("input",_,E,$),o("numBuckets",_,E,$))];default:throw TypeError(`Node type ${_.op} is not implemented`)}})(me,He,Re));case"transformation":return P.tidy(()=>((_,E,$)=>{switch(_.op){case"Cast":return[un.p(o("x",_,E,$),o("dtype",_,E,$))];case"ExpandDims":{const Ee=o("axis",_,E,$);return[no.d(o("x",_,E,$),Ee)]}case"Squeeze":{const Ee=o("axis",_,E,$);return[As.L(o("x",_,E,$),Ee)]}case"Reshape":return[ka.X(o("x",_,E,$),o("shape",_,E,$))];case"MirrorPad":return[ro.V(o("x",_,E,$),o("padding",_,E,$),o("mode",_,E,$))];case"PadV2":case"Pad":return[Ys.v(o("x",_,E,$),o("padding",_,E,$),o("constantValue",_,E,$))];case"SpaceToBatchND":{const Ee=o("blockShape",_,E,$),Le=o("paddings",_,E,$);return[ea.f(o("x",_,E,$),Ee,Le)]}case"BatchToSpaceND":{const Ee=o("blockShape",_,E,$),Le=o("crops",_,E,$);return[Oa.E(o("x",_,E,$),Ee,Le)]}case"DepthToSpace":{const Ee=o("blockSize",_,E,$),Le=o("dataFormat",_,E,$).toUpperCase();return[so.n(o("x",_,E,$),Ee,Le)]}case"BroadcastTo":return[Na.U(o("x",_,E,$),o("shape",_,E,$))];case"BroadcastArgs":return[xa.X(o("s0",_,E,$),o("s1",_,E,$))];default:throw TypeError(`Node type ${_.op} is not implemented`)}})(me,He,Re));case"hash_table":return(async(_,E,$,Ee)=>{switch(_.op){case"HashTable":case"HashTableV2":{const Le=o("keyDType",_,E,$),Ze=o("valueDType",_,E,$),qe=new os(Le,Ze);return Ee.addHashTable(_.name,qe),[qe.handle]}case"LookupTableImport":case"LookupTableImportV2":{const Le=o("tableHandle",_,E,$,Ee),Ze=o("keys",_,E,$),qe=o("values",_,E,$),ht=Ee.getHashTableById(Le.id);return[await ht.import(Ze,qe)]}case"LookupTableFind":case"LookupTableFindV2":{const Le=o("tableHandle",_,E,$,Ee),Ze=o("keys",_,E,$),qe=o("defaultValue",_,E,$),ht=Ee.getHashTableById(Le.id);return[await ht.find(Ze,qe)]}case"LookupTableSize":case"LookupTableSizeV2":{const Le=o("tableHandle",_,E,$,Ee);return[Ee.getHashTableById(Le.id).tensorSize()]}default:throw TypeError(`Node type ${_.op} is not implemented`)}})(me,He,Re,X);case"custom":const pt=oe(me.op);if(pt&&pt.customExecutor)return pt.customExecutor(new Tn(me,He,Re));throw TypeError(`Custom op ${me.op} is not registered.`);default:throw TypeError(`Unknown op '${me.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(ee,l,M);return P.util.isPromise(we)?we.then(me=>[].concat(me)):[].concat(we)}class Mr{constructor(l={},M={},X={},we={}){this.weightMap=l,this.tensorArrayMap=M,this.tensorListMap=X,this.functionMap=we,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(l,M){return{id:l,frameName:M,iterationId:0}}set currentContext(l){this.contexts!==l&&(this.contexts=l,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const l=[];for(let M=0;M<this.contexts.length-1;M++){const X=this.contexts.slice(0,this.contexts.length-M);l.push(this.contextIdforContexts(X))}l.push(""),this._currentContextIds=l}contextIdforContexts(l){return l?l.map(M=>0===M.id&&0===M.iterationId?"":`${M.frameName}-${M.iterationId}`).join("/"):""}enterFrame(l){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,l)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const l=Object.assign({},this.contexts[this.contexts.length-1]);l.iterationId+=1,l.id=this.lastId,this.contexts.splice(-1,1,l),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(l){return this.weightMap[l]}addTensorArray(l){this.tensorArrayMap[l.id]=l}getTensorArray(l){return this.tensorArrayMap[l]}addTensorList(l){this.tensorListMap[l.id]=l}getTensorList(l){return this.tensorListMap[l]}dispose(l){for(const M in this.tensorArrayMap)this.tensorArrayMap[M].clearAndClose(l);for(const M in this.tensorListMap)this.tensorListMap[M].clearAndClose(l)}}function B(ee,l,M,X){const we=new Set,me=[];let He=null,Re=null;const pt=new Set,_=Object.keys(ee).map(Ee=>ze(Ee)[0]);let E=[];null!=X&&(E=X.map(Ee=>ze(Ee.name)[0]));const $=[...l];for(;$.length>0;){const Ee=$.pop();(j(Ee)||de(Ee)||xe(Ee))&&null==He&&(He=Ee,Re=He.children.map(Le=>Le.name).filter(Le=>we.has(Le))),we.add(Ee.name),null==M[Ee.name]&&(-1===_.indexOf(Ee.name)&&-1===E.indexOf(Ee.name)&&(0!==Ee.inputs.length?Ee.inputs.forEach(Le=>{pt.has(Le.name)||(pt.add(Le.name),$.push(Le))}):me.push(Ee.name)))}return{inputs:ee,outputs:l,usedNodes:we,missingInputs:me,dynamicNode:He,syncInputs:Re}}const d=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],D=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],H=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function j(ee){return d.indexOf(ee.op)>=0}function de(ee){return D.indexOf(ee.op)>=0}function xe(ee){return H.indexOf(ee.op)>=0}class Te{constructor(l,M){this.graph=l,this.parent=M,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=l.outputs,this._inputs=l.inputs,this._initNodes=l.initNodes,this._signature=l.signature,this._functions=l.functions,null!=l.functions&&Object.keys(l.functions).forEach(X=>{this._functionExecutorMap[X]=new Te(l.functions[X],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(l){const M=Object.keys(l).map(X=>l[X].map(we=>we.id));this._weightIds=[].concat(...M),this._weightMap=l}set resourceManager(l){this._resourceManager=l}get inputs(){return this._inputs.map(l=>({name:l.name,shape:l.attrParams.shape?l.attrParams.shape.value:void 0,dtype:l.attrParams.dtype?l.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(l=>({name:l.name,shape:l.attrParams.shape?l.attrParams.shape.value:void 0,dtype:l.attrParams.dtype?l.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(l=>l.signatureKey||l.name)}get outputNodes(){return this._outputs.map(l=>{const M=l.signatureKey||l.name;return l.defaultOutput?`${M}:${l.defaultOutput}`:M})}get functions(){return Object.keys(this._functions).reduce((l,M)=>(l[M]=this._functions[M].signature,l),{})}getCompilationKey(l,M){const X=l.map(me=>me.name).sort(),we=M.map(me=>me.name).sort();return X.join(this.SEPERATOR)+"--"+we.join(this.SEPERATOR)}compile(l,M){const X=B(l,M,this.weightMap,this._initNodes),{missingInputs:we,dynamicNode:me,syncInputs:He}=X;if(null!=me)throw new Error(`This execution contains the node '${me.name}', which has the dynamic op '${me.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${He}]`);if(we.length>0){const Re=M.map(_=>_.name),pt=Object.keys(l);throw new Error(`Cannot compute the outputs [${Re}] from the provided inputs [${pt}]. Missing the following inputs: [${we}]`)}return function(Re,pt,_){const{usedNodes:E,inputs:$}=_,Ee=[],Le=Object.keys($).map(At=>ze(At)[0]).map(At=>Re.nodes[At]),Ze=Re.initNodes;Le.forEach(At=>{E.has(At.name)&&Ee.push(At)}),Re.weights.forEach(At=>{E.has(At.name)&&Ee.push(At)}),null!=Ze&&Ze.forEach(At=>{E.has(At.name)&&Ee.push(At)});const qe=new Set,ht=[];for(;Ee.length>0;){const At=Ee.pop();qe.add(At.name),pt[At.name]||ht.push(At),At.children.forEach(rn=>{!qe.has(rn.name)&&E.has(rn.name)&&rn.inputs.every(ln=>qe.has(ln.name))&&Ee.push(rn)})}return ht}(this.graph,this.weightMap,X)}execute(l,M){l=this.mapInputs(l);const X=Object.keys(l).sort();this.checkInputs(l),this.checkInputShapeAndType(l),M=this.mapOutputs(M),this.checkOutputs(M);const we=X.map($=>this.graph.nodes[ze($)[0]]),me=M.map($=>ze($)[0]);let He=me.map($=>this.graph.nodes[$]);0===He.length&&(He=this._outputs);const Re=this.getCompilationKey(we,He);let pt=this.compiledMap.get(Re);null==pt&&(pt=this.compile(l,He),this.compiledMap.set(Re,pt));const _={},E={};return(0,P.tidy)(()=>{const $=new Mr(this.weightMap,_,E,this.functionExecutorMap),Ee=Object.assign({},this.weightMap);Object.keys(l).forEach(qe=>{const[ht,At]=ze(qe),rn=[];rn[At]=l[qe],Ee[ht]=rn});const Le=this.getFrozenTensorIds(Ee),Ze={};for(let qe=0;qe<pt.length;qe++){const ht=pt[qe];if(!Ee[ht.name]){const At=ta(ht,Ee,$,this._resourceManager);if(P.util.isPromise(At))throw new Error(`The execution of the op '${ht.op}' returned a promise. Please use model.executeAsync() instead.`);Ee[ht.name]=At,this.checkTensorForDisposal(ht.name,ht,Ee,$,Le,me,Ze)}}return null==this.parent&&$.dispose(Le),M.map(qe=>te(qe,Ee,$))})}getFrozenTensorIds(l){const M=[].concat.apply([],Object.keys(l).map(X=>l[X]).map(X=>X.map(we=>we.id)));return new Set(M)}checkTensorForDisposal(l,M,X,we,me,He,Re){"control"!==M.category&&-1===He.indexOf(l)&&(X[l].forEach(pt=>{null!=pt&&(Re[pt.id]=(Re[pt.id]||0)+M.children.length)}),M.inputs.forEach(pt=>{if("control"!==pt.category){const _=function(E,$,Ee){return $[Ve(E,Ee.currentContextId)]}(pt.name,X,we);null!=_&&_.forEach(E=>{if(E&&!E.kept&&!me.has(E.id)){const $=Re[E.id];1===$?(E.dispose(),delete Re[E.id]):null!=$&&Re[E.id]--}})}}))}async executeAsync(l,M){return this._executeAsync(l,M)}async _executeAsync(l,M,X=false,we={},me={}){X||(l=this.mapInputs(l),this.checkInputs(l),this.checkInputShapeAndType(l),M=this.mapOutputs(M),this.checkOutputs(M));const He=new Mr(this.weightMap,we,me,this.functionExecutorMap),Re=await this.executeWithControlFlow(l,He,M,X),pt=M.map(Ee=>te(Ee,Re,He)),_=pt.map(Ee=>Ee.id),E=Object.keys(l).map(Ee=>l[Ee].id),$=new Set([..._,...E,...this.weightIds]);return Object.keys(Re).forEach(Ee=>{Re[Ee].forEach(Le=>{!Le||Le.kept||Le.isDisposed||$.has(Le.id)||Le.dispose()})}),null==this.parent&&He.dispose($),pt}async executeFunctionAsync(l,M,X){const we=l.reduce((me,He,Re)=>(me[this.inputs[Re].name]=He,me),{});return this._executeAsync(we,this.outputNodes,true,M,X)}async executeWithControlFlow(l,M,X,we){const me=Object.keys(l),He=me.map(ln=>this.graph.nodes[ze(ln)[0]]),Re=X.map(ln=>ze(ln)[0]);let pt=Re.map(ln=>this.graph.nodes[ln]);0===pt.length&&(pt=this._outputs);const{usedNodes:_,missingInputs:E,dynamicNode:$,syncInputs:Ee}=B(l,pt,this.weightMap,this._initNodes),Le=[...He,...this.graph.weights,...this._initNodes||[]].map(ln=>({node:ln,contexts:M.currentContext})),Ze=Object.assign({},this.weightMap);Object.keys(l).forEach(ln=>{const[_a,na]=ze(ln),Sa=[];Sa[na]=l[ln],Ze[_a]=Sa});const qe={},ht=this.getFrozenTensorIds(Ze),At={};for(;Le.length>0;){const ln=this.processStack(He,Le,M,Ze,At,ht,Re,qe,_);await Promise.all(ln)}null!=$||we||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const rn=pt.filter(ln=>!j(ln)&&!te(ln.name,Ze,M)).map(ln=>ln.name);if(rn.length>0){let ln="";throw null!=$&&(ln=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${Ee}]`),new Error(`Cannot compute the outputs [${rn}] from the provided inputs [${me}]. Consider providing the following inputs: [${E}]. ${ln}`)}return Ze}processStack(l,M,X,we,me,He,Re,pt,_){const E=[];for(;M.length>0;){const $=M.pop();X.currentContext=$.contexts;let Ee="";if("Enter"===$.node.op&&o("isConstant",$.node,we,X)&&([Ee]=De($.node.name,X)),null==we[$.node.name]){const Le=ta($.node,we,X,this._resourceManager);Ee||([Ee]=De($.node.name,X));const Ze=X.currentContext;P.util.isPromise(Le)?E.push(Le.then(qe=>(we[Ee]=qe,X.currentContext=Ze,this.checkTensorForDisposal(Ee,$.node,we,X,He,Re,pt),this.processChildNodes($.node,M,X,we,me,_),qe))):(we[Ee]=Le,this.checkTensorForDisposal(Ee,$.node,we,X,He,Re,pt),this.processChildNodes($.node,M,X,we,me,_))}else this.processChildNodes($.node,M,X,we,me,_)}return E}processChildNodes(l,M,X,we,me,He){l.children.forEach(Re=>{const[pt]=De(Re.name,X);!me[pt]&&He.has(Re.name)&&("Merge"===Re.op?Re.inputNames.some(_=>!!te(_,we,X))&&(me[pt]=true,M.push({contexts:X.currentContext,node:Re})):Re.inputNames.every(_=>!!te(_,we,X))&&(me[pt]=true,M.push({contexts:X.currentContext,node:Re})))})}dispose(){Object.keys(this.weightMap).forEach(l=>this.weightMap[l].forEach(M=>M.dispose()))}checkInputShapeAndType(l){Object.keys(l).forEach(M=>{const X=l[M],[we]=ze(M),me=this.graph.nodes[we];if(me.attrParams.shape&&me.attrParams.shape.value){const He=me.attrParams.shape.value,Re=He.length===X.shape.length&&X.shape.every((pt,_)=>-1===He[_]||He[_]===pt);P.util.assert(Re,()=>`The shape of dict['${me.name}'] provided in model.execute(dict) must be [${He}], but was [${X.shape}]`)}me.attrParams.dtype&&me.attrParams.dtype.value&&P.util.assert(X.dtype===me.attrParams.dtype.value,()=>`The dtype of dict['${me.name}'] provided in model.execute(dict) must be ${me.attrParams.dtype.value}, but was ${X.dtype}`)})}mapInputs(l){const M={};for(const X in l)if(null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[X]){M[this._signature.inputs[X].name]=l[X]}else M[X]=l[X];return M}checkInputs(l){const M=Object.keys(l).filter(X=>{const[we]=ze(X);return null==this.graph.nodes[we]});if(M.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${M}] that are not part of graph`)}mapOutputs(l){return l.map(M=>{if(null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[M]){return this._signature.outputs[M].name}return M},{})}checkOutputs(l){l.forEach(M=>{const[X]=ze(M);if(!this.graph.nodes[X])throw new Error(`The output '${M}' is not found in the graph`)})}}class Je{constructor(l={},M={}){this.hashTableNameToHandle=l,this.hashTableMap=M}addHashTable(l,M){this.hashTableNameToHandle[l]=M.handle,this.hashTableMap[M.id]=M}getHashTableHandleByName(l){return this.hashTableNameToHandle[l]}getHashTableById(l){return this.hashTableMap[l]}dispose(){for(const l in this.hashTableMap)this.hashTableMap[l].clearAndClose(),delete this.hashTableMap[l];for(const l in this.hashTableNameToHandle)this.hashTableNameToHandle[l].dispose(),delete this.hashTableNameToHandle[l]}}class it{constructor(l,M={}){this.modelUrl=l,this.loadOptions=M,this.version="n/a",null==M&&(this.loadOptions={}),this.resourceManager=new Je}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const l=this.modelUrl;if(null!=l.load)this.handler=l;else if(null!=this.loadOptions.requestInit)this.handler=P.io.browserHTTPRequest(l,this.loadOptions);else{const M=P.io.getLoadHandlers(l,this.loadOptions);if(0===M.length)M.push(P.io.browserHTTPRequest(l,this.loadOptions));else if(M.length>1)throw new Error(`Found more than one (${M.length}) load handlers for URL '${[l]}'`);this.handler=M[0]}}async load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const l=await this.handler.load();return this.loadSync(l)}loadSync(l){this.artifacts=l;const M=this.artifacts.modelTopology;let X;X=null!=this.artifacts.userDefinedMetadata&&null!=this.artifacts.userDefinedMetadata.signature?this.artifacts.userDefinedMetadata.signature:this.artifacts.signature,this.signature=X,this.version=`${M.versions.producer}.${M.versions.minConsumer}`;const we=P.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Te(yt.Instance.transformGraph(M,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(we),this.executor.resourceManager=this.resourceManager,null!=l.modelInitializer&&null!=l.modelInitializer.node){const me=yt.Instance.transformGraph(l.modelInitializer);this.initializer=new Te(me),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return true}async save(l,M){if("string"==typeof l){const X=P.io.getSaveHandlers(l);if(0===X.length)throw new Error(`Cannot find any save handlers for URL '${l}'`);if(X.length>1)throw new Error(`Found more than one (${X.length}) save handlers for URL '${l}'`);l=X[0]}if(null==l.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return l.save(this.artifacts)}predict(l,M){return this.execute(l,this.outputNodes)}normalizeInputs(l){if(!(l instanceof P.Tensor||Array.isArray(l)))return l;if((l=Array.isArray(l)?l:[l]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${l.length} input tensors.`);return this.inputNodes.reduce((M,X,we)=>(M[X]=l[we],M),{})}normalizeOutputs(l){return l=l||this.outputNodes,Array.isArray(l)?l:[l]}execute(l,M){l=this.normalizeInputs(l),M=this.normalizeOutputs(M);const X=this.executor.execute(l,M);return X.length>1?X:X[0]}async executeAsync(l,M){l=this.normalizeInputs(l),M=this.normalizeOutputs(M);const X=await this.executor.executeAsync(l,M);return X.length>1?X:X[0]}convertTensorMapToTensorsMap(l){return Object.keys(l).reduce((M,X)=>(M[X]=[l[X]],M),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function ut(ee,l={}){if(null==ee)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==l&&(l={}),l.fromTFHub&&null==ee.load&&(ee.endsWith("/")||(ee+="/"),ee=`${ee}model.json?tfjs-format=file`);const M=new it(ee,l);return await M.load(),M}const Ue="3.9.0"},8713:(b,u,e)=>{e.d(u,{JL:()=>g,Zu:()=>n});class g{constructor(w,k){this.backend=w,this.dataMover=k,this.data=new WeakMap,this.dataIdsCount=0}get(w){return this.data.has(w)||this.dataMover.moveData(this.backend,w),this.data.get(w)}set(w,k){this.dataIdsCount++,this.data.set(w,k)}has(w){return this.data.has(w)}delete(w){return this.dataIdsCount--,this.data.delete(w)}numDataIds(){return this.dataIdsCount}}class n{refCount(w){return h("refCount")}incRef(w){return h("incRef")}timerAvailable(){return true}time(w){return h("time")}read(w){return h("read")}readSync(w){return h("readSync")}numDataIds(){return h("numDataIds")}disposeData(w,k){return h("disposeData")}write(w,k,I){return h("write")}move(w,k,I,T,c){return h("move")}memory(){return h("memory")}floatPrecision(){return h("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return h("dispose")}}function h(i){throw new Error(`'${i}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}},3337:(b,u,e)=>{function g(p,y,W){const L=function(K,re,J){return function(ve,ue,ie){let F=0,P=ve.length,f=0,Q=false;for(;F<P;){f=F+(P-F>>>1);const oe=ie(ue,ve[f]);oe>0?F=f+1:(P=f,Q=!oe)}return Q?F:-F-1}(K,re,J||n)}(p,y,W),R=L<0?-(L+1):L;p.splice(R,0,y)}function n(p,y){return p>y?1:p<y?-1:0}function h(p,y,W,L,R){return k(p,y,W,L,R,0)}function i(p,y,W,L,R,K){return k(p,y,W,L,R,0,false,K,true)}function w(p,y,W,L,R,K){return k(p,y,W,L,R,K,true)}function k(p,y,W,L,R,K,re=false,J=false,ve=false){const ue=[];for(let se=0;se<y.length;se++)y[se]>R&&ue.push({score:y[se],boxIndex:se,suppressBeginIndex:0});ue.sort(c);const ie=K>0?-.5/K:0,F=[],P=[];for(;F.length<W&&ue.length>0;){const se=ue.pop(),{score:o,boxIndex:te,suppressBeginIndex:De}=se;if(o<R)break;let Ve=false;for(let ze=F.length-1;ze>=De;--ze){const Ke=I(p,te,F[ze]);if(Ke>=L){Ve=true;break}if(se.score=se.score*T(L,ie,Ke),se.score<=R)break}se.suppressBeginIndex=F.length,Ve||(se.score===o?(F.push(te),P.push(se.score)):se.score>R&&g(ue,se,c))}const f=F.length,Q=W-f;J&&Q>0&&(F.push(...new Array(Q).fill(0)),P.push(...new Array(Q).fill(0)));const oe={selectedIndices:F};return re&&(oe.selectedScores=P),ve&&(oe.validOutputs=f),oe}function I(p,y,W){const L=p.subarray(4*y,4*y+4),R=p.subarray(4*W,4*W+4),K=Math.min(L[0],L[2]),re=Math.min(L[1],L[3]),J=Math.max(L[0],L[2]),ve=Math.max(L[1],L[3]),ue=Math.min(R[0],R[2]),ie=Math.min(R[1],R[3]),F=Math.max(R[0],R[2]),P=Math.max(R[1],R[3]),f=(J-K)*(ve-re),Q=(F-ue)*(P-ie);if(f<=0||Q<=0)return 0;const oe=Math.max(K,ue),se=Math.max(re,ie),o=Math.min(J,F),te=Math.min(ve,P),De=Math.max(o-oe,0)*Math.max(te-se,0);return De/(f+Q-De)}function T(p,y,W){const L=Math.exp(y*W*W);return W<=p?L:0}function c(p,y){return p.score-y.score||p.score===y.score&&y.boxIndex-p.boxIndex}e.d(u,{GP:()=>h,qP:()=>i,pA:()=>w})},8333:(b,u,e)=>{e.d(u,{Z:()=>n});var g=e(2657);function n(h,i){const w=[];for(let T=0;T<i.length;T++)i[T]&&w.push(T);const k=(0,g.f)(h,"int32"),I=(0,g.f)([w.length,h.length],"int32");for(let T=0;T<w.length;T++){const c=k.indexToLoc(w[T]),p=T*h.length;I.values.set(c,p)}return I.toTensor()}},7097:(b,u,e)=>{e.d(u,{BV:()=>ve,wv:()=>J});var g=e(8713),n=e(2885),h=e(5938),i=e(9121),w=e(6151),k=e(9122),I=e(569);class T{constructor(F,P){this.backendTimer=F,this.logger=P,null==P&&(this.logger=new p)}profileKernel(F,P,f){let Q;const oe=()=>{Q=f()};let se;const o=k.now();if(this.backendTimer.timerAvailable())se=this.backendTimer.time(oe);else{oe();for(const te of Q)te.dataSync();se=Promise.resolve({kernelMs:k.now()-o})}if((0,n.OB)().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let te=0;te<Q.length;te++){const De=Q[te];De.data().then(Ve=>{c(Ve,De.dtype,F)})}return{kernelName:F,outputs:Q,inputs:P,timeMs:se.then(te=>te.kernelMs),extraInfo:se.then(te=>null!=te.getExtraProfileInfo?te.getExtraProfileInfo():"")}}logKernelProfile(F){const{kernelName:P,outputs:f,timeMs:Q,inputs:oe,extraInfo:se}=F;f.forEach(o=>{Promise.all([o.data(),Q,se]).then(te=>{this.logger.logKernelProfile(P,o,te[0],te[1],oe,te[2])})})}}function c(ie,F,P){if("float32"!==F)return false;for(let f=0;f<ie.length;f++){const Q=ie[f];if(isNaN(Q)||!isFinite(Q))return console.warn(`Found ${Q} in the result of '${P}'`),true}return false}class p{logKernelProfile(F,P,f,Q,oe,se){const o="number"==typeof Q?I.oj(`${Q}ms`,9):Q.error,te=I.oj(F,25),De=P.rank,Ve=P.size,ze=I.oj(P.shape.toString(),14);let Ke="";for(const Ye in oe){const rt=oe[Ye];if(null!=rt){const Qe=rt.shape||P.shape,tt=Qe.length;Ke+=`${Ye}: ${tt}D ${tt>0?Qe:""} `}}console.log(`%c${te}	%c${o}	%c${De}D ${ze}	%c${Ve}	%c${Ke}	%c${se}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}var y=e(4077),W=e(747),L=e(4706);function R(ie){return null!=ie.kernelName}class K{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=false,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(F=>F.name)))}}}dispose(){for(const F in this.registeredVariables)this.registeredVariables[F].dispose()}}class re{constructor(F){this.ENV=F,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new K}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then(()=>{});if(null!=this.backendInstance)return;const F=this.getSortedBackends();for(let P=0;P<F.length;P++){const f=F[P];if(await this.initializeBackend(f).success)return void await this.setBackend(f)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:F,asyncInit:P}=this.initializeBackendsAndReturnBest();if(P)throw new Error(`The highest priority backend '${F}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(F)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(F){if(!(F in this.registry)){if(!(F in this.registryFactory))return null;{const{asyncInit:P}=this.initializeBackend(F);if(P)return null}}return this.registry[F]}findBackendFactory(F){return F in this.registryFactory?this.registryFactory[F].factory:null}registerBackend(F,P,f=1){return F in this.registryFactory?(L.Z(`${F} backend was already registered. Reusing existing backend factory.`),false):(this.registryFactory[F]={factory:P,priority:f},true)}async setBackend(F){if(null==this.registryFactory[F])throw new Error(`Backend name '${F}' not found in registry`);if(this.backendName=F,null==this.registry[F]){this.backendInstance=null;const{success:P,asyncInit:f}=this.initializeBackend(F);if(!(f?await P:P))return false}return this.backendInstance=this.registry[F],this.setupRegisteredKernels(),this.profiler=new T(this.backendInstance),true}setupRegisteredKernels(){(0,w.tr)(this.backendName).forEach(F=>{null!=F.setupFunc&&F.setupFunc(this.backendInstance)})}disposeRegisteredKernels(F){(0,w.tr)(F).forEach(P=>{null!=P.disposeFunc&&P.disposeFunc(this.registry[F])})}initializeBackend(F){const P=this.registryFactory[F];if(null==P)throw new Error(`Cannot initialize backend ${F}, no registration found.`);try{const f=P.factory();if(!f||f instanceof g.Zu||"function"!=typeof f.then)return this.registry[F]=f,{success:true,asyncInit:false};{const Q=++this.pendingBackendInitId,oe=f.then(se=>!(Q<this.pendingBackendInitId)&&(this.registry[F]=se,this.pendingBackendInit=null,true)).catch(se=>(Q<this.pendingBackendInitId||(this.pendingBackendInit=null,L.Z(`Initialization of backend ${F} failed`),L.Z(se.stack||se.message)),false));return this.pendingBackendInit=oe,{success:oe,asyncInit:true}}}catch(f){return L.Z(`Initialization of backend ${F} failed`),L.Z(f.stack||f.message),{success:false,asyncInit:false}}}removeBackend(F){if(!(F in this.registryFactory))throw new Error(`${F} backend not found in registry`);this.backendName===F&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,F in this.registry&&(this.disposeRegisteredKernels(F),this.registry[F].dispose(),delete this.registry[F]),delete this.registryFactory[F],this.backendName===F&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((F,P)=>this.registryFactory[P].priority-this.registryFactory[F].priority)}initializeBackendsAndReturnBest(){const F=this.getSortedBackends();for(let P=0;P<F.length;P++){const f=F[P],{success:Q,asyncInit:oe}=this.initializeBackend(f);if(oe||Q)return{name:f,asyncInit:oe}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(F,P){const f=this.state.tensorInfo.get(P),Q=f.backend,oe=this.readSync(P),se=Q.refCount(P);Q.disposeData(P,true),f.backend=F,F.move(P,oe,f.shape,f.dtype,se),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(F,P){let f,Q=null;if(null==P){if("function"!=typeof F)throw new Error("Please provide a function to tidy()");P=F}else{if("string"!=typeof F&&!(F instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof P)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");Q=F}return this.scopedRun(()=>this.startScope(Q),()=>this.endScope(f),()=>(f=P(),f instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),f))}scopedRun(F,P,f){F();try{const Q=f();return P(),Q}catch(Q){throw P(),Q}}nextTensorId(){return re.nextTensorId++}nextVariableId(){return re.nextVariableId++}clone(F){const P=ve.runKernel(i.iJ,{x:F}),f={x:F};return this.addTapeNode(this.state.activeScope.name,f,[P],Q=>({x:()=>{const oe={x:Q},se={dtype:"float32"};return ve.runKernel(i.RF,oe,se)}}),[],{}),P}runKernel(F,P,f){null==this.backendName&&this.backend;if(!(null!=(0,w.pI)(F,this.backendName)))throw new Error(`Kernel '${F}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:F,inputs:P,attrs:f})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(F,P,f){const Q=this.backend.numDataIds();let oe=0;f.forEach(te=>{oe+="complex64"===te.dtype?3:1});const se=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=Q-P-oe-se;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${F}'`)}runKernelFunc(F){let P,f=[];const Q=this.isTapeOn(),oe=this.state.numBytes,se=this.state.numTensors;let o,te;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const De=R(F)?F.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(R(F)){const{kernelName:rt,inputs:Qe,attrs:tt}=F;null==this.backendName&&this.backend;const Nt=(0,w.pI)(rt,this.backendName);I.hu(null!=Nt,()=>`Cannot find registered kernel '${rt}' for backend '${this.backendName}'`),o=()=>{const $t=this.backend.numDataIds();te=Nt.kernelFunc({inputs:Qe,attrs:tt,backend:this.backend});const Ct=Array.isArray(te)?te:[te];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(rt,$t,Ct);const Ot=Ct.map(zt=>{if(null!=zt.rank)return zt;const{dataId:Ht,shape:tn,dtype:qt}=zt;return this.makeTensorFromDataId(Ht,tn,qt)});if(Q){const zt=this.getTensorsForGradient(rt,Qe,Ot);f=this.saveTensorsForBackwardMode(zt)}return Ot}}else{const{forwardFunc:rt}=F,Qe=tt=>{Q&&(f=tt.map(Nt=>this.keep(this.clone(Nt))))};o=()=>{const tt=this.backend.numDataIds();te=this.tidy(()=>rt(this.backend,Qe));const Nt=Array.isArray(te)?te:[te];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(De,tt,Nt),Nt}}const{inputs:Ve,attrs:ze}=F,Ke=R(F)?null:F.backwardsFunc;let Ye;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(Ye=this.profiler.profileKernel(De,Ve,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(Ye),P=Ye.outputs):P=o()}),Q&&this.addTapeNode(De,Ve,P,Ke,f,ze),this.state.profiling&&this.state.activeProfile.kernels.push({name:De,bytesAdded:this.state.numBytes-oe,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-se,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(Ve).map(rt=>null!=Ve[rt]?Ve[rt].shape:null),outputShapes:P.map(rt=>rt.shape),kernelTimeMs:Ye.timeMs,extraInfo:Ye.extraInfo}),Array.isArray(te)?P:P[0]}saveTensorsForBackwardMode(F){return F.map(P=>this.keep(this.clone(P)))}getTensorsForGradient(F,P,f){const Q=(0,w.uk)(F);if(null!=Q){const oe=Q.inputsToSave||[],se=Q.outputsToSave||[];let o;Q.saveAllInputs?(I.hu(Array.isArray(P),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(P).map(De=>P[De])):o=oe.map(De=>P[De]);const te=f.filter((De,Ve)=>se[Ve]);return o.concat(te)}return[]}makeTensor(F,P,f,Q){if(null==F)throw new Error("Values passed to engine.makeTensor() are null");f=f||"float32",Q=Q||this.backend;let oe=F;"string"===f&&I.HD(F[0])&&(oe=F.map(te=>k.encodeString(te)));const se=Q.write(oe,P,f),o=new y.es(P,f,se,this.nextTensorId());if(this.trackTensor(o,Q),"string"===f){const te=this.state.tensorInfo.get(se),De=(0,I.Ub)(oe);this.state.numBytes+=De-te.bytes,te.bytes=De}return o}makeTensorFromDataId(F,P,f,Q){f=f||"float32";const oe=new y.es(P,f,F,this.nextTensorId());return this.trackTensor(oe,Q),oe}makeVariable(F,P=true,f,Q){f=f||this.nextVariableId().toString(),null!=Q&&Q!==F.dtype&&(F=F.cast(Q));const oe=new y._w(F,P,f,this.nextTensorId());if(null!=this.state.registeredVariables[oe.name])throw new Error(`Variable with name ${oe.name} was already registered`);return this.state.registeredVariables[oe.name]=oe,this.incRef(oe,this.backend),oe}trackTensor(F,P){this.state.numTensors++,"string"===F.dtype&&this.state.numStringTensors++;let f=0;"complex64"!==F.dtype&&"string"!==F.dtype&&(f=F.size*I.bT(F.dtype)),this.state.numBytes+=f,this.state.tensorInfo.has(F.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(F.dataId,{backend:P||this.backend,dtype:F.dtype,shape:F.shape,bytes:f})),F instanceof y._w||this.track(F)}incRef(F,P){this.trackTensor(F,P),this.backend.incRef(F.dataId)}removeDataId(F,P){this.state.tensorInfo.has(F)&&this.state.tensorInfo.get(F).backend===P&&(this.state.tensorInfo.delete(F),this.state.numDataBuffers--)}disposeTensor(F){if(!this.state.tensorInfo.has(F.dataId))return;const P=this.state.tensorInfo.get(F.dataId);if(this.state.numTensors--,"string"===F.dtype&&(this.state.numStringTensors--,this.state.numBytes-=P.bytes),"complex64"!==F.dtype&&"string"!==F.dtype){const f=F.size*I.bT(F.dtype);this.state.numBytes-=f}P.backend.disposeData(F.dataId)&&this.removeDataId(F.dataId,P.backend)}disposeVariables(){for(const F in this.state.registeredVariables){const P=this.state.registeredVariables[F];this.disposeVariable(P)}}disposeVariable(F){this.disposeTensor(F),null!=this.state.registeredVariables[F.name]&&delete this.state.registeredVariables[F.name]}memory(){const F=this.backend.memory();return F.numTensors=this.state.numTensors,F.numDataBuffers=this.state.numDataBuffers,F.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(F.unreliable=true,null==F.reasons&&(F.reasons=[]),F.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),F}async profile(F){this.state.profiling=true;const P=this.state.numBytes,f=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await F(),this.state.profiling=false,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(Q=>Q.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-P,this.state.activeProfile.newTensors=this.state.numTensors-f;for(const Q of this.state.activeProfile.kernels)Q.kernelTimeMs=await Q.kernelTimeMs,Q.extraInfo=await Q.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(F,P,f,Q,oe,se){const o={id:this.state.nextTapeNodeId++,kernelName:F,inputs:P,outputs:f,saved:oe},te=(0,w.uk)(F);null!=te&&(Q=te.gradFunc),null!=Q&&(o.gradient=De=>(De=De.map((Ve,ze)=>{if(null==Ve){const Ke=f[ze],Ye=I.wT(Ke.size,Ke.dtype);return this.makeTensor(Ye,Ke.shape,Ke.dtype)}return Ve}),Q(De.length>1?De:De[0],oe,se))),this.state.activeTape.push(o)}keep(F){return F.kept=true,F}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(F){const P={track:[],name:"unnamed scope",id:this.state.nextScopeId++};F&&(P.name=F),this.state.scopeStack.push(P),this.state.activeScope=P}endScope(F){const P=(0,W.getTensorsInContainer)(F),f=new Set(P.map(oe=>oe.id));for(let oe=0;oe<this.state.activeScope.track.length;oe++){const se=this.state.activeScope.track[oe];se.kept||f.has(se.id)||se.dispose()}const Q=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],P.forEach(oe=>{oe.kept||oe.scopeId!==Q.id||this.track(oe)})}gradients(F,P,f,Q=false){if(I.hu(P.length>0,()=>"gradients() received an empty list of xs."),null!=f&&"float32"!==f.dtype)throw new Error(`dy must have 'float32' dtype, but has '${f.dtype}'`);const oe=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",F));I.hu(oe instanceof y.es,()=>"The result y returned by f() must be a tensor.");const se=function(o,te,De){const Ve={},ze={};for(let Qe=0;Qe<te.length;Qe++)Ve[te[Qe].id]=true;for(let Qe=0;Qe<o.length;Qe++){const tt=o[Qe],Nt=tt.inputs;for(const $t in Nt){const Ct=Nt[$t];let Ot=false;for(let zt=0;zt<te.length;zt++)if(Ve[Ct.id]){tt.outputs.forEach(Ht=>Ve[Ht.id]=true),Ot=true,ze[tt.id]=true;break}if(Ot)break}}const Ke={};Ke[De.id]=true;const Ye={};for(let Qe=o.length-1;Qe>=0;Qe--){const tt=o[Qe],Nt=tt.inputs;for(let $t=0;$t<tt.outputs.length;$t++)if(Ke[tt.outputs[$t].id]){for(const Ct in Nt)Ke[Nt[Ct].id]=true,Ye[tt.id]=true;break}}const rt=[];for(let Qe=0;Qe<o.length;Qe++){const tt=o[Qe];if(ze[tt.id]&&Ye[tt.id]){const Nt={};for(const Ct in tt.inputs){const Ot=tt.inputs[Ct];Ve[Ot.id]&&(Nt[Ct]=Ot)}const $t=Object.assign({},tt);$t.inputs=Nt,$t.outputs=tt.outputs,rt.push($t)}}return rt}(this.state.activeTape,P,oe);if(!Q&&0===se.length&&P.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const o={};o[oe.id]=null==f?function(De){const Ve=(0,I.p8)((0,I.NA)(De),"float32");return ve.makeTensor(Ve,De,"float32")}(oe.shape):f,function(De,Ve,ze,Ke){for(let Ye=Ve.length-1;Ye>=0;Ye--){const rt=Ve[Ye],Qe=[];if(rt.outputs.forEach(Nt=>{const $t=De[Nt.id];null!=$t?Qe.push($t):Qe.push(null)}),null==rt.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${rt.kernelName}.`);const tt=rt.gradient(Qe);for(const Nt in rt.inputs){if(!(Nt in tt))throw new Error(`Cannot backprop through input ${Nt}. Available gradients found: ${Object.keys(tt)}.`);const $t=ze(()=>tt[Nt]());if("float32"!==$t.dtype)throw new Error(`Error in gradient for op ${rt.kernelName}. The gradient of input ${Nt} must have 'float32' dtype, but has '${$t.dtype}'`);const Ct=rt.inputs[Nt];if(!I.cO($t.shape,Ct.shape))throw new Error(`Error in gradient for op ${rt.kernelName}. The gradient of input '${Nt}' has shape '${$t.shape}', which does not match the shape of the input '${Ct.shape}'`);if(null==De[Ct.id])De[Ct.id]=$t;else{const Ot=De[Ct.id];De[Ct.id]=Ke(Ot,$t),Ot.dispose()}}}}(o,se,De=>this.tidy(De),ue);const te=P.map(De=>o[De.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(De=>{for(const Ve of De.saved)Ve.dispose()}),this.state.activeTape=null),{value:oe,grads:te}})}customGrad(F){return I.hu(I.mf(F),()=>"The f passed in customGrad(f) must be a function."),(...P)=>{let f;I.hu(P.every(oe=>oe instanceof y.es),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const Q={};P.forEach((oe,se)=>{Q[se]=oe});return this.runKernelFunc({forwardFunc:(oe,se)=>(f=F(...P,se),I.hu(f.value instanceof y.es,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),I.hu(I.mf(f.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),f.value),backwardsFunc:(oe,se)=>{const o=f.gradFunc(oe,se),te=Array.isArray(o)?o:[o];I.hu(te.length===P.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),I.hu(te.every(Ve=>Ve instanceof y.es),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const De={};return te.forEach((Ve,ze)=>{De[ze]=()=>Ve}),De},inputs:Q})}}readSync(F){return this.state.tensorInfo.get(F).backend.readSync(F)}read(F){return this.state.tensorInfo.get(F).backend.read(F)}async time(F){const P=(0,k.now)(),f=await this.backend.time(F);return f.wallMs=(0,k.now)()-P,f}track(F){return null!=this.state.activeScope&&(F.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(F)),F}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new K;for(const F in this.registry)this.disposeRegisteredKernels(F),this.registry[F].dispose(),delete this.registry[F];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function J(){const ie=(0,h.D)();if(null==ie._tfengine){const F=new n.qA(ie);ie._tfengine=new re(F)}return(0,n.iG)(ie._tfengine.ENV),(0,y.Vi)(()=>ie._tfengine),ie._tfengine}re.nextTensorId=0,re.nextVariableId=0;const ve=J();function ue(ie,F){const P={a:ie,b:F};return ve.runKernel(i.mm,P)}},2885:(b,u,e)=>{e.d(u,{qA:()=>i,OB:()=>k,Vi:()=>I,iG:()=>T});var g=e(569),n=e(4706);const h="tfjsflags";class i{constructor(p){this.global=p,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=w,this.populateURLFlags()}setPlatform(p,y){null!=this.platform&&n.Z(`Platform ${this.platformName} has already been set. Overwriting the platform with ${y}.`),this.platformName=p,this.platform=y}registerFlag(p,y,W){if(this.flagRegistry[p]={evaluationFn:y,setHook:W},null!=this.urlFlags[p]){const L=this.urlFlags[p];n.Z(`Setting feature override from URL ${p}: ${L}.`),this.set(p,L)}}async getAsync(p){return p in this.flags||(this.flags[p]=await this.evaluateFlag(p)),this.flags[p]}get(p){if(p in this.flags)return this.flags[p];const y=this.evaluateFlag(p);if((0,g.tI)(y))throw new Error(`Flag ${p} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[p]=y,this.flags[p]}getNumber(p){return this.get(p)}getBool(p){return this.get(p)}getFlags(){return this.flags}get features(){return this.flags}set(p,y){if(null==this.flagRegistry[p])throw new Error(`Cannot set flag ${p} as it has not been registered.`);this.flags[p]=y,null!=this.flagRegistry[p].setHook&&this.flagRegistry[p].setHook(y)}evaluateFlag(p){if(null==this.flagRegistry[p])throw new Error(`Cannot evaluate flag '${p}': no evaluation function found.`);return this.flagRegistry[p].evaluationFn()}setFlags(p){this.flags=Object.assign({},p)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const p=this.getQueryParams(this.global.location.search);if(h in p){p.tfjsflags.split(",").forEach(y=>{const[W,L]=y.split(":");this.urlFlags[W]=function(R,K){if("true"===(K=K.toLowerCase())||"false"===K)return"true"===K;if(""+ +K===K)return+K;throw new Error(`Could not parse value flag value ${K} for flag ${R}.`)}(W,L)})}}}function w(c){const p={};return c.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(y,...W)=>(function(L,R,K){L[decodeURIComponent(R)]=decodeURIComponent(K||"")}(p,W[0],W[1]),W.join("="))),p}function k(){return I}let I=null;function T(c){I=c}},5938:(b,u,e)=>{let g;function n(){if(null==g){let i;if("undefined"!=typeof window)i=window;else if("undefined"!=typeof ko)i=ko;else if("undefined"!=typeof process)i=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");i=self}g=i}return g}function h(i,w){const k=function(){const I=n();return null==I._tfGlobals&&(I._tfGlobals=new Map),I._tfGlobals}();if(k.has(i))return k.get(i);{const I=w();return k.set(i,I),k.get(i)}}e.d(u,{D:()=>n,R:()=>h})},4368:(b,u,e)=>{e.d(u,{G4:()=>w,R:()=>k,cF:()=>I,MX:()=>T,N8:()=>c,SR:()=>p,sq:()=>y,N5:()=>W,lu:()=>L,B9:()=>R,Cn:()=>K,XV:()=>re,CQ:()=>J,Cd:()=>ve,N_:()=>ue,cj:()=>ie,x3:()=>F,ze:()=>P,jq:()=>f,y3:()=>Q,VY:()=>oe});var g=e(7097),n=e(2885),h=e(4077),i=e(747);function w(){(0,n.OB)().set("PROD",true)}function k(){(0,n.OB)().set("DEBUG",true)}function I(){(0,n.OB)().set("DEPRECATION_WARNINGS_ENABLED",false),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function T(se){(0,n.OB)().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(se+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function c(){g.BV.disposeVariables()}function p(){return g.BV}function y(){return g.BV.memory()}function W(se){return g.BV.profile(se)}function L(se,o){return g.BV.tidy(se,o)}function R(se){(0,i.getTensorsInContainer)(se).forEach(o=>o.dispose())}function K(se){return g.BV.keep(se)}function re(se){return g.BV.time(se)}function J(se){return g.BV.setBackend(se)}function ve(){return g.BV.ready()}function ue(){return g.BV.backendName}function ie(se){g.BV.removeBackend(se)}function F(se){return g.BV.findBackend(se)}function P(se){return g.BV.findBackendFactory(se)}function f(se,o,te=1){return g.BV.registerBackend(se,o,te)}function Q(){return g.BV.backend}function oe(se,o){(0,n.OB)().setPlatform(se,o)}(0,h.FZ)(T)},633:(b,u,e)=>{e.d(u,{cb:()=>p,pn:()=>c,h7:()=>I,fN:()=>T,UQ:()=>w,ti:()=>k});var g=e(7097),n=e(4077),h=e(3740),i=e(569);function w(W){return i.hu(i.mf(W),()=>"The f passed in grad(f) must be a function"),(L,R)=>{const K=(0,h._1)(L,"x","tf.grad","string_or_numeric"),re=null!=R?(0,h._1)(R,"dy","tf.grad"):null;return g.BV.tidy(()=>{const{value:J,grads:ve}=g.BV.gradients(()=>W(K),[K],re);return null!=re&&i.k5(J.shape,re.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),y(ve),ve[0]})}}function k(W){return i.hu(i.mf(W),()=>"The f passed in grads(f) must be a function"),(L,R)=>{i.hu(Array.isArray(L),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const K=(0,h.sI)(L,"args","tf.grads","string_or_numeric"),re=null!=R?(0,h._1)(R,"dy","tf.grads"):null;return g.BV.tidy(()=>{const{value:J,grads:ve}=g.BV.gradients(()=>W(...K),K,re);return null!=re&&i.k5(J.shape,re.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),y(ve),ve})}}function I(W){return i.hu(i.mf(W),()=>"The f passed in valueAndGrad(f) must be a function"),(L,R)=>{i.hu(L instanceof n.es,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),i.hu(null==R||R instanceof n.es,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:K,value:re}=g.BV.gradients(()=>W(L),[L],R);return y(K),{grad:K[0],value:re}}}function T(W){return i.hu(i.mf(W),()=>"The f passed in valueAndGrads(f) must be a function"),(L,R)=>{i.hu(Array.isArray(L)&&L.every(re=>re instanceof n.es),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),i.hu(null==R||R instanceof n.es,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const K=g.BV.gradients(()=>W(...L),L,R);return null!=R&&i.k5(K.value.shape,R.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),y(K.grads),K}}function c(W,L){i.hu(i.mf(W),()=>"The f passed in variableGrads(f) must be a function"),i.hu(null==L||Array.isArray(L)&&L.every(ie=>ie instanceof n._w),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const R=null!=L;if(!R){L=[];for(const ie in g.BV.registeredVariables)L.push(g.BV.registeredVariables[ie])}const K=R?L.filter(ie=>!ie.trainable):null,re=L.length;L=L.filter(ie=>ie.trainable),i.hu(L.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${re} variables is trainable.`);const{value:J,grads:ve}=g.BV.gradients(W,L,null,true);i.hu(ve.some(ie=>null!=ie),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),i.hu(0===J.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${J.rank} tensor`);const ue={};return L.forEach((ie,F)=>{null!=ve[F]&&(ue[ie.name]=ve[F])}),null!=K&&K.forEach(ie=>ue[ie.name]=null),{value:J,grads:ue}}function p(W){return g.BV.customGrad(W)}function y(W){if(W.filter(L=>null==L).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}},5363:(b,u,e)=>{e.r(u),e.d(u,{Abs:()=>Ce.SY,Acos:()=>Ce.VG,Acosh:()=>Ce.Sp,AdadeltaOptimizer:()=>Pr,AdagradOptimizer:()=>un,AdamOptimizer:()=>vr,AdamaxOptimizer:()=>Rr,Add:()=>Ce.mm,AddN:()=>Ce.Xz,All:()=>Ce.oT,Any:()=>Ce.IK,ArgMax:()=>Ce.sJ,ArgMin:()=>Ce.aJ,Asin:()=>Ce.M2,Asinh:()=>Ce.qw,Atan:()=>Ce.jM,Atan2:()=>Ce.QC,Atanh:()=>Ce.Oy,AvgPool:()=>Ce.Jh,AvgPool3D:()=>Ce._k,AvgPool3DGrad:()=>Ce.IM,AvgPoolGrad:()=>Ce.RO,BatchMatMul:()=>Ce.XL,BatchToSpaceND:()=>Ce.zw,Bincount:()=>Ce.zv,BroadcastArgs:()=>Ce.eE,BroadcastTo:()=>Ce.Ly,Cast:()=>Ce.RF,Ceil:()=>Ce.gJ,ClipByValue:()=>Ce.xn,Complex:()=>Ce.Zz,ComplexAbs:()=>Ce.yj,Concat:()=>Ce.Eh,Conv2D:()=>Ce.mh,Conv2DBackpropFilter:()=>Ce.wU,Conv2DBackpropInput:()=>Ce.wm,Conv3D:()=>Ce.x1,Conv3DBackpropFilterV2:()=>Ce.o2,Conv3DBackpropInputV2:()=>Ce.ik,Cos:()=>Ce.mc,Cosh:()=>Ce.TR,CropAndResize:()=>Ce.Vc,Cumsum:()=>Ce.iH,DataStorage:()=>Mr.JL,DenseBincount:()=>Ce.QR,DepthToSpace:()=>Ce.T0,DepthwiseConv2dNative:()=>Ce.ci,DepthwiseConv2dNativeBackpropFilter:()=>Ce.sL,DepthwiseConv2dNativeBackpropInput:()=>Ce.y7,Diag:()=>Ce.$w,Dilation2D:()=>Ce.p4,Dilation2DBackpropFilter:()=>Ce.Vn,Dilation2DBackpropInput:()=>Ce.ek,ENV:()=>K.Vi,Einsum:()=>Ce.$g,Elu:()=>Ce.SX,EluGrad:()=>Ce.HE,Environment:()=>K.qA,Equal:()=>Ce.hd,Erf:()=>Ce.Om,Exp:()=>Ce.NE,ExpandDims:()=>Ce.YF,Expm1:()=>Ce.Y0,FFT:()=>Ce.vw,Fill:()=>Ce.de,FlipLeftRight:()=>Ce.Uy,Floor:()=>Ce.OR,FloorDiv:()=>Ce.je,FromPixels:()=>Ce.eB,FusedBatchNorm:()=>Ce.sH,FusedConv2D:()=>Ce._V,FusedDepthwiseConv2D:()=>Ce.lu,GatherNd:()=>Ce.q1,GatherV2:()=>Ce.qi,Greater:()=>Ce.iZ,GreaterEqual:()=>Ce.Ac,IFFT:()=>Ce.Qg,Identity:()=>Ce.iJ,Imag:()=>Ce.J_,IsFinite:()=>Ce.av,IsInf:()=>Ce.iW,IsNan:()=>Ce.r7,KernelBackend:()=>Mr.Zu,LRN:()=>Ce.eZ,LRNGrad:()=>Ce.Hh,LeakyRelu:()=>Ce.J$,Less:()=>Ce.vt,LessEqual:()=>Ce.CA,LinSpace:()=>Ce.e7,Log:()=>Ce.Zb,Log1p:()=>Ce.kU,LogSoftmax:()=>Ce.qC,LogicalAnd:()=>Ce.PY,LogicalNot:()=>Ce.Vf,LogicalOr:()=>Ce.MZ,Max:()=>Ce.Yo,MaxPool:()=>Ce.mT,MaxPool3D:()=>Ce.OA,MaxPool3DGrad:()=>Ce.OU,MaxPoolGrad:()=>Ce.OV,MaxPoolWithArgmax:()=>Ce.vF,Maximum:()=>Ce.BM,Mean:()=>Ce.q2,Min:()=>Ce.c1,Minimum:()=>Ce.q8,MirrorPad:()=>Ce.jQ,Mod:()=>Ce.Vb,MomentumOptimizer:()=>os,Multinomial:()=>Ce.NZ,Multiply:()=>Ce.wY,Neg:()=>Ce.ku,NonMaxSuppressionV3:()=>Ce.uv,NonMaxSuppressionV4:()=>Ce.cy,NonMaxSuppressionV5:()=>Ce.W0,NotEqual:()=>Ce.yQ,OP_SCOPE_SUFFIX:()=>Ie.zvA,OneHot:()=>Ce.we,OnesLike:()=>Ce.qW,Optimizer:()=>dr,Pack:()=>Ce.Qi,PadV2:()=>Ce.ly,Pool:()=>Ce.Kg,Pow:()=>Ce.pe,Prelu:()=>Ce.o0,Prod:()=>Ce.Dl,RMSPropOptimizer:()=>is,Range:()=>Ce.e6,Rank:()=>us.yw,Real:()=>Ce.xJ,RealDiv:()=>Ce.oH,Reciprocal:()=>Ce.$H,Reduction:()=>Gs.I,Relu:()=>Ce.qk,Relu6:()=>Ce.Sb,Reshape:()=>Ce.HZ,ResizeBilinear:()=>Ce._Y,ResizeBilinearGrad:()=>Ce.zb,ResizeNearestNeighbor:()=>Ce.dp,ResizeNearestNeighborGrad:()=>Ce.Hm,Reverse:()=>Ce.mK,RotateWithOffset:()=>Ce.b9,Round:()=>Ce.e0,Rsqrt:()=>Ce.bV,SGDOptimizer:()=>hr,ScatterNd:()=>Ce.xQ,Select:()=>Ce.Ph,Selu:()=>Ce.oF,Sigmoid:()=>Ce.a5,Sign:()=>Ce.i5,Sin:()=>Ce.RQ,Sinh:()=>Ce.w3,Slice:()=>Ce.p2,Softmax:()=>Ce.Gc,Softplus:()=>Ce.MR,SpaceToBatchND:()=>Ce.TQ,SparseFillEmptyRows:()=>Ce.O3,SparseReshape:()=>Ce.nh,SparseSegmentMean:()=>Ce.YW,SparseSegmentSum:()=>Ce.Zj,SparseToDense:()=>Ce.D2,SplitV:()=>Ce.L8,Sqrt:()=>Ce.FK,Square:()=>Ce.bK,SquaredDifference:()=>Ce._t,Step:()=>Ce.h8,StridedSlice:()=>Ce.m2,StringNGrams:()=>Ce._J,StringSplit:()=>Ce.s1,StringToHashBucketFast:()=>Ce.Xk,Sub:()=>Ce.Tr,Sum:()=>Ce.GB,Tan:()=>Ce.sE,Tanh:()=>Ce.MI,Tensor:()=>ir.es,TensorBuffer:()=>ir.YD,Tile:()=>Ce.n9,TopK:()=>Ce.cW,Transform:()=>Ce.wx,Transpose:()=>Ce.G3,Unique:()=>Ce.kp,Unpack:()=>Ce.To,UnsortedSegmentSum:()=>Ce.Qv,Variable:()=>ir._w,ZerosLike:()=>Ce.Ru,_FusedMatMul:()=>Ce.us,abs:()=>Ie.WnP,acos:()=>Ie.Khb,acosh:()=>Ie.__u,add:()=>Ie.IHx,addN:()=>Ie.QBD,all:()=>Ie.$6P,any:()=>Ie.YjB,argMax:()=>Ie.NqF,argMin:()=>Ie.vHJ,asin:()=>Ie.ZRM,asinh:()=>Ie.VfV,atan:()=>Ie.z4N,atan2:()=>Ie.fvJ,atanh:()=>Ie.C80,avgPool:()=>Ie.wS1,avgPool3d:()=>Ie.uR5,backend:()=>Bt.y3,backend_util:()=>p,basicLSTMCell:()=>Ie.zEQ,batchNorm:()=>Ie.tgs,batchNorm2d:()=>Ie.Dxk,batchNorm3d:()=>Ie.JY5,batchNorm4d:()=>Ie.p3b,batchToSpaceND:()=>Ie.E4h,bincount:()=>Ie.yE8,booleanMaskAsync:()=>Ie.anm,broadcastArgs:()=>Ie.XsQ,broadcastTo:()=>Ie.UFq,browser:()=>i,buffer:()=>Ie.f3b,cast:()=>Ie.pju,ceil:()=>Ie.mDi,clipByValue:()=>Ie.iUl,clone:()=>Ie.d9v,complex:()=>Ie.PYB,concat:()=>Ie.zoF,concat1d:()=>Ie.gME,concat2d:()=>Ie.Izb,concat3d:()=>Ie.MNy,concat4d:()=>Ie.ZaL,conv1d:()=>Ie.PAt,conv2d:()=>Ie.Tek,conv2dTranspose:()=>Ie.bc,conv3d:()=>Ie.pdZ,conv3dTranspose:()=>Ie.$QV,copyRegisteredKernels:()=>Gn.T3,cos:()=>Ie.mCk,cosh:()=>Ie.f9Y,cosineWindow:()=>Ie.mew,cumsum:()=>Ie.zbp,customGrad:()=>br.cb,denseBincount:()=>Ie.ppE,deprecationWarn:()=>Bt.MX,depthToSpace:()=>Ie.nTT,depthwiseConv2d:()=>Ie.B10,device_util:()=>g,diag:()=>Ie.Ka3,dilation2d:()=>Ie.WmZ,disableDeprecationWarnings:()=>Bt.cF,dispose:()=>Bt.B9,disposeVariables:()=>Bt.N8,div:()=>Ie.hiC,divNoNan:()=>Ie.NTj,dot:()=>Ie.AKD,dropout:()=>Ie.rvX,einsum:()=>Ie.WYO,elu:()=>Ie.pyx,enableDebugMode:()=>Bt.R,enableProdMode:()=>Bt.G4,enclosingPowerOfTwo:()=>Ie.GRh,engine:()=>Bt.SR,env:()=>K.OB,equal:()=>Ie.DgJ,erf:()=>Ie.qNN,exp:()=>Ie.Qqt,expandDims:()=>Ie.dt4,expm1:()=>Ie.t$B,eye:()=>Ie.iyy,fft:()=>Ie.kp_,fill:()=>Ie.hlL,findBackend:()=>Bt.x3,findBackendFactory:()=>Bt.ze,floor:()=>Ie.GWj,floorDiv:()=>Ie.qPi,fused:()=>Ie.imm,gather:()=>Ie.Iqj,gatherND:()=>Ie.dbB,gather_util:()=>w,getBackend:()=>Bt.N_,getGradient:()=>Gn.uk,getKernel:()=>Gn.pI,getKernelsForBackend:()=>Gn.tr,grad:()=>br.UQ,grads:()=>br.ti,greater:()=>Ie.pjt,greaterEqual:()=>Ie.brS,ifft:()=>Ie.Sxn,imag:()=>Ie.asL,image:()=>Ie.BHj,inTopKAsync:()=>Ie.V3u,io:()=>n,irfft:()=>Ie.wx0,isFinite:()=>Ie.xVT,isInf:()=>Ie.UWc,isNaN:()=>Ie.i2d,keep:()=>Bt.Cn,kernel_impls:()=>y,leakyRelu:()=>Ie.hi7,less:()=>Ie.d9m,lessEqual:()=>Ie.zN1,linalg:()=>Ie.$r2,linspace:()=>Ie.SX3,localResponseNormalization:()=>Ie.G9k,log:()=>Ie.cM7,log1p:()=>Ie.Krr,logSigmoid:()=>Ie.e_t,logSoftmax:()=>Ie.CmS,logSumExp:()=>Ie.l_t,logicalAnd:()=>Ie.HvI,logicalNot:()=>Ie.hJK,logicalOr:()=>Ie.K5V,logicalXor:()=>Ie.egP,losses:()=>Ie.MB5,matMul:()=>Ie.OI3,math:()=>h,max:()=>Ie.Fp7,maxPool:()=>Ie._sB,maxPool3d:()=>Ie.YQQ,maxPoolWithArgmax:()=>Ie.Ip$,maximum:()=>Ie.gWQ,mean:()=>Ie.J69,memory:()=>Bt.sq,meshgrid:()=>Ie.ry_,min:()=>Ie.VV$,minimum:()=>Ie.LTh,mirrorPad:()=>Ie.VdP,mod:()=>Ie.wQq,moments:()=>Ie.Gi7,movingAverage:()=>Ie.p_,mul:()=>Ie.dC7,multiRNNCell:()=>Ie.rq4,multinomial:()=>Ie.SJ_,neg:()=>Ie.W76,nextFrame:()=>fa,norm:()=>Ie.KOy,notEqual:()=>Ie.Quu,oneHot:()=>Ie.lfX,ones:()=>Ie.iUs,onesLike:()=>Ie.JpU,op:()=>Ie.op,outerProduct:()=>Ie.N2O,pad:()=>Ie.vku,pad1d:()=>Ie.pNR,pad2d:()=>Ie.koy,pad3d:()=>Ie.t1L,pad4d:()=>Ie.lGY,pool:()=>Ie.d_R,pow:()=>Ie.sQ3,prelu:()=>Ie.AL3,print:()=>Ie.S0v,prod:()=>Ie.WVs,profile:()=>Bt.N5,rand:()=>Ie.TN_,randomGamma:()=>Ie.wzB,randomNormal:()=>Ie.nGf,randomUniform:()=>Ie.LGj,range:()=>Ie.w6H,ready:()=>Bt.Cd,real:()=>Ie.kwC,reciprocal:()=>Ie.M25,registerBackend:()=>Bt.jq,registerGradient:()=>Gn.Li,registerKernel:()=>Gn.wC,relu:()=>Ie.UYe,relu6:()=>Ie.btT,removeBackend:()=>Bt.cj,reshape:()=>Ie.XLQ,reverse:()=>Ie.GYS,reverse1d:()=>Ie.SDf,reverse2d:()=>Ie.diP,reverse3d:()=>Ie.sx7,reverse4d:()=>Ie.mG2,rfft:()=>Ie.QEs,round:()=>Ie.NMM,rsqrt:()=>Ie.bp0,scalar:()=>Ie.iD$,scatterND:()=>Ie.snQ,scatter_util:()=>Fr,selu:()=>Ie.U8D,separableConv2d:()=>Ie.U_I,serialization:()=>I,setBackend:()=>Bt.CQ,setPlatform:()=>Bt.VY,setdiff1dAsync:()=>Ie.ODp,sigmoid:()=>Ie.XD2,sign:()=>Ie.Xxe,signal:()=>Ie.tdS,sin:()=>Ie.O$l,sinh:()=>Ie.R_K,slice:()=>Ie.tPi,slice1d:()=>Ie.jZU,slice2d:()=>Ie.SmN,slice3d:()=>Ie.CnO,slice4d:()=>Ie.p0P,slice_util:()=>k,softmax:()=>Ie.XAC,softplus:()=>Ie.Wvh,spaceToBatchND:()=>Ie.fBT,sparse:()=>Ie.rVs,sparseToDense:()=>Ie.ers,spectral:()=>Ie.uN7,split:()=>Ie.Vl2,sqrt:()=>Ie._b3,square:()=>Ie.h62,squaredDifference:()=>Ie.$i,squeeze:()=>Ie.L9e,stack:()=>Ie.knu,step:()=>Ie.Nbs,stridedSlice:()=>Ie.NXj,string:()=>Ie.Z_8,sub:()=>Ie.luU,sum:()=>Ie.Smz,sumOutType:()=>us.z4,tan:()=>Ie.ORZ,tanh:()=>Ie.AEp,tensor:()=>Ie.XeE,tensor1d:()=>Ie.RRF,tensor2d:()=>Ie.odF,tensor3d:()=>Ie.wOQ,tensor4d:()=>Ie.yXz,tensor5d:()=>Ie.Bfx,tensor6d:()=>Ie.xZs,tensor_util:()=>ua,test_util:()=>T,tidy:()=>Bt.lu,tile:()=>Ie.Gg6,time:()=>Bt.XV,topk:()=>Ie.hg7,train:()=>Ca,transpose:()=>Ie.p4s,truncatedNormal:()=>Ie.Xu6,unique:()=>Ie.Two,unregisterGradient:()=>Gn.bt,unregisterKernel:()=>Gn.nE,unsortedSegmentSum:()=>Ie.pUJ,unstack:()=>Ie.HHK,upcastType:()=>us.x8,util:()=>Tr,valueAndGrad:()=>br.h7,valueAndGrads:()=>br.fN,variable:()=>Ie.VD$,variableGrads:()=>br.pn,version_core:()=>xs,where:()=>Ie.arb,whereAsync:()=>Ie.itS,zeros:()=>Ie.lls,zerosLike:()=>Ie.P84});var g={};e.r(g),e.d(g,{isBrowser:()=>R,isMobile:()=>L});var n={};e.r(n),e.d(n,{browserFiles:()=>Gr,browserHTTPRequest:()=>oa,concatenateArrayBuffers:()=>se,copyModel:()=>Nn,decodeWeights:()=>P,encodeWeights:()=>F,fromMemory:()=>fs,getLoadHandlers:()=>tt,getModelArtifactsForJSON:()=>De,getModelArtifactsInfoForJSON:()=>Ve,getSaveHandlers:()=>Qe,http:()=>ps,isHTTPScheme:()=>Xr,listModels:()=>Xt,loadWeights:()=>Os,moveModel:()=>yn,registerLoadRouter:()=>rt,registerSaveRouter:()=>Ye,removeModel:()=>jt,weightsLoaderFactory:()=>Bs,withSaveHandler:()=>Dn});var h={};e.r(h),e.d(h,{confusionMatrix:()=>sn});var i={};e.r(i),e.d(i,{fromPixels:()=>zs,fromPixelsAsync:()=>Rs,toPixels:()=>Vs});var w={};e.r(w),e.d(w,{prepareAndValidate:()=>gs});var k={};e.r(k),e.d(k,{assertParamsValid:()=>Yr,computeFlatOffset:()=>Un,computeOutShape:()=>es,getNormalizedAxes:()=>bs,isSliceContinous:()=>Us,maskToAxes:()=>Kn,parseSliceParams:()=>vs,sliceInfo:()=>Br,startForAxis:()=>Ws,startIndicesWithElidedDims:()=>ks,stopForAxis:()=>ws,stopIndicesWithElidedDims:()=>Or,stridesForAxis:()=>ns,stridesWithElidedDims:()=>ys});var I={};e.r(I),e.d(I,{Serializable:()=>nr,SerializationMap:()=>cr,registerClass:()=>Fn});var T={};e.r(T),e.d(T,{TEST_EPSILON_FLOAT16:()=>cn,encodeStrings:()=>Hs,expectArrayBuffersEqual:()=>ha,expectArraysClose:()=>rs,expectArraysEqual:()=>ca,expectNumbersClose:()=>da,expectPromiseToFail:()=>la,expectValuesInRange:()=>qs,testEpsilon:()=>ss});var c={};e.r(c),e.d(c,{collectGatherOpShapeInfo:()=>Oa,computeOutShape:()=>ea,segOpComputeOptimalWindowSize:()=>Ys});var p={};e.r(p),e.d(p,{ERF_A1:()=>$a,ERF_A2:()=>Ka,ERF_A3:()=>ya,ERF_A4:()=>Xa,ERF_A5:()=>Is,ERF_P:()=>Ga,PARALLELIZE_THRESHOLD:()=>ma,SELU_SCALE:()=>ja,SELU_SCALEALPHA:()=>Ha,applyActivation:()=>Zs.QH,assertAndGetBroadcastShape:()=>Ks.$N,assertAxesAreInnerMostDims:()=>Pn.lB,assertParamsConsistent:()=>Xs,assignToTypedArray:()=>wa,axesAreInnerMostDims:()=>Pn.YB,calculateShapes:()=>Fr.calculateShapes,checkEinsumDimSizes:()=>Fa,combineLocations:()=>Pn.Vh,complexWithEvenIndex:()=>Es,complexWithOddIndex:()=>As,computeConv2DInfo:()=>Nr.Ix,computeConv3DInfo:()=>Nr.jw,computeDefaultPad:()=>Nr.aO,computeDilation2DInfo:()=>Nr.Rf,computeOptimalWindowSize:()=>ga,computeOutAndReduceShapes:()=>Pn.kz,computeOutShape:()=>_s,computePool2DInfo:()=>Nr.Xw,computePool3DInfo:()=>Nr.pl,convertConv2DDataFormat:()=>Nr.sl,decodeEinsumEquation:()=>eo,eitherStridesOrDilationsAreOne:()=>Nr.jT,expandShapeToKeepDim:()=>Pn.rv,exponent:()=>Ja,exponents:()=>Qa,fromStringArrayToUint8:()=>Na,fromUint8ToStringArray:()=>so,getAxesPermutation:()=>Pn.Q3,getBroadcastDims:()=>Ks.XF,getComplexWithIndex:()=>ka,getEinsumComputePath:()=>va,getEinsumPermutation:()=>to,getFusedBiasGradient:()=>Zs.pf,getFusedDyActivation:()=>Zs.Fr,getImageCenter:()=>rr,getInnerMostAxes:()=>Pn.sY,getPermuted:()=>Ts,getReductionAxes:()=>Ks.RR,getReshaped:()=>Ss,getReshapedPermuted:()=>Wa,getSliceBeginCoords:()=>Ua,getSliceSize:()=>qa,getUndoAxesPermutation:()=>Pn.LJ,isIdentityPermutation:()=>Js,log:()=>Qs.c,mergeRealAndImagArrays:()=>ba,prepareAndValidate:()=>gs,prepareSplitSize:()=>ro,segment_util:()=>c,shouldFuse:()=>Zs.uy,slice_util:()=>k,splitRealAndImagArrays:()=>Za,tupleValuesAreOne:()=>Nr.I0,upcastType:()=>us.x8,validateInput:()=>Fr.validateInput,validateUpdateShape:()=>Fr.validateUpdateShape,warn:()=>Qs.Z});var y={};e.r(y),e.d(y,{nonMaxSuppressionV3Impl:()=>xa.GP,nonMaxSuppressionV4Impl:()=>xa.qP,nonMaxSuppressionV5Impl:()=>xa.pA,whereImpl:()=>ta.Z});var W=e(7097);function L(B){if(B||"undefined"!=typeof navigator&&null!=navigator){if(B||(B=navigator),"ReactNative"===B.product)return true;const d=B.userAgent||B.vendor||("undefined"!=typeof window?window.opera:"");if(!d){const D=B;return D.userAgentData&&D.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(d)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(d.substr(0,4))}return false}function R(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}var K=e(2885);const re=(0,K.OB)();re.registerFlag("DEBUG",()=>false,B=>{B&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),re.registerFlag("IS_BROWSER",()=>R()),re.registerFlag("IS_NODE",()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node),re.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),re.registerFlag("PROD",()=>false),re.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>re.getBool("DEBUG")),re.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>true),re.registerFlag("IS_TEST",()=>false),re.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>true),re.registerFlag("WRAP_TO_IMAGEBITMAP",()=>false);var J=e(1661),ve=e(701),ue=e(569);const ie={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};async function F(B,d){const D=[],H=[],j=Array.isArray(B)?B.map(de=>de.name):Object.keys(B);for(let de=0;de<j.length;++de){const xe=j[de],Te=Array.isArray(B)?B[de].tensor:B[xe];if("float32"!==Te.dtype&&"int32"!==Te.dtype&&"bool"!==Te.dtype&&"string"!==Te.dtype&&"complex64"!==Te.dtype)throw new Error(`Unsupported dtype in weight '${xe}': ${Te.dtype}`);const Je={name:xe,shape:Te.shape,dtype:Te.dtype};if("string"===Te.dtype){const it=new Promise(async ut=>{const Ue=await Te.bytes(),ee=Ue.reduce((X,we)=>X+we.length,0)+4*Ue.length,l=new Uint8Array(ee);let M=0;for(let X=0;X<Ue.length;X++){const we=Ue[X],me=new Uint8Array(new Uint32Array([we.length]).buffer);l.set(me,M),M+=4,l.set(we,M),M+=we.length}ut(l)});H.push(it)}else H.push(Te.data());null!=d&&(Je.group=d),D.push(Je)}return{data:f(await Promise.all(H)),specs:D}}function P(B,d){const D={};let H,j=0;for(const de of d){const xe=de.name,Te=de.dtype,Je=de.shape,it=(0,ue.NA)(Je);let ut;if("quantization"in de){const Ue=de.quantization;if("uint8"===Ue.dtype||"uint16"===Ue.dtype){if(!("min"in Ue)||!("scale"in Ue))throw new Error(`Weight ${de.name} with quantization ${Ue.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==Ue.dtype)throw new Error(`Weight ${de.name} has unknown quantization dtype ${Ue.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==Te)throw new Error(`Weight ${de.name} is quantized with ${Ue.dtype} which only supports weights of type float32 not ${Te}.`)}const ee=ie[Ue.dtype],l=B.slice(j,j+it*ee),M="uint8"===Ue.dtype?new Uint8Array(l):new Uint16Array(l);if("float32"===Te)if("uint8"===Ue.dtype||"uint16"===Ue.dtype){ut=new Float32Array(M.length);for(let X=0;X<M.length;X++){const we=M[X];ut[X]=we*Ue.scale+Ue.min}}else{if("float16"!==Ue.dtype)throw new Error(`Unsupported quantization type ${Ue.dtype} for weight type float32.`);void 0===H&&(H=ze()),ut=H(M)}else{if("int32"!==Te)throw new Error(`Unsupported dtype in weight '${xe}': ${Te}`);if("uint8"!==Ue.dtype&&"uint16"!==Ue.dtype)throw new Error(`Unsupported quantization type ${Ue.dtype} for weight type int32.`);ut=new Int32Array(M.length);for(let X=0;X<M.length;X++){const we=M[X];ut[X]=Math.round(we*Ue.scale+Ue.min)}}j+=it*ee}else if("string"===Te){const Ue=(0,ue.NA)(de.shape);ut=[];for(let ee=0;ee<Ue;ee++){const l=new Uint32Array(B.slice(j,j+4))[0];j+=4;const M=new Uint8Array(B.slice(j,j+l));ut.push(M),j+=l}}else{const Ue=ie[Te],ee=B.slice(j,j+it*Ue);if("float32"===Te)ut=new Float32Array(ee);else if("int32"===Te)ut=new Int32Array(ee);else if("bool"===Te)ut=new Uint8Array(ee);else{if("complex64"!==Te)throw new Error(`Unsupported dtype in weight '${xe}': ${Te}`);{ut=new Float32Array(ee);const l=new Float32Array(ut.length/2),M=new Float32Array(ut.length/2);for(let me=0;me<l.length;me++)l[me]=ut[2*me],M[me]=ut[2*me+1];const X=(0,ve.X)(l,Je,"float32"),we=(0,ve.X)(M,Je,"float32");D[xe]=(0,J.P)(X,we),X.dispose(),we.dispose()}}j+=it*Ue}"complex64"!==Te&&(D[xe]=(0,ve.X)(ut,Je,Te))}return D}function f(B){if(null===B)throw new Error(`Invalid input value: ${JSON.stringify(B)}`);let d=0;const D=[];B.forEach(de=>{if(d+=de.byteLength,D.push(de.byteLength===de.buffer.byteLength?de:new de.constructor(de)),!(de instanceof Float32Array||de instanceof Int32Array||de instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${de.constructor.name}`)});const H=new Uint8Array(d);let j=0;return D.forEach(de=>{H.set(new Uint8Array(de.buffer),j),j+=de.byteLength}),H.buffer}const Q="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function oe(B){return Q?Buffer.byteLength(B):new Blob([B]).size}function se(B){if(1===B.length)return B[0];let d=0;B.forEach(j=>{d+=j.byteLength});const D=new Uint8Array(d);let H=0;return B.forEach(j=>{D.set(new Uint8Array(j),H),H+=j.byteLength}),D.buffer}function o(B){for(B=B.trim();B.endsWith("/");)B=B.slice(0,B.length-1);const d=B.split("/");return d[d.length-1]}function te(B,d){const D={modelTopology:B.modelTopology,format:B.format,generatedBy:B.generatedBy,convertedBy:B.convertedBy,weightsManifest:d};return null!=B.signature&&(D.signature=B.signature),null!=B.userDefinedMetadata&&(D.userDefinedMetadata=B.userDefinedMetadata),null!=B.modelInitializer&&(D.modelInitializer=B.modelInitializer),null!=B.trainingConfig&&(D.trainingConfig=B.trainingConfig),D}async function De(B,d){const D={modelTopology:B.modelTopology,format:B.format,generatedBy:B.generatedBy,convertedBy:B.convertedBy};if(null!=B.trainingConfig&&(D.trainingConfig=B.trainingConfig),null!=B.weightsManifest){const[H,j]=await d(B.weightsManifest);D.weightSpecs=H,D.weightData=j}return null!=B.signature&&(D.signature=B.signature),null!=B.userDefinedMetadata&&(D.userDefinedMetadata=B.userDefinedMetadata),null!=B.modelInitializer&&(D.modelInitializer=B.modelInitializer),D}function Ve(B){if(B.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==B.modelTopology?0:oe(JSON.stringify(B.modelTopology)),weightSpecsBytes:null==B.weightSpecs?0:oe(JSON.stringify(B.weightSpecs)),weightDataBytes:null==B.weightData?0:B.weightData.byteLength}}function ze(){const B=function(){const H=de=>{let xe=de<<13,Te=0;for(;0==(8388608&xe);)Te-=8388608,xe<<=1;return xe&=-8388609,Te+=947912704,xe|Te},j=new Uint32Array(2048);j[0]=0;for(let de=1;de<1024;de++)j[de]=H(de);for(let de=1024;de<2048;de++)j[de]=939524096+(de-1024<<13);return j}(),d=function(){const H=new Uint32Array(64);H[0]=0,H[31]=1199570944,H[32]=2147483648,H[63]=3347054592;for(let j=1;j<31;j++)H[j]=j<<23;for(let j=33;j<63;j++)H[j]=2147483648+(j-32<<23);return H}(),D=function(){const H=new Uint32Array(64);for(let j=0;j<64;j++)H[j]=1024;return H[0]=H[32]=0,H}();return H=>{const j=new ArrayBuffer(4*H.length),de=new Uint32Array(j);for(let xe=0;xe<H.length;xe++){const Te=H[xe],Je=B[D[Te>>10]+(1023&Te)]+d[Te>>10];de[xe]=Je}return new Float32Array(j)}}class Ke{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Ke.instance&&(Ke.instance=new Ke),Ke.instance}static registerSaveRouter(d){Ke.getInstance().saveRouters.push(d)}static registerLoadRouter(d){Ke.getInstance().loadRouters.push(d)}static getSaveHandlers(d){return Ke.getHandlers(d,"save")}static getLoadHandlers(d,D){return Ke.getHandlers(d,"load",D)}static getHandlers(d,D,H){const j=[];return("load"===D?Ke.getInstance().loadRouters:Ke.getInstance().saveRouters).forEach(de=>{const xe=de(d,H);null!==xe&&j.push(xe)}),j}}const Ye=B=>Ke.registerSaveRouter(B),rt=B=>Ke.registerLoadRouter(B),Qe=B=>Ke.getSaveHandlers(B),tt=(B,d)=>Ke.getLoadHandlers(B,d),Nt="tensorflowjs",$t="models_store",Ct="model_info_store";function Ot(){if(!(0,K.OB)().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const B="undefined"==typeof window?self:window,d=B.indexedDB||B.mozIndexedDB||B.webkitIndexedDB||B.msIndexedDB||B.shimIndexedDB;if(null==d)throw new Error("The current browser does not appear to support IndexedDB.");return d}function zt(B){const d=B.result;d.createObjectStore($t,{keyPath:"modelPath"}),d.createObjectStore(Ct,{keyPath:"modelPath"})}class Ht{constructor(d){if(this.indexedDB=Ot(),null==d||!d)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=d}async save(d){if(d.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,d)}async load(){return this.databaseAction(this.modelPath)}databaseAction(d,D){return new Promise((H,j)=>{const de=this.indexedDB.open(Nt,1);de.onupgradeneeded=()=>zt(de),de.onsuccess=()=>{const xe=de.result;if(null==D){const Te=xe.transaction($t,"readonly"),Je=Te.objectStore($t).get(this.modelPath);Je.onsuccess=()=>{if(null==Je.result)return xe.close(),j(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));H(Je.result.modelArtifacts)},Je.onerror=it=>(xe.close(),j(Je.error)),Te.oncomplete=()=>xe.close()}else{const Te=Ve(D),Je=xe.transaction(Ct,"readwrite");let it=Je.objectStore(Ct);const ut=it.put({modelPath:this.modelPath,modelArtifactsInfo:Te});let Ue;ut.onsuccess=()=>{Ue=xe.transaction($t,"readwrite");const ee=Ue.objectStore($t).put({modelPath:this.modelPath,modelArtifacts:D,modelArtifactsInfo:Te});ee.onsuccess=()=>H({modelArtifactsInfo:Te}),ee.onerror=l=>{it=Je.objectStore(Ct);const M=it.delete(this.modelPath);M.onsuccess=()=>(xe.close(),j(ee.error)),M.onerror=X=>(xe.close(),j(ee.error))}},ut.onerror=ee=>(xe.close(),j(ut.error)),Je.oncomplete=()=>{null==Ue?xe.close():Ue.oncomplete=()=>xe.close()}}},de.onerror=xe=>j(de.error)})}}Ht.URL_SCHEME="indexeddb://";const tn=B=>{return(0,K.OB)().getBool("IS_BROWSER")&&!Array.isArray(B)&&B.startsWith(Ht.URL_SCHEME)?(d=B.slice(Ht.URL_SCHEME.length),new Ht(d)):null;var d};Ke.registerSaveRouter(tn),Ke.registerLoadRouter(tn);class qt{constructor(){this.indexedDB=Ot()}async listModels(){return new Promise((d,D)=>{const H=this.indexedDB.open(Nt,1);H.onupgradeneeded=()=>zt(H),H.onsuccess=()=>{const j=H.result,de=j.transaction(Ct,"readonly"),xe=de.objectStore(Ct).getAll();xe.onsuccess=()=>{const Te={};for(const Je of xe.result)Te[Je.modelPath]=Je.modelArtifactsInfo;d(Te)},xe.onerror=Te=>(j.close(),D(xe.error)),de.oncomplete=()=>j.close()},H.onerror=j=>D(H.error)})}async removeModel(d){var D;return d=(D=d).startsWith(Ht.URL_SCHEME)?D.slice(Ht.URL_SCHEME.length):D,new Promise((H,j)=>{const de=this.indexedDB.open(Nt,1);de.onupgradeneeded=()=>zt(de),de.onsuccess=()=>{const xe=de.result,Te=xe.transaction(Ct,"readwrite"),Je=Te.objectStore(Ct),it=Je.get(d);let ut;it.onsuccess=()=>{if(null==it.result)return xe.close(),j(new Error(`Cannot find model with path '${d}' in IndexedDB.`));{const Ue=Je.delete(d),ee=()=>{ut=xe.transaction($t,"readwrite");const l=ut.objectStore($t).delete(d);l.onsuccess=()=>H(it.result.modelArtifactsInfo),l.onerror=M=>j(it.error)};Ue.onsuccess=ee,Ue.onerror=l=>(ee(),xe.close(),j(it.error))}},it.onerror=Ue=>(xe.close(),j(it.error)),Te.oncomplete=()=>{null==ut?xe.close():ut.oncomplete=()=>xe.close()}},de.onerror=xe=>j(de.error)})}}const Ut="/",Wt="tensorflowjs_models",Be="info",Fe="model_topology",Y="weight_specs",be="weight_data",ke="model_metadata";function We(B){return{info:[Wt,B,Be].join(Ut),topology:[Wt,B,Fe].join(Ut),weightSpecs:[Wt,B,Y].join(Ut),weightData:[Wt,B,be].join(Ut),modelMetadata:[Wt,B,ke].join(Ut)}}function yt(B){for(const d of Object.values(B))window.localStorage.removeItem(d)}function _t(B){const d=B.split(Ut);if(d.length<3)throw new Error(`Invalid key format: ${B}`);return d.slice(1,d.length-1).join(Ut)}class dt{constructor(d){if(!(0,K.OB)().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==d||!d)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=d,this.keys=We(this.modelPath)}async save(d){if(d.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const D=JSON.stringify(d.modelTopology),H=JSON.stringify(d.weightSpecs),j=Ve(d);try{this.LS.setItem(this.keys.info,JSON.stringify(j)),this.LS.setItem(this.keys.topology,D),this.LS.setItem(this.keys.weightSpecs,H),this.LS.setItem(this.keys.weightData,function(xe){if(Q)return Buffer.from(xe).toString("base64");const Te=new Uint8Array(xe);let Je="";for(let it=0,ut=Te.length;it<ut;it++)Je+=String.fromCharCode(Te[it]);return btoa(Je)}(d.weightData));const de={format:d.format,generatedBy:d.generatedBy,convertedBy:d.convertedBy,signature:null!=d.signature?d.signature:void 0,userDefinedMetadata:null!=d.userDefinedMetadata?d.userDefinedMetadata:void 0,modelInitializer:null!=d.modelInitializer?d.modelInitializer:void 0,trainingConfig:null!=d.trainingConfig?d.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(de)),{modelArtifactsInfo:j}}catch(de){throw yt(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${j.modelTopologyBytes}, weightSpecsBytes=${j.weightSpecsBytes}, weightDataBytes=${j.weightDataBytes}.`)}}}async load(){const d=JSON.parse(this.LS.getItem(this.keys.info));if(null==d)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==d.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const D={},H=JSON.parse(this.LS.getItem(this.keys.topology));if(null==H)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);D.modelTopology=H;const j=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==j)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);D.weightSpecs=j;const de=this.LS.getItem(this.keys.modelMetadata);if(null!=de){const Te=JSON.parse(de);D.format=Te.format,D.generatedBy=Te.generatedBy,D.convertedBy=Te.convertedBy,null!=Te.signature&&(D.signature=Te.signature),null!=Te.userDefinedMetadata&&(D.userDefinedMetadata=Te.userDefinedMetadata),null!=Te.modelInitializer&&(D.modelInitializer=Te.modelInitializer),null!=Te.trainingConfig&&(D.trainingConfig=Te.trainingConfig)}const xe=this.LS.getItem(this.keys.weightData);if(null==xe)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return D.weightData=function(Te){if(Q){const ut=Buffer.from(Te,"base64");return ut.buffer.slice(ut.byteOffset,ut.byteOffset+ut.byteLength)}const Je=atob(Te),it=new Uint8Array(Je.length);for(let ut=0;ut<Je.length;++ut)it.set([Je.charCodeAt(ut)],ut);return it.buffer}(xe),D}}dt.URL_SCHEME="localstorage://";const Ft=B=>{return(0,K.OB)().getBool("IS_BROWSER")&&!Array.isArray(B)&&B.startsWith(dt.URL_SCHEME)?(d=B.slice(dt.URL_SCHEME.length),new dt(d)):null;var d};Ke.registerSaveRouter(Ft),Ke.registerLoadRouter(Ft);class Yt{constructor(){(0,ue.hu)((0,K.OB)().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),(0,ue.hu)("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const d={},D=Wt+Ut,H=Ut+Be;for(let j=0;j<this.LS.length;++j){const de=this.LS.key(j);if(de.startsWith(D)&&de.endsWith(H)){d[_t(de)]=JSON.parse(this.LS.getItem(de))}}return d}async removeModel(d){var D;const H=We(d=(D=d).startsWith(dt.URL_SCHEME)?D.slice(dt.URL_SCHEME.length):D);if(null==this.LS.getItem(H.info))throw new Error(`Cannot find model at path '${d}'`);const j=JSON.parse(this.LS.getItem(H.info));return yt(H),j}}const fn="://";class an{constructor(){this.managers={}}static getInstance(){return null==an.instance&&(an.instance=new an),an.instance}static registerManager(d,D){(0,ue.hu)(null!=d,()=>"scheme must not be undefined or null."),d.endsWith(fn)&&(d=d.slice(0,d.indexOf(fn))),(0,ue.hu)(d.length>0,()=>"scheme must not be an empty string.");const H=an.getInstance();(0,ue.hu)(null==H.managers[d],()=>`A model store manager is already registered for scheme '${d}'.`),H.managers[d]=D}static getManager(d){const D=this.getInstance().managers[d];if(null==D)throw new Error(`Cannot find model manager for scheme '${d}'`);return D}static getSchemes(){return Object.keys(this.getInstance().managers)}}function gn(B){if(-1===B.indexOf(fn))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${an.getSchemes().join(",")}`);return{scheme:B.split(fn)[0],path:B.split(fn)[1]}}async function Rt(B,d,D=false){(0,ue.hu)(B!==d,()=>`Old path and new path are the same: '${B}'`);const H=Ke.getLoadHandlers(B);(0,ue.hu)(H.length>0,()=>`Copying failed because no load handler is found for source URL ${B}.`),(0,ue.hu)(H.length<2,()=>`Copying failed because more than one (${H.length}) load handlers for source URL ${B}.`);const j=H[0],de=Ke.getSaveHandlers(d);(0,ue.hu)(de.length>0,()=>`Copying failed because no save handler is found for destination URL ${d}.`),(0,ue.hu)(de.length<2,()=>`Copying failed because more than one (${H.length}) save handlers for destination URL ${d}.`);const xe=de[0],Te=gn(B).scheme,Je=gn(B).path,it=Te===gn(B).scheme,ut=await j.load();D&&it&&await an.getManager(Te).removeModel(Je);const Ue=await xe.save(ut);return D&&!it&&await an.getManager(Te).removeModel(Je),Ue.modelArtifactsInfo}async function Xt(){const B=an.getSchemes(),d={};for(const D of B){const H=await an.getManager(D).listModels();for(const j in H){d[D+fn+j]=H[j]}}return d}async function jt(B){const d=gn(B);return an.getManager(d.scheme).removeModel(d.path)}async function Nn(B,d){return Rt(B,d,false)}async function yn(B,d){return Rt(B,d,true)}class An{fetch(d,D){return fetch(d,D)}now(){return performance.now()}encode(d,D){if("utf-8"!==D&&"utf8"!==D)throw new Error(`Browser's encoder only supports utf-8, but got ${D}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(d)}decode(d,D){return new TextDecoder(D).decode(d)}}if((0,K.OB)().get("IS_BROWSER")){(0,K.OB)().setPlatform("browser",new An);try{an.registerManager(dt.URL_SCHEME,new Yt)}catch(B){}try{an.registerManager(Ht.URL_SCHEME,new qt)}catch(B){}}const vn=()=>e(7854);let Tn;class wn{constructor(){this.util=e(1669),this.textEncoder=new this.util.TextEncoder}fetch(d,D){return null!=(0,K.OB)().global.fetch?(0,K.OB)().global.fetch(d,D):(null==Tn&&(Tn=vn()),Tn(d,D))}now(){const d=process.hrtime();return 1e3*d[0]+d[1]/1e6}encode(d,D){if("utf-8"!==D&&"utf8"!==D)throw new Error(`Node built-in encoder only supports utf-8, but got ${D}`);return this.textEncoder.encode(d)}decode(d,D){return 0===d.length?"":new this.util.TextDecoder(D).decode(d)}}(0,K.OB)().get("IS_NODE")&&(0,K.OB)().setPlatform("node",new wn);var Mn=e(2657),fr=e(2271),Jn=e(8723),Hr=e(9798),ir=e(4077);(0,W.wv)();const Ds={buffer:Mn.f,cast:fr.p,clone:Jn.d,print:Hr.S};(0,ir.Vp)(Ds);function hs(B){return new Promise(d=>setTimeout(d)).then(B)}class ur{constructor(d){if(!(0,K.OB)().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");d.startsWith(ur.URL_SCHEME)&&(d=d.slice(ur.URL_SCHEME.length)),null!=d&&0!==d.length||(d="model"),this.modelJsonFileName=d+".json",this.weightDataFileName=d+".weights.bin"}async save(d){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const D=window.URL.createObjectURL(new Blob([d.weightData],{type:"application/octet-stream"}));if(d.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const H=te(d,[{paths:["./"+this.weightDataFileName],weights:d.weightSpecs}]),j=window.URL.createObjectURL(new Blob([JSON.stringify(H)],{type:"application/json"})),de=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(de.download=this.modelJsonFileName,de.href=j,await hs(()=>de.dispatchEvent(new MouseEvent("click"))),null!=d.weightData){const xe=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;xe.download=this.weightDataFileName,xe.href=D,await hs(()=>xe.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Ve(d)}}}}ur.URL_SCHEME="downloads://";class jr{constructor(d){if(null==d||d.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${d}`);this.jsonFile=d[0],this.weightsFiles=d.slice(1)}async load(){return new Promise((d,D)=>{const H=new FileReader;H.onload=j=>{const de=JSON.parse(j.target.result),xe=de.modelTopology;if(null==xe)return void D(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==de.weightsManifest)return void D(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void d({modelTopology:xe});const Te=De(de,Je=>this.loadWeights(Je));d(Te)},H.onerror=j=>D(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),H.readAsText(this.jsonFile)})}loadWeights(d){const D=[],H=[];for(const xe of d)D.push(...xe.weights),H.push(...xe.paths);const j=this.checkManifestAndWeightFiles(d),de=H.map(xe=>this.loadWeightsFile(xe,j[xe]));return Promise.all(de).then(xe=>[D,se(xe)])}loadWeightsFile(d,D){return new Promise((H,j)=>{const de=new FileReader;de.onload=xe=>{const Te=xe.target.result;H(Te)},de.onerror=xe=>j(`Failed to weights data from file of path '${d}'.`),de.readAsArrayBuffer(D)})}checkManifestAndWeightFiles(d){const D=[],H=this.weightsFiles.map(de=>o(de.name)),j={};for(const de of d)de.paths.forEach(xe=>{const Te=o(xe);if(-1!==D.indexOf(Te))throw new Error(`Duplicate file basename found in weights manifest: '${Te}'`);if(D.push(Te),-1===H.indexOf(Te))throw new Error(`Weight file with basename '${Te}' is not provided.`);j[xe]=this.weightsFiles[H.indexOf(Te)]});if(D.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${D.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return j}}function Gr(B){return new jr(B)}function $n(B,d,D,H){!function(de){(0,ue.hu)(null!=de&&Array.isArray(de)&&de.length>0,()=>"promises must be a none empty array")}(B),function(de,xe){(0,ue.hu)(de>=0&&de<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${de}`),(0,ue.hu)(xe>=0&&xe<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${xe}`),(0,ue.hu)(xe>=de,()=>`startFraction must be no more than endFraction, but got startFraction ${de} and endFraction ${xe}`)}(D=null==D?0:D,H=null==H?1:H);let j=0;return Promise.all(B.map(de=>(de.then(xe=>{const Te=D+ ++j/B.length*(H-D);return d(Te),xe}),de)))}async function Fs(B,d){null==d&&(d={});const D=null==d.fetchFunc?(0,K.OB)().platform.fetch:d.fetchFunc,H=B.map(de=>D(de,d.requestInit,{isBinary:true})),j=(null==d.onProgress?await Promise.all(H):await $n(H,d.onProgress,0,.5)).map(de=>de.arrayBuffer());return null==d.onProgress?await Promise.all(j):await $n(j,d.onProgress,.5,1)}async function Os(B,d="",D,H){return Bs(j=>Fs(j,{requestInit:H}))(B,d,D)}function Bs(B){return async(d,D="",H)=>{const j=d.map(()=>false),de={},xe=null!=H?H.map(()=>false):[],Te=[];if(d.forEach((l,M)=>{let X=0;l.weights.forEach(we=>{const me="quantization"in we?we.quantization.dtype:we.dtype,He=ie[me]*ue.NA(we.shape),Re=()=>{j[M]=true,null==de[M]&&(de[M]=[]),de[M].push({manifestEntry:we,groupOffset:X,sizeBytes:He})};null!=H?H.forEach((pt,_)=>{pt===we.name&&(Re(),xe[_]=true)}):Re(),Te.push(we.name),X+=He})}),!xe.every(l=>l)){const l=H.filter((M,X)=>!xe[X]);throw new Error(`Could not find weights in manifest with names: ${l.join(", ")}. 
Manifest JSON has weights with names: ${Te.join(", ")}.`)}const Je=j.reduce((l,M,X)=>(M&&l.push(X),l),[]),it=[];Je.forEach(l=>{d[l].paths.forEach(M=>{const X=D+(D.endsWith("/")?"":"/")+M;it.push(X)})});const ut=await B(it),Ue={};let ee=0;return Je.forEach(l=>{const M=d[l].paths.length;let X=0;for(let Re=0;Re<M;Re++)X+=ut[ee+Re].byteLength;const we=new ArrayBuffer(X),me=new Uint8Array(we);let He=0;for(let Re=0;Re<M;Re++){const pt=new Uint8Array(ut[ee+Re]);me.set(pt,He),He+=pt.byteLength}de[l].forEach(Re=>{const pt=P(we.slice(Re.groupOffset,Re.groupOffset+Re.sizeBytes),[Re.manifestEntry]);for(const _ in pt)Ue[_]=pt[_]}),ee+=M}),Ue}}Ke.registerSaveRouter(B=>(0,K.OB)().getBool("IS_BROWSER")&&!Array.isArray(B)&&B.startsWith(ur.URL_SCHEME)?function(d="model"){return new ur(d)}(B.slice(ur.URL_SCHEME.length)):null);class Kr{constructor(d,D){if(this.DEFAULT_METHOD="POST",null==D&&(D={}),this.weightPathPrefix=D.weightPathPrefix,this.onProgress=D.onProgress,this.weightUrlConverter=D.weightUrlConverter,null!=D.fetchFunc?((0,ue.hu)("function"==typeof D.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=D.fetchFunc):this.fetch=(0,K.OB)().platform.fetch,(0,ue.hu)(null!=d&&d.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(d)&&(0,ue.hu)(2===d.length,()=>`URL paths for http must have a length of 2, (actual length is ${d.length}).`),this.path=d,null!=D.requestInit&&null!=D.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=D.requestInit||{}}async save(d){if(d.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const D=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);D.body=new FormData;const H=te(d,[{paths:["./model.weights.bin"],weights:d.weightSpecs}]);D.body.append("model.json",new Blob([JSON.stringify(H)],{type:"application/json"}),"model.json"),null!=d.weightData&&D.body.append("model.weights.bin",new Blob([d.weightData],{type:"application/octet-stream"}),"model.weights.bin");const j=await this.fetch(this.path,D);if(j.ok)return{modelArtifactsInfo:Ve(d),responses:[j]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${j.status}.`)}async load(){const d=await this.fetch(this.path,this.requestInit);if(!d.ok)throw new Error(`Request to ${this.path} failed with status code ${d.status}. Please verify this URL points to the model JSON of the model to load.`);let D;try{D=await d.json()}catch(de){let xe=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?xe+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":xe+=" Please make sure the server is serving valid JSON for this request.",new Error(xe)}const H=D.modelTopology,j=D.weightsManifest;if(null==H&&null==j)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return De(D,de=>this.loadWeights(de))}async loadWeights(d){const D=Array.isArray(this.path)?this.path[1]:this.path,[H,j]=function(it){const ut=it.lastIndexOf("/"),Ue=it.lastIndexOf("?"),ee=it.substring(0,ut),l=Ue>ut?it.substring(Ue):"";return[ee+"/",l]}(D),de=this.weightPathPrefix||H,xe=[];for(const it of d)xe.push(...it.weights);const Te=[],Je=[];for(const it of d)for(const ut of it.paths)null!=this.weightUrlConverter?Je.push(this.weightUrlConverter(ut)):Te.push(de+ut+j);this.weightUrlConverter&&Te.push(...await Promise.all(Je));return[xe,se(await Fs(Te,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function Xr(B){return null!=B.match(Kr.URL_SCHEME_REGEX)}Kr.URL_SCHEME_REGEX=/^https?:\/\//;const Zr=(B,d)=>{if("undefined"==typeof fetch&&(null==d||null==d.fetchFunc))return null;{let D=true;if(D=Array.isArray(B)?B.every(H=>Xr(H)):Xr(B),D)return ps(B,d)}return null};function ps(B,d){return new Kr(B,d)}function oa(B,d){return ps(B,d)}Ke.registerSaveRouter(Zr),Ke.registerLoadRouter(Zr);class mr{constructor(d){this.modelArtifacts=d}async load(){return this.modelArtifacts}}class Ls{constructor(d){this.saveHandler=d}async save(d){return this.saveHandler(d)}}function fs(B,d,D,H){if(1===arguments.length){return null!=B.modelTopology||null!=B.weightSpecs?new mr(B):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new mr({modelTopology:B}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new mr({modelTopology:B,weightSpecs:d,weightData:D,trainingConfig:H})}function Dn(B){return new Ls(B)}var Sr=e(3740),Ps=e(8687),ms=e(6708),gr=e(2668),Dr=e(9065);const sn=(0,gr.op)({confusionMatrix_:function(B,d,D){const H=(0,Sr._1)(B,"labels","confusionMatrix"),j=(0,Sr._1)(d,"predictions","confusionMatrix");ue.hu(null==D||D>0&&Number.isInteger(D),()=>`If provided, numClasses must be a positive integer, but got ${D}`),ue.hu(1===H.rank,()=>`Expected the rank of labels to be 1, but got ${H.rank}`),ue.hu(1===j.rank,()=>`Expected the rank of predictions to be 1, but got ${j.rank}`),ue.hu(H.shape[0]===j.shape[0],()=>`Mismatch in the number of examples: ${H.shape[0]} vs. ${j.shape[0]}. Labels and predictions should have the same number of elements.`),ue.hu(D>0&&Number.isInteger(D),()=>`numClasses is required to be a positive integer, but got ${D}`);const de=(0,ms.l)((0,fr.p)(H,"int32"),D),xe=(0,ms.l)((0,fr.p)(j,"int32"),D),Te=(0,Dr.p)(de),Je=(0,Ps.O)(Te,xe);return(0,fr.p)(Je,"int32")}});var Ce=e(9121),Gn=e(6151),Qr=e(9906);let yr;function Jr(B,d=3){if(d>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==B)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let D=false,H=false,j=false,de=false,xe=false,Te=false;if(B.data instanceof Uint8Array)D=true;else if("undefined"!=typeof ImageData&&B instanceof ImageData)H=true;else if("undefined"!=typeof HTMLVideoElement&&B instanceof HTMLVideoElement)j=true;else if("undefined"!=typeof HTMLImageElement&&B instanceof HTMLImageElement)de=true;else if(null!=B.getContext)xe=true;else{if(!("undefined"!=typeof ImageBitmap&&B instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${B.constructor.name}`);Te=true}if(j){const l=2;if(j&&B.readyState<l)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=(0,Gn.pI)(Ce.eB,W.BV.backendName)){const l={pixels:B},M={numChannels:d};return W.BV.runKernel(Ce.eB,l,M)}const[Je,it]=j?[B.videoWidth,B.videoHeight]:[B.width,B.height];let ut,Ue;if(xe?ut=B.getContext("2d").getImageData(0,0,Je,it).data:H||D?ut=B.data:(de||j||Te)&&(null==yr&&(yr=document.createElement("canvas").getContext("2d")),yr.canvas.width=Je,yr.canvas.height=it,yr.drawImage(B,0,0,Je,it),ut=yr.getImageData(0,0,Je,it).data),4===d)Ue=new Int32Array(ut);else{const l=Je*it;Ue=new Int32Array(l*d);for(let M=0;M<l;M++)for(let X=0;X<d;++X)Ue[M*d+X]=ut[4*M+X]}const ee=[it,Je,d];return(0,Qr.w)(Ue,ee,"int32")}function ia(B){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(B instanceof ImageBitmap)&&function(d){return null!=d&&0!==d.width&&0!==d.height}(B)&&!function(d){return null!=d&&d.data instanceof Uint8Array}(B)}async function Rs(B,d=3){let D=null;if((0,K.OB)().getBool("WRAP_TO_IMAGEBITMAP")&&ia(B)){let H;try{H=await createImageBitmap(B,{premultiplyAlpha:"none"})}catch(j){H=null}D=null!=H&&H.width===B.width&&H.height===B.height?H:B}else D=B;return Jr(D,d)}async function Vs(B,d){let D=(0,Sr._1)(B,"img","toPixels");if(!(B instanceof ir.es)){const it=D;D=(0,fr.p)(it,"int32"),it.dispose()}if(2!==D.rank&&3!==D.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${D.rank}.`);const[H,j]=D.shape.slice(0,2),de=2===D.rank?1:D.shape[2];if(de>4||2===de)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${de}`);if("float32"!==D.dtype&&"int32"!==D.dtype)throw new Error(`Unsupported type for toPixels: ${D.dtype}. Please use float32 or int32 tensors.`);const xe=await D.data(),Te="float32"===D.dtype?255:1,Je=new Uint8ClampedArray(j*H*4);for(let it=0;it<H*j;++it){const ut=[0,0,0,255];for(let ee=0;ee<de;ee++){const l=xe[it*de+ee];if("float32"===D.dtype){if(l<0||l>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${l}.`)}else if("int32"===D.dtype&&(l<0||l>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${l}.`);1===de?(ut[0]=l*Te,ut[1]=l*Te,ut[2]=l*Te):ut[ee]=l*Te}const Ue=4*it;Je[Ue+0]=Math.round(ut[0]),Je[Ue+1]=Math.round(ut[1]),Je[Ue+2]=Math.round(ut[2]),Je[Ue+3]=Math.round(ut[3])}if(null!=d){d.width=j,d.height=H;const it=d.getContext("2d"),ut=new ImageData(Je,j,H);it.putImageData(ut,0,0)}return D!==B&&D.dispose(),Je}const zs=(0,gr.op)({fromPixels_:Jr});function gs(B,d){const D=B.shape.length,H=d.shape.length;if(D<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${D}.`);if(H<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${H}.`);if("int32"!==d.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${d.dtype}.`);if(d.shape[H-1]>D)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${d.shape[H-1]} vs. ${D}`);if(0===(0,ue.NA)(B.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${B.shape}.`);const j=d.shape,de=j[j.length-1];let xe=1;for(let Ue=0;Ue<j.length-1;++Ue)xe*=j[Ue];const Te=B.shape,Je=j.slice();Je.pop();let it=1;for(let Ue=de;Ue<D;++Ue)it*=Te[Ue],Je.push(Te[Ue]);const ut=[...(0,ue.e3)(B.shape).map(Ue=>Ue/it),1].slice(0,de);return[Je,xe,it,ut]}var Fr=e(3028);function Yr(B,d,D){const H=B.shape.length;ue.hu(H===d.length,()=>`Error in slice${H}D: Length of begin ${d} must match the rank of the array (${H}).`),ue.hu(H===D.length,()=>`Error in slice${H}D: Length of size ${D} must match the rank of the array (${H}).`);for(let j=0;j<H;++j)ue.hu(d[j]+D[j]<=B.shape[j],()=>`Error in slice${H}D: begin[${j}] + size[${j}] (${d[j]+D[j]}) would overflow input.shape[${j}] (${B.shape[j]})`)}function Kn(B){const d=[];let D=0;for(;B>0;)1&B&&d.push(D),B/=2,D++;return d}function es(B,d,D){const H=[];for(let j=0;j<B.length;j++)H[j]=Math.ceil((d[j]-B[j])/D[j]);return H}function ys(B,d,D,H){const j=[...B];for(let de=j.length;de<H.length;de++)j.push(1);for(let de=0;de<D;de++)0===de?j[d]=1:(j.splice(d,0,1),j.pop());return j}function lr(B,d,D){return D<=B?D:D-(d-1)}function ts(B,d){const D=[];for(let H=0;H<B;H++)D.push(d+H);return D}function bs(B,d,D,H,j,de,xe,Te,Je){const it=B.length;let ut=new Array(it),Ue=new Array(it),ee=new Array(it);if(d.length&&D>0){const l=d[0],M=D+1;ut=ks(xe,l,M,H,B),Ue=Or(Te,l,M,j,B),ee=ys(de,l,M,B)}else for(let l=0;l<it;l++)ut[l]=Ws(xe,H,de,B,l,Je),Ue[l]=ws(Te,j,de,B,l,Je),ee[l]=ns(de,l,Je);return{begin:ut,end:Ue,strides:ee}}function ks(B,d,D,H,j){const de=[...j],xe=ts(D,d);for(let Te=0;Te<de.length;Te++)if(xe.indexOf(Te)>-1)de[Te]=0;else{const Je=lr(d,D,Te);let it=H[Je];B&1<<Je&&(it=0),de[Te]=it}return de}function Or(B,d,D,H,j){const de=[...j],xe=ts(D,d);for(let Te=0;Te<de.length;Te++)if(xe.indexOf(Te)>-1)de[Te]=Number.MAX_SAFE_INTEGER;else{const Je=lr(d,D,Te);let it=H[Je];B&1<<Je&&(it=Number.MAX_SAFE_INTEGER),de[Te]=it}for(let Te=0;Te<de.length;Te++){const Je=j[Te];de[Te]<0&&(de[Te]+=Je),de[Te]=ue.uZ(0,de[Te],j[Te])}return de}function ns(B,d,D){let H=B[d];return(D&1<<d||null==H)&&(H=1),H}function Ws(B,d,D,H,j,de){let xe=d[j];const Te=D[j]||1;(B&1<<j||de&1<<j||null==xe)&&(xe=Te>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const Je=H[j];return xe<0&&(xe+=Je),xe=ue.uZ(0,xe,Je-1),xe}function ws(B,d,D,H,j,de){let xe=d[j];const Te=D[j]||1;(B&1<<j||de&1<<j||null==xe)&&(xe=Te>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const Je=H[j];return xe<0&&(xe+=Je),xe=Te>0?ue.uZ(0,xe,Je):ue.uZ(-1,xe,Je-1),xe}function Us(B,d,D){let H=D.length;for(let j=0;j<D.length;j++)if(D[j]>1){H=j;break}for(let j=H+1;j<D.length;j++)if(d[j]>0||D[j]!==B[j])return false;return true}function Un(B,d){let D=B.length>0?B[B.length-1]:1;for(let H=0;H<B.length-1;H++)D+=B[H]*d[H];return D}function vs(B,d,D){let H;const j=B.shape.length;let de;return H="number"==typeof d?[d,...new Array(j-1).fill(0)]:d.length<j?d.concat(new Array(j-d.length).fill(0)):d.slice(),H.forEach(xe=>{ue.hu(-1!==xe,()=>"slice() does not support negative begin indexing.")}),de=null==D?new Array(j).fill(-1):"number"==typeof D?[D,...new Array(j-1).fill(-1)]:D.length<j?D.concat(new Array(j-D.length).fill(-1)):D,de=de.map((xe,Te)=>xe>=0?xe:(ue.hu(-1===xe,()=>`Negative size values should be exactly -1 but got ${xe} for the slice() size at index ${Te}.`),B.shape[Te]-H[Te])),[H,de]}function Br(B,d,D,H,j,de,xe,Te,Je){let it=d.slice(),ut=D.slice(),Ue=H;null==H&&(Ue=new Array(it.length));const ee=Kn(xe);if(ee.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==xe&&0!==Te)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==xe&&0!==Je)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const l=B.length-it.length,M=Kn(Te),X=B.slice();M.forEach(E=>{it[E]=0,ut[E]=1,X.splice(E,0,1)});const{begin:we,end:me,strides:He}=bs(X,ee,l,it,ut,Ue,j,de,xe);it=we,ut=me,Ue=He;const Re=Kn(Je);Re.forEach(E=>{ut[E]=it[E]+1,Ue[E]=1});const pt=es(it,ut,Ue),_=pt.filter((E,$)=>-1===Re.indexOf($));return{nonStrided:Ue.every(E=>1===E),$begin:it,$end:ut,$strides:Ue,size:pt,newShape:X,outShape:_}}class nr{getClassName(){return this.constructor.className}static fromConfig(d,D){return new d(D)}}class cr{constructor(){this.classNameMap={}}static getMap(){return null==cr.instance&&(cr.instance=new cr),cr.instance}static register(d){cr.getMap().classNameMap[d.className]=[d,d.fromConfig]}}function Fn(B){(0,ue.hu)(null!=B.className,()=>"Class being registered does not have the static className property defined."),(0,ue.hu)("string"==typeof B.className,()=>"className is required to be a string, but got type "+typeof B.className),(0,ue.hu)(B.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),cr.register(B)}var ua=e(747),Tr=e(9122);const cn=.1;function rs(B,d,D){return null==D&&(D=ss()),Lr(B,d,(H,j)=>Ns(H,j,D))}function ss(){return 32===W.BV.backend.floatPrecision()?.001:cn}function Lr(B,d,D){let H=true;if(((0,ue.fU)(B)||(0,ue.fU)(d))&&(H=false),(0,ue.fU)(B)&&(0,ue.fU)(d)&&(H=true),H){const xe=B.constructor.name,Te=d.constructor.name;if(xe!==Te)throw new Error(`Arrays are of different type. Actual: ${xe}. Expected: ${Te}`)}if(Array.isArray(B)&&Array.isArray(d)){const xe=(0,Sr.C)(B),Te=(0,Sr.C)(d);if(!(0,ue.cO)(xe,Te))throw new Error(`Arrays have different shapes. Actual: [${xe}]. Expected: [${Te}]`)}const j=(0,ue.fU)(B)?B:(0,ue.xH)(B),de=(0,ue.fU)(d)?d:(0,ue.xH)(d);if(j.length!==de.length)throw new Error(`Arrays have different lengths actual: ${j.length} vs expected: ${de.length}.
Actual:   ${j}.
Expected: ${de}.`);for(let xe=0;xe<de.length;++xe){const Te=j[xe],Je=de[xe];if(!D(Te,Je))throw new Error(`Arrays differ: actual[${xe}] = ${Te}, expected[${xe}] = ${Je}.
Actual:   ${j}.
Expected: ${de}.`)}}function la(B,d){B().then(()=>d.fail(),()=>d())}function ca(B,d){const D="string"==typeof d||"number"==typeof d||"boolean"==typeof d?[d]:d;return(0,ue.HD)(B)||(0,ue.HD)(B[0])||(0,ue.HD)(d)||(0,ue.HD)(d[0])?Lr(B,D,(H,j)=>H==j):Lr(B,d,(H,j)=>Ns(H,j,0))}function da(B,d,D){if(null==D&&(D=ss()),!Ns(B,d,D))throw new Error(`Numbers differ: actual === ${B}, expected === ${d}`)}function Ns(B,d,D){return!isFinite(B)&&!isFinite(d)||!(isNaN(B)||isNaN(d)||Math.abs(B-d)>D)}function qs(B,d,D){for(let H=0;H<B.length;H++)if(B[H]<d||B[H]>D)throw new Error(`Value out of range:${B[H]} low: ${d}, high: ${D}`)}function ha(B,d){expect(new Float32Array(B)).toEqual(new Float32Array(d))}function Hs(B){for(let d=0;d<B.length;d++){const D=B[d];Array.isArray(D)?Hs(D):B[d]=(0,Tr.encodeString)(D)}return B}const xs="3.9.0";var Bt=e(4368),on=e(6407),Yn=e(1274),Zt=e(4841),Ir=e(3261),Xn=e(248),er=e(6577),br=e(633),kr=e(9494);class dr extends nr{minimize(d,D=false,H){const{value:j,grads:de}=this.computeGradients(d,H);if(null!=H){const xe=H.map(Te=>({name:Te.name,tensor:de[Te.name]}));this.applyGradients(xe)}else this.applyGradients(de);return(0,Bt.B9)(de),D?j:(j.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(d,D){return(0,br.pn)(d,D)}dispose(){null!=this.iterations_&&(0,Bt.B9)(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:(0,kr.i)(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(d){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(d){return this.iterations_=(await d[0].tensor.data())[0],d.slice(1)}}Object.defineProperty(dr,Symbol.hasInstance,{value:B=>null!=B.minimize&&null!=B.computeGradients&&null!=B.applyGradients});class Pr extends dr{constructor(d,D,H=null){super(),this.learningRate=d,this.rho=D,this.epsilon=H,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==H&&(this.epsilon=W.BV.backend.epsilon())}applyGradients(d){(Array.isArray(d)?d.map(D=>D.name):Object.keys(d)).forEach((D,H)=>{const j=W.BV.registeredVariables[D];null==this.accumulatedGrads[H]&&(this.accumulatedGrads[H]={originalName:`${D}/accum_grad`,variable:(0,Bt.lu)(()=>(0,er.P)(j).variable(false))}),null==this.accumulatedUpdates[H]&&(this.accumulatedUpdates[H]={originalName:`${D}/accum_var`,variable:(0,Bt.lu)(()=>(0,er.P)(j).variable(false))});const de=Array.isArray(d)?d[H].tensor:d[D];if(null==de)return;const xe=this.accumulatedGrads[H].variable,Te=this.accumulatedUpdates[H].variable;(0,Bt.lu)(()=>{const Je=(0,on.I)((0,Zt.d)(xe,this.rho),(0,Zt.d)((0,Xn.h)(de),1-this.rho)),it=(0,Zt.d)((0,Yn.h)((0,Ir._)((0,on.I)(Te,this.epsilon)),(0,Ir._)((0,on.I)(xe,this.epsilon))),de),ut=(0,on.I)((0,Zt.d)(Te,this.rho),(0,Zt.d)((0,Xn.h)(it),1-this.rho));xe.assign(Je),Te.assign(ut);const Ue=(0,on.I)((0,Zt.d)(it,-this.learningRate),j);j.assign(Ue)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&((0,Bt.B9)(this.accumulatedGrads.map(d=>d.variable)),(0,Bt.B9)(this.accumulatedUpdates.map(d=>d.variable)))}async getWeights(){const d=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(d.map(D=>({name:D.originalName,tensor:D.variable})))}async setWeights(d){const D=(d=await this.extractIterations(d)).length/2;this.accumulatedGrads=d.slice(0,D).map(H=>({originalName:H.name,variable:H.tensor.variable(false)})),this.accumulatedUpdates=d.slice(D,2*D).map(H=>({originalName:H.name,variable:H.tensor.variable(false)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(d,D){return new d(D.learningRate,D.rho,D.epsilon)}}Pr.className="Adadelta",Fn(Pr);var Ln=e(4006);class un extends dr{constructor(d,D=.1){super(),this.learningRate=d,this.initialAccumulatorValue=D,this.accumulatedGrads=[]}applyGradients(d){(Array.isArray(d)?d.map(D=>D.name):Object.keys(d)).forEach((D,H)=>{const j=W.BV.registeredVariables[D];if(null==this.accumulatedGrads[H]){const Te=false;this.accumulatedGrads[H]={originalName:`${D}/accumulator`,variable:(0,Bt.lu)(()=>(0,Ln.h)(j.shape,this.initialAccumulatorValue).variable(Te))}}const de=Array.isArray(d)?d[H].tensor:d[D];if(null==de)return;const xe=this.accumulatedGrads[H].variable;(0,Bt.lu)(()=>{const Te=(0,on.I)(xe,(0,Xn.h)(de));xe.assign(Te);const Je=(0,on.I)((0,Zt.d)((0,Yn.h)(de,(0,Ir._)((0,on.I)(Te,W.BV.backend.epsilon()))),-this.learningRate),j);j.assign(Je)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&(0,Bt.B9)(this.accumulatedGrads.map(d=>d.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(d=>({name:d.originalName,tensor:d.variable})))}async setWeights(d){d=await this.extractIterations(d);this.accumulatedGrads=d.map(D=>({originalName:D.name,variable:D.tensor.variable(false)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(d,D){return new d(D.learningRate,D.initialAccumulatorValue)}}un.className="Adagrad",Fn(un);var as=e(3453),wr=e(827);class vr extends dr{constructor(d,D,H,j=null){super(),this.learningRate=d,this.beta1=D,this.beta2=H,this.epsilon=j,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],(0,Bt.lu)(()=>{this.accBeta1=(0,kr.i)(D).variable(),this.accBeta2=(0,kr.i)(H).variable()}),null==j&&(this.epsilon=W.BV.backend.epsilon())}applyGradients(d){const D=Array.isArray(d)?d.map(H=>H.name):Object.keys(d);(0,Bt.lu)(()=>{const H=(0,wr.l)(1,this.accBeta1),j=(0,wr.l)(1,this.accBeta2);D.forEach((de,xe)=>{const Te=W.BV.registeredVariables[de];null==this.accumulatedFirstMoment[xe]&&(this.accumulatedFirstMoment[xe]={originalName:`${de}/m`,variable:(0,Bt.lu)(()=>(0,er.P)(Te).variable(false))}),null==this.accumulatedSecondMoment[xe]&&(this.accumulatedSecondMoment[xe]={originalName:`${de}/v`,variable:(0,Bt.lu)(()=>(0,er.P)(Te).variable(false))});const Je=Array.isArray(d)?d[xe].tensor:d[de];if(null==Je)return;const it=this.accumulatedFirstMoment[xe].variable,ut=this.accumulatedSecondMoment[xe].variable,Ue=(0,on.I)((0,Zt.d)(it,this.beta1),(0,Zt.d)(Je,1-this.beta1)),ee=(0,on.I)((0,Zt.d)(ut,this.beta2),(0,Zt.d)((0,Xn.h)(Je),1-this.beta2)),l=(0,Yn.h)(Ue,H),M=(0,Yn.h)(ee,j);it.assign(Ue),ut.assign(ee);const X=(0,on.I)((0,Zt.d)((0,Yn.h)(l,(0,on.I)((0,Ir._)(M),this.epsilon)),-this.learningRate),Te);Te.assign(X)}),this.accBeta1.assign((0,Zt.d)(this.accBeta1,this.beta1)),this.accBeta2.assign((0,Zt.d)(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&(0,Bt.B9)(this.accumulatedFirstMoment.map(d=>d.variable)),null!=this.accumulatedSecondMoment&&(0,Bt.B9)(this.accumulatedSecondMoment.map(d=>d.variable))}async getWeights(){const d=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(d.map(D=>({name:D.originalName,tensor:D.variable})))}async setWeights(d){d=await this.extractIterations(d),(0,Bt.lu)(()=>{this.accBeta1.assign((0,as.s)(this.beta1,this.iterations_+1)),this.accBeta2.assign((0,as.s)(this.beta2,this.iterations_+1))});const D=d.length/2;this.accumulatedFirstMoment=d.slice(0,D).map(H=>({originalName:H.name,variable:H.tensor.variable(false)})),this.accumulatedSecondMoment=d.slice(D,2*D).map(H=>({originalName:H.name,variable:H.tensor.variable(false)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(d,D){return new d(D.learningRate,D.beta1,D.beta2,D.epsilon)}}vr.className="Adam",Fn(vr);var pa=e(6235),js=e(632);class Rr extends dr{constructor(d,D,H,j=null,de=0){super(),this.learningRate=d,this.beta1=D,this.beta2=H,this.epsilon=j,this.decay=de,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],(0,Bt.lu)(()=>{this.iteration=(0,kr.i)(0).variable(),this.accBeta1=(0,kr.i)(D).variable()}),null==j&&(this.epsilon=W.BV.backend.epsilon())}applyGradients(d){const D=Array.isArray(d)?d.map(H=>H.name):Object.keys(d);(0,Bt.lu)(()=>{const H=(0,wr.l)(1,this.accBeta1),j=(0,Yn.h)(-this.learningRate,(0,on.I)((0,Zt.d)(this.iteration,this.decay),1));D.forEach((de,xe)=>{const Te=W.BV.registeredVariables[de];null==this.accumulatedFirstMoment[xe]&&(this.accumulatedFirstMoment[xe]={originalName:`${de}/m`,variable:(0,er.P)(Te).variable(false)}),null==this.accumulatedWeightedInfNorm[xe]&&(this.accumulatedWeightedInfNorm[xe]={originalName:`${de}/v`,variable:(0,er.P)(Te).variable(false)});const Je=Array.isArray(d)?d[xe].tensor:d[de];if(null==Je)return;const it=this.accumulatedFirstMoment[xe].variable,ut=this.accumulatedWeightedInfNorm[xe].variable,Ue=(0,on.I)((0,Zt.d)(it,this.beta1),(0,Zt.d)(Je,1-this.beta1)),ee=(0,Zt.d)(ut,this.beta2),l=(0,pa.W)(Je),M=(0,js.g)(ee,l);it.assign(Ue),ut.assign(M);const X=(0,on.I)((0,Zt.d)((0,Yn.h)(j,H),(0,Yn.h)(Ue,(0,on.I)(M,this.epsilon))),Te);Te.assign(X)}),this.iteration.assign((0,on.I)(this.iteration,1)),this.accBeta1.assign((0,Zt.d)(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&(0,Bt.B9)(this.accumulatedFirstMoment.map(d=>d.variable)),null!=this.accumulatedWeightedInfNorm&&(0,Bt.B9)(this.accumulatedWeightedInfNorm.map(d=>d.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(d){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(d,D){return new d(D.learningRate,D.beta1,D.beta2,D.epsilon,D.decay)}}Rr.className="Adamax",Fn(Rr);class hr extends dr{constructor(d){super(),this.learningRate=d,this.setLearningRate(d)}applyGradients(d){(Array.isArray(d)?d.map(D=>D.name):Object.keys(d)).forEach((D,H)=>{const j=Array.isArray(d)?d[H].tensor:d[D];if(null==j)return;const de=W.BV.registeredVariables[D];(0,Bt.lu)(()=>{const xe=(0,on.I)((0,Zt.d)(this.c,j),de);de.assign(xe)})}),this.incrementIterations()}setLearningRate(d){this.learningRate=d,null!=this.c&&this.c.dispose(),this.c=(0,Bt.Cn)((0,kr.i)(-d))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(d){if(0!==(d=await this.extractIterations(d)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(d,D){return new d(D.learningRate)}}hr.className="SGD",Fn(hr);class os extends hr{constructor(d,D,H=false){super(d),this.learningRate=d,this.momentum=D,this.useNesterov=H,this.accumulations=[],this.m=(0,kr.i)(this.momentum)}applyGradients(d){(Array.isArray(d)?d.map(D=>D.name):Object.keys(d)).forEach((D,H)=>{const j=W.BV.registeredVariables[D];if(null==this.accumulations[H]){const Te=false;this.accumulations[H]={originalName:`${D}/momentum`,variable:(0,Bt.lu)(()=>(0,er.P)(j).variable(Te))}}const de=this.accumulations[H].variable,xe=Array.isArray(d)?d[H].tensor:d[D];null!=xe&&(0,Bt.lu)(()=>{let Te;const Je=(0,on.I)((0,Zt.d)(this.m,de),xe);Te=this.useNesterov?(0,on.I)((0,Zt.d)(this.c,(0,on.I)(xe,(0,Zt.d)(Je,this.m))),j):(0,on.I)((0,Zt.d)(this.c,Je),j),de.assign(Je),j.assign(Te)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&(0,Bt.B9)(this.accumulations.map(d=>d.variable))}setMomentum(d){this.momentum=d}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(d=>({name:d.originalName,tensor:d.variable})))}async setWeights(d){d=await this.extractIterations(d);this.accumulations=d.map(D=>({originalName:D.name,variable:D.tensor.variable(false)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(d,D){return new d(D.learningRate,D.momentum,D.useNesterov)}}os.className="Momentum",Fn(os);class is extends dr{constructor(d,D=.9,H=0,j=null,de=false){if(super(),this.learningRate=d,this.decay=D,this.momentum=H,this.epsilon=j,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=de,null==j&&(this.epsilon=W.BV.backend.epsilon()),null==d)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(d){(Array.isArray(d)?d.map(D=>D.name):Object.keys(d)).forEach((D,H)=>{const j=W.BV.registeredVariables[D],de=false;null==this.accumulatedMeanSquares[H]&&(this.accumulatedMeanSquares[H]={originalName:`${D}/rms`,variable:(0,Bt.lu)(()=>(0,er.P)(j).variable(de))}),null==this.accumulatedMoments[H]&&(this.accumulatedMoments[H]={originalName:`${D}/momentum`,variable:(0,Bt.lu)(()=>(0,er.P)(j).variable(de))}),null==this.accumulatedMeanGrads[H]&&this.centered&&(this.accumulatedMeanGrads[H]={originalName:`${D}/mg`,variable:(0,Bt.lu)(()=>(0,er.P)(j).variable(de))});const xe=Array.isArray(d)?d[H].tensor:d[D];if(null==xe)return;const Te=this.accumulatedMeanSquares[H].variable,Je=this.accumulatedMoments[H].variable;(0,Bt.lu)(()=>{const it=(0,on.I)((0,Zt.d)(Te,this.decay),(0,Zt.d)((0,Xn.h)(xe),1-this.decay));if(this.centered){const ut=this.accumulatedMeanGrads[H].variable,Ue=(0,on.I)((0,Zt.d)(ut,this.decay),(0,Zt.d)(xe,1-this.decay)),ee=(0,Yn.h)((0,Zt.d)(xe,this.learningRate),(0,Ir._)((0,wr.l)(it,(0,on.I)((0,Xn.h)(Ue),this.epsilon)))),l=(0,on.I)((0,Zt.d)(Je,this.momentum),ee);Te.assign(it),ut.assign(Ue),Je.assign(l);const M=(0,wr.l)(j,l);j.assign(M)}else{const ut=(0,on.I)((0,Zt.d)(Te,this.decay),(0,Zt.d)((0,Xn.h)(xe),1-this.decay)),Ue=(0,on.I)((0,Zt.d)(Je,this.momentum),(0,Yn.h)((0,Zt.d)(xe,this.learningRate),(0,Ir._)((0,on.I)(ut,this.epsilon))));Te.assign(ut),Je.assign(Ue);const ee=(0,wr.l)(j,Ue);j.assign(ee)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&(0,Bt.B9)(this.accumulatedMeanSquares.map(d=>d.variable)),null!=this.accumulatedMeanGrads&&this.centered&&(0,Bt.B9)(this.accumulatedMeanGrads.map(d=>d.variable)),null!=this.accumulatedMoments&&(0,Bt.B9)(this.accumulatedMoments.map(d=>d.variable))}async getWeights(){const d=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&d.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(d.map(D=>({name:D.originalName,tensor:D.variable})))}async setWeights(d){d=await this.extractIterations(d);const D=this.centered?d.length/3:d.length/2,H=false;this.accumulatedMeanSquares=d.slice(0,D).map(j=>({originalName:j.name,variable:j.tensor.variable(H)})),this.accumulatedMoments=d.slice(D,2*D).map(j=>({originalName:j.name,variable:j.tensor.variable(H)})),this.centered&&(this.accumulatedMeanGrads=d.slice(2*D,3*D).map(j=>({originalName:j.name,variable:j.tensor.variable(H)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(d,D){return new d(D.learningRate,D.decay,D.momentum,D.epsilon,D.centered)}}is.className="RMSProp",Fn(is);var us=e(1221),Ie=e(4885),Gs=e(9876);class Er{static sgd(d){return new hr(d)}static momentum(d,D,H=false){return new os(d,D,H)}static rmsprop(d,D=.9,H=0,j=null,de=false){return new is(d,D,H,j,de)}static adam(d=.001,D=.9,H=.999,j=null){return new vr(d,D,H,j)}static adadelta(d=.001,D=.95,H=null){return new Pr(d,D,H)}static adamax(d=.002,D=.9,H=.999,j=null,de=0){return new Rr(d,D,H,j,de)}static adagrad(d,D=.1){return new un(d,D)}}const Ca={sgd:Er.sgd,momentum:Er.momentum,adadelta:Er.adadelta,adagrad:Er.adagrad,rmsprop:Er.rmsprop,adamax:Er.adamax,adam:Er.adam},Ar="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:B=>B();function fa(){return new Promise(B=>Ar(()=>B()))}var Pn=e(3591),Ks=e(2200);function Xs(B,d){const D=B[0].length;B.forEach((j,de)=>{ue.hu(j.length===D,()=>`Error in concat${D}D: rank of tensors[${de}] must be the same as the rank of the rest (${D})`)}),ue.hu(d>=0&&d<D,()=>`Error in concat${D}D: axis must be between 0 and ${D-1}.`);const H=B[0];B.forEach((j,de)=>{for(let xe=0;xe<D;xe++)ue.hu(xe===d||j[xe]===H[xe],()=>`Error in concat${D}D: Shape of tensors[${de}] (${j}) does not match the shape of the rest (${H}) along the non-concatenated axis ${de}.`)})}function _s(B,d){const D=B[0].slice();for(let H=1;H<B.length;H++)D[d]+=B[H][d];return D}var Nr=e(2582),Zs=e(9323);const ma=30;function ga(B){return B<=ma?B:(0,ue.jP)(B,Math.floor(Math.sqrt(B)))}function rr(B,d,D){return[D*("number"==typeof B?B:B[0]),d*("number"==typeof B?B:B[1])]}function Ss(B,d,D,H=true){let j=[];if(H)j=j.concat(d.slice(0)),j.push(B[0]/D),j=j.concat(B.slice(1));else{j=j.concat(B[0]);const de=d.length;for(let xe=0;xe<de;++xe)j=j.concat([B[xe+1]/d[xe],d[xe]]);j=j.concat(B.slice(de+1))}return j}function Ts(B,d,D=true){const H=[];if(D){H.push(d);for(let j=d+1;j<B;++j)j<=2*d?(H.push(j),H.push(j-(d+1))):H.push(j)}else{const j=[],de=[];for(let xe=1;xe<B;++xe)xe>=2*d+1||xe%2==1?de.push(xe):j.push(xe);H.push(...j),H.push(0),H.push(...de)}return H}function Wa(B,d,D,H=true){const j=[];H?j.push(B[0]/D):j.push(B[0]*D);for(let de=1;de<B.length;++de)de<=d.length?H?j.push(d[de-1]*B[de]):j.push(B[de]/d[de-1]):j.push(B[de]);return j}function Ua(B,d){const D=[0];for(let H=0;H<d;++H)D.push(B[H][0]);return D}function qa(B,d,D){const H=B.slice(0,1);for(let j=0;j<D;++j)H.push(B[j+1]-d[j][0]-d[j][1]);return H}const Ha=1.7580993408473768,ja=1.0507009873554805,Ga=.3275911,$a=.254829592,Ka=-.284496736,ya=1.421413741,Xa=-1.453152027,Is=1.061405429;var Qs=e(4706);function ba(B,d){if(B.length!==d.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${B.length}, imag: ${d.length}.`);const D=new Float32Array(2*B.length);for(let H=0;H<D.length;H+=2)D[H]=B[H/2],D[H+1]=d[H/2];return D}function Za(B){const d=new Float32Array(B.length/2),D=new Float32Array(B.length/2);for(let H=0;H<B.length;H+=2)d[H/2]=B[H],D[H/2]=B[H+1];return{real:d,imag:D}}function Es(B){const d=Math.ceil(B.length/4),D=new Float32Array(d),H=new Float32Array(d);for(let j=0;j<B.length;j+=4)D[Math.floor(j/4)]=B[j],H[Math.floor(j/4)]=B[j+1];return{real:D,imag:H}}function As(B){const d=Math.floor(B.length/4),D=new Float32Array(d),H=new Float32Array(d);for(let j=2;j<B.length;j+=4)D[Math.floor(j/4)]=B[j],H[Math.floor(j/4)]=B[j+1];return{real:D,imag:H}}function ka(B,d){return{real:B[2*d],imag:B[2*d+1]}}function wa(B,d,D,H){B[2*H]=d,B[2*H+1]=D}function Qa(B,d){const D=new Float32Array(B/2),H=new Float32Array(B/2);for(let j=0;j<Math.ceil(B/2);j++){const de=(d?2:-2)*Math.PI*(j/B);D[j]=Math.cos(de),H[j]=Math.sin(de)}return{real:D,imag:H}}function Ja(B,d,D){const H=(D?2:-2)*Math.PI*(B/d);return{real:Math.cos(H),imag:Math.sin(H)}}const Da="->",Ya=/->/g;function eo(B,d){const D=((B=B.replace(/\s/g,"")).length-B.replace(Ya,"").length)/Da.length;if(D<1)throw new Error("Equations without an arrow are not supported.");if(D>1)throw new Error('Equation must contain exactly one arrow ("->").');const[H,j]=B.split(Da);(0,ue.hu)(-1===H.indexOf("..."),()=>'The ellipsis notation ("...") is not supported yet.');const de=H.split(","),xe=de.length;if(d!==xe)throw new Error(`Expected ${xe} input tensors, received ${d}`);if(xe>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const Te=[];for(let Ue=0;Ue<j.length;++Ue){const ee=j[Ue];if(!de.some(l=>-1!==l.indexOf(ee)))throw new Error(`Output subscripts contain the label ${ee} not present in the input subscripts.`);-1===Te.indexOf(ee)&&Te.push(ee)}for(let Ue=0;Ue<H.length;++Ue){const ee=H[Ue];-1===Te.indexOf(ee)&&","!==ee&&Te.push(ee)}const Je=new Array(de.length);for(let Ue=0;Ue<xe;++Ue){if(new Set(de[Ue].split("")).size!==de[Ue].length)throw new Error(`Found duplicate axes in input component ${de[Ue]}. Support for duplicate axes in input is not implemented yet.`);Je[Ue]=[];for(let ee=0;ee<de[Ue].length;++ee)Je[Ue].push(Te.indexOf(de[Ue][ee]))}const it=Te.length,ut=[];for(let Ue=j.length;Ue<it;++Ue)ut.push(Ue);return{allDims:Te,summedDims:ut,idDims:Je}}function to(B,d){let D=new Array(B);D.fill(-1);for(let j=0;j<d.length;++j)D[d[j]]=j;const H=[];for(let j=0;j<B;++j)-1===D[j]&&H.push(j);return D=D.filter(j=>-1!==j),{permutationIndices:D,expandDims:H}}function Fa(B,d,D){const H=new Array(B);for(let j=0;j<D.length;++j){const de=D[j].shape;for(let xe=0;xe<d[j].length;++xe)void 0===H[d[j][xe]]?H[d[j][xe]]=de[xe]:(0,ue.hu)(H[d[j][xe]]===de[xe],()=>`Expected dimension ${H[d[j][xe]]} at axis ${xe} of input shaped ${JSON.stringify(de)}, but got dimension ${de[xe]}`)}}function va(B,d){const D=B,H=[];let j=0;0===B.length&&D.push(-1),j=B.length+1;for(let xe=0;xe<j;++xe)H.push([]);const de=[];for(let xe=0;xe<D.length;++xe){const Te=no(d,D[xe]);for(const Je of Te)-1===de.indexOf(Je)&&(H[xe].push(Je),de.push(Je))}return{path:D,steps:H}}function Js(B){return B.every((d,D)=>d===D)}function no(B,d){const D=[];for(let H=0;H<B.length;++H)0!==B[H].length&&-1===B[H].indexOf(d)&&-1!==d||D.push(H);return D}function ro(B,d,D=0){let H=[];if("number"==typeof d)(0,ue.hu)(B.shape[D]%d==0,()=>"Number of splits must evenly divide the axis."),H=new Array(d).fill(B.shape[D]/d);else{const j=d.reduce((xe,Te)=>(-1===Te&&(xe+=1),xe),0);(0,ue.hu)(j<=1,()=>"There should be only one negative value in split array.");const de=d.indexOf(-1);if(-1!==de){const xe=d.reduce((Te,Je)=>Je>0?Te+Je:Te);d[de]=B.shape[D]-xe}(0,ue.hu)(B.shape[D]===d.reduce((xe,Te)=>xe+Te),()=>"The sum of sizes must match the size of the axis dimension."),H=d}return H}function Ys(B,d){let D,H=false;for(B<=ma?(D=B,H=true):D=(0,ue.jP)(B,Math.floor(Math.sqrt(B)));!H;)D>d||D===B?H=true:D=(0,ue.jP)(B,D+1);return D}function ea(B,d,D){const H=[],j=B.length;for(let de=0;de<j;de++)de!==d?H.push(B[de]):H.push(D);return H}function Oa(B,d,D,H){const j=d.shape.length,de=B.shape.length;if(0!==H&&(H<-j||H>j))throw new Error(`Expect batchDims in the range of [-${j}, ${j}], but got ${H}`);if(H<0&&(H+=j),H>de)throw new Error(`batchDims (${H}) must be less than rank(x) (
    ${de}).`);if(D<H)throw new Error(`batchDims (${H}) must be less than or equal to axis (${D}).`);for(let Ue=0;Ue<H;++Ue)if(B.shape[Ue]!==d.shape[Ue])throw new Error(`x.shape[${Ue}]: ${B.shape[Ue]} should be equal to indices.shape[${Ue}]: ${d.shape[Ue]}.`);const xe=B.shape[D],Te=[];let Je=1,it=1,ut=1;for(let Ue=0;Ue<H;++Ue)Te.push(B.shape[Ue]),Je*=B.shape[Ue];for(let Ue=H;Ue<D;Ue++)Te.push(B.shape[Ue]),it*=B.shape[Ue];for(let Ue=H;Ue<j;Ue++)Te.push(d.shape[Ue]);for(let Ue=D+1;Ue<de;Ue++)Te.push(B.shape[Ue]),ut*=B.shape[Ue];return{batchSize:Je,sliceSize:ut,outerSize:it,dimSize:xe,outputShape:Te}}function so(B){try{return B.map(d=>(0,Tr.decodeString)(d))}catch(d){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${d}`)}}function Na(B){return B.map(d=>(0,Tr.encodeString)(d))}var xa=e(3337),ta=e(8333),Mr=e(8713)},9121:(b,u,e)=>{e.d(u,{SY:()=>g,VG:()=>n,Sp:()=>h,mm:()=>i,Xz:()=>w,oT:()=>k,IK:()=>I,sJ:()=>T,aJ:()=>c,M2:()=>p,qw:()=>y,jM:()=>W,Oy:()=>L,QC:()=>R,Jh:()=>K,RO:()=>re,_k:()=>J,IM:()=>ve,XL:()=>ue,zw:()=>ie,zv:()=>F,Ly:()=>P,eE:()=>f,RF:()=>Q,gJ:()=>oe,xn:()=>se,Zz:()=>o,yj:()=>te,Eh:()=>De,mh:()=>Ve,wU:()=>ze,wm:()=>Ke,x1:()=>Ye,o2:()=>rt,ik:()=>Qe,mc:()=>tt,TR:()=>Nt,iH:()=>$t,Vc:()=>Ct,QR:()=>Ot,T0:()=>zt,ci:()=>Ht,sL:()=>tn,y7:()=>qt,$w:()=>Ut,p4:()=>Wt,ek:()=>Be,Vn:()=>Fe,oH:()=>Y,$g:()=>be,SX:()=>ke,HE:()=>We,Om:()=>yt,hd:()=>_t,NE:()=>dt,YF:()=>Ft,Y0:()=>Yt,vw:()=>fn,de:()=>an,Uy:()=>gn,OR:()=>Rt,je:()=>Xt,sH:()=>jt,qi:()=>Nn,q1:()=>yn,iZ:()=>An,Ac:()=>vn,iJ:()=>Tn,Qg:()=>wn,J_:()=>Mn,av:()=>fr,iW:()=>Jn,r7:()=>Hr,J$:()=>ir,vt:()=>Ds,CA:()=>hs,e7:()=>ur,Zb:()=>jr,kU:()=>Gr,PY:()=>$n,Vf:()=>Fs,MZ:()=>Os,qC:()=>Bs,eZ:()=>Kr,Hh:()=>Xr,Yo:()=>Zr,BM:()=>ps,mT:()=>oa,OV:()=>mr,OA:()=>Ls,OU:()=>fs,vF:()=>Dn,q2:()=>Sr,c1:()=>Ps,q8:()=>ms,jQ:()=>gr,Vb:()=>Dr,NZ:()=>sn,wY:()=>Ce,ku:()=>Gn,yQ:()=>Qr,uv:()=>yr,cy:()=>Jr,W0:()=>ia,qW:()=>Rs,we:()=>Vs,Qi:()=>zs,ly:()=>gs,Kg:()=>Fr,pe:()=>Yr,o0:()=>Kn,Dl:()=>es,e6:()=>ys,xJ:()=>lr,$H:()=>ts,qk:()=>bs,HZ:()=>ks,dp:()=>Or,Hm:()=>ns,_Y:()=>Ws,zb:()=>ws,Sb:()=>Us,mK:()=>Un,e0:()=>vs,bV:()=>Br,xQ:()=>nr,Ph:()=>cr,oF:()=>Fn,p2:()=>ua,RQ:()=>Tr,w3:()=>cn,i5:()=>rs,a5:()=>ss,MR:()=>Lr,FK:()=>la,GB:()=>ca,TQ:()=>da,L8:()=>Ns,Gc:()=>qs,O3:()=>ha,nh:()=>Hs,YW:()=>xs,Zj:()=>Bt,D2:()=>on,_t:()=>Yn,bK:()=>Zt,m2:()=>Ir,_J:()=>Xn,s1:()=>er,Xk:()=>br,Tr:()=>kr,sE:()=>dr,MI:()=>Pr,n9:()=>Ln,cW:()=>un,wx:()=>as,G3:()=>wr,kp:()=>vr,To:()=>pa,Qv:()=>js,Ru:()=>Rr,h8:()=>hr,eB:()=>os,b9:()=>is,us:()=>us,_V:()=>Ie,lu:()=>Gs});const g="Abs",n="Acos",h="Acosh",i="Add",w="AddN",k="All",I="Any",T="ArgMax",c="ArgMin",p="Asin",y="Asinh",W="Atan",L="Atanh",R="Atan2",K="AvgPool",re="AvgPoolGrad",J="AvgPool3D",ve="AvgPool3DGrad",ue="BatchMatMul",ie="BatchToSpaceND",F="Bincount",P="BroadcastTo",f="BroadcastArgs",Q="Cast",oe="Ceil",se="ClipByValue",o="Complex",te="ComplexAbs",De="Concat",Ve="Conv2D",ze="Conv2DBackpropFilter",Ke="Conv2DBackpropInput",Ye="Conv3D",rt="Conv3DBackpropFilterV2",Qe="Conv3DBackpropInputV2",tt="Cos",Nt="Cosh",$t="Cumsum",Ct="CropAndResize",Ot="DenseBincount",zt="DepthToSpace",Ht="DepthwiseConv2dNative",tn="DepthwiseConv2dNativeBackpropFilter",qt="DepthwiseConv2dNativeBackpropInput",Ut="Diag",Wt="Dilation2D",Be="Dilation2DBackpropInput",Fe="Dilation2DBackpropFilter",Y="RealDiv",be="Einsum",ke="Elu",We="EluGrad",yt="Erf",_t="Equal",dt="Exp",Ft="ExpandDims",Yt="Expm1",fn="FFT",an="Fill",gn="FlipLeftRight",Rt="Floor",Xt="FloorDiv",jt="FusedBatchNorm",Nn="GatherV2",yn="GatherNd",An="Greater",vn="GreaterEqual",Tn="Identity",wn="IFFT",Mn="Imag",fr="IsFinite",Jn="IsInf",Hr="IsNan",ir="LeakyRelu",Ds="Less",hs="LessEqual",ur="LinSpace",jr="Log",Gr="Log1p",$n="LogicalAnd",Fs="LogicalNot",Os="LogicalOr",Bs="LogSoftmax",Kr="LRN",Xr="LRNGrad",Zr="Max",ps="Maximum",oa="MaxPool",mr="MaxPoolGrad",Ls="MaxPool3D",fs="MaxPool3DGrad",Dn="MaxPoolWithArgmax",Sr="Mean",Ps="Min",ms="Minimum",gr="MirrorPad",Dr="Mod",sn="Multinomial",Ce="Multiply",Gn="Neg",Qr="NotEqual",yr="NonMaxSuppressionV3",Jr="NonMaxSuppressionV4",ia="NonMaxSuppressionV5",Rs="OnesLike",Vs="OneHot",zs="Pack",gs="PadV2",Fr="Pool",Yr="Pow",Kn="Prelu",es="Prod",ys="Range",lr="Real",ts="Reciprocal",bs="Relu",ks="Reshape",Or="ResizeNearestNeighbor",ns="ResizeNearestNeighborGrad",Ws="ResizeBilinear",ws="ResizeBilinearGrad",Us="Relu6",Un="Reverse",vs="Round",Br="Rsqrt",nr="ScatterNd",cr="Select",Fn="Selu",ua="Slice",Tr="Sin",cn="Sinh",rs="Sign",ss="Sigmoid",Lr="Softplus",la="Sqrt",ca="Sum",da="SpaceToBatchND",Ns="SplitV",qs="Softmax",ha="SparseFillEmptyRows",Hs="SparseReshape",xs="SparseSegmentMean",Bt="SparseSegmentSum",on="SparseToDense",Yn="SquaredDifference",Zt="Square",Ir="StridedSlice",Xn="StringNGrams",er="StringSplit",br="StringToHashBucketFast",kr="Sub",dr="Tan",Pr="Tanh",Ln="Tile",un="TopK",as="Transform",wr="Transpose",vr="Unique",pa="Unpack",js="UnsortedSegmentSum",Rr="ZerosLike",hr="Step",os="FromPixels",is="RotateWithOffset",us="_FusedMatMul",Ie="FusedConv2D",Gs="FusedDepthwiseConv2D"},6151:(b,u,e)=>{e.d(u,{pI:()=>k,uk:()=>I,tr:()=>T,wC:()=>c,Li:()=>p,nE:()=>y,bt:()=>W,T3:()=>L});var g=e(2885),n=e(5938),h=e(4706);const i=(0,n.R)("kernelRegistry",()=>new Map),w=(0,n.R)("gradRegistry",()=>new Map);function k(K,re){const J=R(K,re);return i.get(J)}function I(K){return w.get(K)}function T(K){const re=i.entries(),J=[];for(;;){const{done:ve,value:ue}=re.next();if(ve)break;const[ie,F]=ue,[P]=ie.split("_");P===K&&J.push(F)}return J}function c(K){const{kernelName:re,backendName:J}=K,ve=R(re,J);i.has(ve)&&h.Z(`The kernel '${re}' for backend '${J}' is already registered`),i.set(ve,K)}function p(K){const{kernelName:re}=K;w.has(re)&&(0,g.OB)().getBool("DEBUG")&&h.Z(`Overriding the gradient for '${re}'`),w.set(re,K)}function y(K,re){const J=R(K,re);if(!i.has(J))throw new Error(`The kernel '${K}' for backend '${re}' is not registered`);i.delete(J)}function W(K){if(!w.has(K))throw new Error(`The gradient '${K}' for backend is not registered`);w.delete(K)}function L(K,re){T(K).forEach(J=>{c(Object.assign({},J,{backendName:re}))})}function R(K,re){return`${re}_${K}`}},4706:(b,u,e)=>{e.d(u,{Z:()=>n,c:()=>h});var g=e(2885);function n(...i){(0,g.OB)().getBool("IS_TEST")||(0,g.OB)().getBool("PROD")||console.warn(...i)}function h(...i){(0,g.OB)().getBool("IS_TEST")||(0,g.OB)().getBool("PROD")||console.log(...i)}},6235:(b,u,e)=>{e.d(u,{W:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({abs_:function(w){const k=(0,h._1)(w,"x","abs");if("complex64"===k.dtype){const I={x:k};return g.BV.runKernel(n.yj,I)}{const I={x:k};return g.BV.runKernel(n.SY,I)}}})},7839:(b,u,e)=>{e.d(u,{K:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({acos_:function(w){const k={x:(0,h._1)(w,"x","acos")};return g.BV.runKernel(n.VG,k)}})},1470:(b,u,e)=>{e.d(u,{_:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({acosh_:function(w){const k={x:(0,h._1)(w,"x","acosh")};return g.BV.runKernel(n.Sp,k)}})},6407:(b,u,e)=>{e.d(u,{I:()=>w});var g=e(7097),n=e(9121),h=e(747),i=e(3740);const w=(0,e(2668).op)({add_:function(k,I){let T=(0,i._1)(k,"a","add"),c=(0,i._1)(I,"b","add");[T,c]=(0,h.makeTypesMatch)(T,c);const p={a:T,b:c};return g.BV.runKernel(n.mm,p)}})},3135:(b,u,e)=>{e.d(u,{Q:()=>w});var g=e(7097),n=e(9121),h=e(3740),i=e(569);const w=(0,e(2668).op)({addN_:function(k){i.hu(Array.isArray(k),()=>"The argument passed to tf.addN() must be a list of tensors"),i.hu(k.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${k.length}`);const I=k.map((p,y)=>(0,h._1)(p,`tensors${y}`,"addN")),T=I[0];I.forEach(p=>{if(p.dtype!==T.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),I.forEach(p=>{if(!i.cO(p.shape,T.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const c=I;return g.BV.runKernel(n.Xz,c)}})},781:(b,u,e)=>{e.d(u,{$:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({all_:function(w,k=null,I=false){const T={x:(0,h._1)(w,"x","all","bool")},c={axis:k,keepDims:I};return g.BV.runKernel(n.oT,T,c)}})},2998:(b,u,e)=>{e.d(u,{Y:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({any_:function(w,k=null,I=false){const T={x:(0,h._1)(w,"x","any","bool")},c={axis:k,keepDims:I};return g.BV.runKernel(n.IK,T,c)}})},47:(b,u,e)=>{e.d(u,{N:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({argMax_:function(w,k=0){const I={x:(0,h._1)(w,"x","argMax")},T={axis:k};return g.BV.runKernel(n.sJ,I,T)}})},7394:(b,u,e)=>{e.d(u,{v:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({argMin_:function(w,k=0){const I={x:(0,h._1)(w,"x","argMin")},T={axis:k};return g.BV.runKernel(n.aJ,I,T)}})},2421:(b,u,e)=>{e.d(u,{Z:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({asin_:function(w){const k={x:(0,h._1)(w,"x","asin")};return g.BV.runKernel(n.M2,k)}})},1891:(b,u,e)=>{e.d(u,{V:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({asinh_:function(w){const k={x:(0,h._1)(w,"x","asinh")};return g.BV.runKernel(n.qw,k)}})},7037:(b,u,e)=>{e.d(u,{z:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({atan_:function(w){const k={x:(0,h._1)(w,"x","atan")};return g.BV.runKernel(n.jM,k)}})},9812:(b,u,e)=>{e.d(u,{f:()=>w});var g=e(7097),n=e(9121),h=e(747),i=e(3740);const w=(0,e(2668).op)({atan2_:function(k,I){let T=(0,i._1)(k,"a","atan2"),c=(0,i._1)(I,"b","atan2");[T,c]=(0,h.makeTypesMatch)(T,c);const p={a:T,b:c};return g.BV.runKernel(n.QC,p)}})},369:(b,u,e)=>{e.d(u,{C:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({atanh_:function(w){const k={x:(0,h._1)(w,"x","atanh")};return g.BV.runKernel(n.Oy,k)}})},5176:(b,u,e)=>{e.d(u,{w:()=>c});var g=e(7097),n=e(9121),h=e(3740),i=e(569),w=e(2271),k=e(2582),I=e(2668),T=e(4968);const c=(0,I.op)({avgPool_:function(p,y,W,L,R){const K=(0,h._1)(p,"x","avgPool","float32");i.hu(k.jT(W,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${W} and dilations '1'`);let re=K,J=false;3===K.rank&&(J=true,re=(0,T.X)(K,[1,K.shape[0],K.shape[1],K.shape[2]])),i.hu(4===re.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${re.rank}.`),null!=R&&i.hu(i.GN(L),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${R} but got pad ${L}.`);const ve={x:re},ue={filterSize:y,strides:W,pad:L,dimRoundingMode:R};let ie=g.BV.runKernel(n.Jh,ve,ue);return ie=(0,w.p)(ie,K.dtype),J?(0,T.X)(ie,[ie.shape[1],ie.shape[2],ie.shape[3]]):ie}})},1749:(b,u,e)=>{e.d(u,{u:()=>T});var g=e(7097),n=e(9121),h=e(3740),i=e(569),w=e(2271),k=e(2668),I=e(4968);const T=(0,k.op)({avgPool3d_:function(c,p,y,W,L,R="NDHWC"){const K=(0,h._1)(c,"x","avgPool3d","float32");let re=K,J=false;4===K.rank&&(J=true,re=(0,I.X)(K,[1,K.shape[0],K.shape[1],K.shape[2],K.shape[3]])),i.hu(5===re.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${re.rank}.`),i.hu("NDHWC"===R,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${R}`),null!=L&&i.hu(i.GN(W),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${L} but got pad ${W}.`);const ve={x:re},ue={filterSize:p,strides:y,pad:W,dimRoundingMode:L,dataFormat:R};let ie=g.BV.runKernel(n._k,ve,ue);return ie=(0,w.p)(ie,re.dtype),J?(0,I.X)(ie,[ie.shape[1],ie.shape[2],ie.shape[3],ie.shape[4]]):ie}})},3591:(b,u,e)=>{e.d(u,{YB:()=>n,Vh:()=>h,kz:()=>i,rv:()=>w,lB:()=>k,Q3:()=>I,LJ:()=>T,sY:()=>c});var g=e(569);function n(p,y){for(let W=0;W<p.length;++W)if(p[p.length-W-1]!==y-1-W)return false;return true}function h(p,y,W){const L=p.length+y.length,R=[];let K=0,re=0;for(let J=0;J<L;J++)-1===W.indexOf(J)?R.push(p[K++]):R.push(y[re++]);return R}function i(p,y){const W=[],L=p.length;for(let R=0;R<L;R++)-1===y.indexOf(R)&&W.push(p[R]);return[W,y.map(R=>p[R])]}function w(p,y){return h(p,y.map(W=>1),y)}function k(p,y,W){g.hu(n(y,W),()=>`${p} supports only inner-most axes for now. Got axes ${y} and rank-${W} input.`)}function I(p,y){if(n(p,y))return null;const W=[];for(let L=0;L<y;++L)-1===p.indexOf(L)&&W.push(L);return p.forEach(L=>W.push(L)),W}function T(p){return p.map((y,W)=>[W,y]).sort((y,W)=>y[1]-W[1]).map(y=>y[0])}function c(p,y){const W=[];for(let L=y-p;L<y;++L)W.push(L);return W}},8441:(b,u,e)=>{e.d(u,{E:()=>w});var g=e(7097),n=e(9121),h=e(3740),i=e(569);const w=(0,e(2668).op)({batchToSpaceND_:function(k,I,T){const c=(0,h._1)(k,"x","batchToSpaceND"),p=I.reduce((L,R)=>L*R);i.hu(c.rank>=1+I.length,()=>`input rank is ${c.rank} but should be > than blockShape.length ${I.length}`),i.hu(T.length===I.length,()=>`crops.length is ${T.length} but should be equal to blockShape.length  ${I.length}`),i.hu(c.shape[0]%p==0,()=>`input tensor batch is ${c.shape[0]} but is not divisible by the product of the elements of blockShape ${I.join(" * ")} === ${p}`);const y={x:c},W={blockShape:I,crops:T};return g.BV.runKernel(n.zw,y,W)}})},7505:(b,u,e)=>{e.d(u,{t:()=>k});var g=e(7097),n=e(9121),h=e(3740),i=e(569),w=e(4968);const k=(0,e(2668).op)({batchNorm_:function(I,T,c,p,y,W){null==W&&(W=.001);const L=(0,h._1)(I,"x","batchNorm"),R=(0,h._1)(T,"mean","batchNorm"),K=(0,h._1)(c,"variance","batchNorm");let re,J;null!=y&&(re=(0,h._1)(y,"scale","batchNorm")),null!=p&&(J=(0,h._1)(p,"offset","batchNorm")),i.hu(R.rank===K.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),i.hu(null==J||R.rank===J.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),i.hu(null==re||R.rank===re.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const ve={x:function(F){let P;return P=0===F.rank||1===F.rank?(0,w.X)(F,[1,1,1,F.size]):2===F.rank?(0,w.X)(F,[1,1,F.shape[0],F.shape[1]]):3===F.rank?(0,w.X)(F,[1,F.shape[0],F.shape[1],F.shape[2]]):F,P}(L),scale:re,offset:J,mean:R,variance:K},ue={varianceEpsilon:W},ie=g.BV.runKernel(n.sH,ve,ue);return(0,w.X)(ie,L.shape)}})},3865:(b,u,e)=>{e.d(u,{y:()=>w});var g=e(7097),n=e(9121),h=e(3740),i=e(569);const w=(0,e(2668).op)({bincount_:function(k,I,T){const c=(0,h._1)(k,"x","bincount"),p=(0,h._1)(I,"weights","bincount");i.hu("int32"===c.dtype,()=>`Error in bincount: input dtype must be int32, but got ${c.dtype}`),i.hu(T>=0,()=>`size must be non-negative, but got ${T}.`),i.hu(p.size===c.size||0===p.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${c.shape}, weights shape: ${p.shape}.`);const y={x:c,weights:p},W={size:T};return g.BV.runKernel(n.zv,y,W)}})},8194:(b,u,e)=>{e.d(u,{X:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({broadcastArgs_:function(w,k){const I=(0,h._1)(w,"s0","broadcastArgs","int32"),T=(0,h._1)(k,"s1","broadcastArgs","int32");if(1!==I.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${I.rank}`);if(1!==T.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${T.rank}`);const c={s0:I,s1:T};return g.BV.runKernel(n.eE,c)}})},8247:(b,u,e)=>{e.d(u,{U:()=>I});var g=e(7097),n=e(9121),h=e(3740),i=e(8723),w=e(2668),k=e(4968);const I=(0,w.op)({broadcastTo_:function(T,c){let p=(0,h._1)(T,"broadcastTo","x");const y=p.shape;if(c.some(re=>!(re>0)||re%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${c}].`);if(c.length<p.rank)throw new Error(`broadcastTo(): shape.length=${c.length} < input.rank=${p.rank}.`);if(c.length>p.rank){const re=p.shape.slice();for(;re.length<c.length;)re.unshift(1);p=(0,k.X)(p,re)}const W=p.shape,L=Array.from(c);for(let re=c.length-1;re>=0;re--)if(W[re]===c[re])L[re]=1;else if(1!==p.shape[re])throw new Error(`broadcastTo(): [${y}] cannot be broadcast to [${c}].`);if(0===L.map((re,J)=>re>1?J:-1).filter(re=>re>=0).length)return(0,i.d)(p);const R={x:p},K={reps:L};return g.BV.runKernel(n.n9,R,K)}})},2200:(b,u,e)=>{function g(i,w){const k=i.length,I=[];for(let T=0;T<k;T++){const c=k-1-T,p=i[c]||1;(w[w.length-1-T]||1)>1&&1===p&&I.unshift(c)}return I}function n(i,w){const k=[];for(let I=0;I<w.length;I++){const T=i[i.length-I-1],c=w.length-I-1,p=w[c];(null==T||1===T&&p>1)&&k.unshift(c)}return k}function h(i,w){const k=[],I=Math.max(i.length,w.length);for(let T=0;T<I;T++){let c=i[i.length-T-1];null==c&&(c=1);let p=w[w.length-T-1];if(null==p&&(p=1),1===c)k.unshift(p);else if(1===p)k.unshift(c);else{if(c!==p){throw Error(`Operands could not be broadcast together with shapes ${i} and ${w}.`)}k.unshift(c)}}return k}e.d(u,{XF:()=>g,RR:()=>n,$N:()=>h})},2657:(b,u,e)=>{e.d(u,{f:()=>h});var g=e(4077),n=e(569);function h(i,w="float32",k){return w=w||"float32",n.Mu(i),new g.YD(i,w,k)}},2271:(b,u,e)=>{e.d(u,{p:()=>w});var g=e(7097),n=e(9121),h=e(3740),i=e(569);const w=(0,e(2668).op)({cast_:function(k,I){const T=(0,h._1)(k,"x","cast");if(!i.LP(I))throw new Error(`Failed to cast to unknown dtype ${I}`);if("string"===I&&"string"!==T.dtype||"string"!==I&&"string"===T.dtype)throw new Error("Only strings can be casted to strings");const c={x:T},p={dtype:I};return g.BV.runKernel(n.RF,c,p)}})},6825:(b,u,e)=>{e.d(u,{m:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({ceil_:function(w){const k={x:(0,h._1)(w,"x","ceil")};return g.BV.runKernel(n.gJ,k)}})},2279:(b,u,e)=>{e.d(u,{i:()=>w});var g=e(7097),n=e(9121),h=e(3740),i=e(569);const w=(0,e(2668).op)({clipByValue_:function(k,I,T){const c=(0,h._1)(k,"x","clipByValue");i.hu(I<=T,()=>`Error in clip: min (${I}) must be less than or equal to max (${T}).`);const p={x:c},y={clipValueMin:I,clipValueMax:T};return g.BV.runKernel(n.xn,p,y)}})},8723:(b,u,e)=>{e.d(u,{d:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({clone_:function(w){const k={x:(0,h._1)(w,"x","clone","string_or_numeric")};return g.BV.runKernel(n.iJ,k)}})},1661:(b,u,e)=>{e.d(u,{P:()=>w});var g=e(7097),n=e(9121),h=e(3740),i=e(569);const w=(0,e(2668).op)({complex_:function(k,I){const T=(0,h._1)(k,"real","complex"),c=(0,h._1)(I,"imag","complex");i.k5(T.shape,c.shape,`real and imag shapes, ${T.shape} and ${c.shape}, must match in call to tf.complex().`);const p={real:T,imag:c};return g.BV.runKernel(n.Zz,p)}})},6884:(b,u,e)=>{e.d(u,{z:()=>k});var g=e(7097),n=e(9121),h=e(3740),i=e(569),w=e(8723);const k=(0,e(2668).op)({concat_:function(I,T=0){(0,i.hu)(I.length>=1,()=>"Pass at least one tensor to concat");const c=(0,h.sI)(I,"tensors","concat","string_or_numeric");if("complex64"===c[0].dtype&&c.forEach(W=>{if("complex64"!==W.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${W.dtype}. `)}),1===c.length)return(0,w.d)(c[0]);const p=c,y={axis:T};return g.BV.runKernel(n.Eh,p,y)}})},1355:(b,u,e)=>{e.d(u,{P:()=>I});var g=e(3740),n=e(569),h=e(4794),i=e(2582),w=e(2668),k=e(4968);const I=(0,w.op)({conv1d_:function(T,c,p,y,W="NWC",L=1,R){const K=(0,g._1)(T,"x","conv1d"),re=(0,g._1)(c,"filter","conv1d");let J=K,ve=false;2===K.rank&&(ve=true,J=(0,k.X)(K,[1,K.shape[0],K.shape[1]])),n.hu(3===J.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${J.rank}.`),n.hu(3===re.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${re.rank}.`),null!=R&&n.hu(n.GN(y),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${R} but got pad ${y}.`),n.hu(J.shape[2]===re.shape[1],()=>`Error in conv1d: depth of input (${J.shape[2]}) must match input depth for filter ${re.shape[1]}.`),n.hu(i.jT(p,L),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${p} and dilation '${L}'`),n.hu("NWC"===W,()=>`Error in conv1d: got dataFormat of ${W} but only NWC is currently supported.`);const ue=(0,k.X)(re,[1,re.shape[0],re.shape[1],re.shape[2]]),ie=(0,k.X)(J,[J.shape[0],1,J.shape[1],J.shape[2]]),F=[1,p],P=[1,L],f=(0,h.T)(ie,ue,F,y,"NHWC",P,R);return ve?(0,k.X)(f,[f.shape[2],f.shape[3]]):(0,k.X)(f,[f.shape[0],f.shape[2],f.shape[3]])}})},4794:(b,u,e)=>{e.d(u,{T:()=>T});var g=e(7097),n=e(9121),h=e(3740),i=e(569),w=e(2582),k=e(2668),I=e(4968);const T=(0,k.op)({conv2d_:function(c,p,y,W,L="NHWC",R=[1,1],K){const re=(0,h._1)(c,"x","conv2d"),J=(0,h._1)(p,"filter","conv2d");let ve=re,ue=false;3===re.rank&&(ue=true,ve=(0,I.X)(re,[1,re.shape[0],re.shape[1],re.shape[2]])),i.hu(4===ve.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${ve.rank}.`),i.hu(4===J.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${J.rank}.`),null!=K&&i.hu(i.GN(W),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${K} but got pad ${W}.`);const ie="NHWC"===L?ve.shape[3]:ve.shape[1];i.hu(ie===J.shape[2],()=>`Error in conv2d: depth of input (${ie}) must match input depth for filter ${J.shape[2]}.`),i.hu(w.jT(y,R),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${y} and dilations '${R}'`);const F={x:ve,filter:J},P={strides:y,pad:W,dataFormat:L,dilations:R,dimRoundingMode:K},f=g.BV.runKernel(n.mh,F,P);return ue?(0,I.X)(f,[f.shape[1],f.shape[2],f.shape[3]]):f}})},9832:(b,u,e)=>{e.d(u,{_:()=>k});var g=e(7097),n=e(9121),h=e(569),i=e(2668),w=e(4968);const k=(0,i.op)({conv2DBackpropInput_:function(I,T,c,p,y,W="NHWC",L){h.hu(I.length===T.rank,()=>`Length of inShape (${I.length}) and rank of dy (${T.rank}) must match`);let R=I,K=T,re=false;3===T.rank&&(re=true,K=(0,w.X)(T,[1,T.shape[0],T.shape[1],T.shape[2]]),R=[1,I[0],I[1],I[2]]),h.hu(4===R.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${R.length}.`),h.hu(4===K.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${K.rank}`),h.hu(4===c.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${c.rank}`);const J="NHWC"===W?R[3]:R[1],ve="NHWC"===W?K.shape[3]:K.shape[1];h.hu(J===c.shape[2],()=>`Error in conv2dDerInput: depth of input (${J}) must match input depth for filter ${c.shape[2]}.`),h.hu(ve===c.shape[3],()=>`Error in conv2dDerInput: depth of output (${ve}) must match output depth for filter ${c.shape[3]}.`),null!=L&&h.hu(h.GN(y),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${L} but got pad ${y}.`);const ue={dy:K,filter:c},ie={strides:p,pad:y,dataFormat:W,dimRoundingMode:L,inputShape:R},F=g.BV.runKernel(n.wm,ue,ie);return re?(0,w.X)(F,[F.shape[1],F.shape[2],F.shape[3]]):F}})},1405:(b,u,e)=>{e.d(u,{b:()=>h});var g=e(3740),n=e(9832);const h=(0,e(2668).op)({conv2dTranspose_:function(i,w,k,I,T,c){const p=(0,g._1)(i,"x","conv2dTranspose"),y=(0,g._1)(w,"filter","conv2dTranspose");return(0,n._)(k,p,y,I,T,"NHWC",c)}})},473:(b,u,e)=>{e.d(u,{p:()=>T});var g=e(7097),n=e(9121),h=e(3740),i=e(569),w=e(2582),k=e(2668),I=e(4968);const T=(0,k.op)({conv3d_:function(c,p,y,W,L="NDHWC",R=[1,1,1]){const K=(0,h._1)(c,"x","conv3d"),re=(0,h._1)(p,"filter","conv3d");let J=K,ve=false;4===K.rank&&(ve=true,J=(0,I.X)(K,[1,K.shape[0],K.shape[1],K.shape[2],K.shape[3]])),i.hu(5===J.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${J.rank}.`),i.hu(5===re.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${re.rank}.`),i.hu(J.shape[4]===re.shape[3],()=>`Error in conv3d: depth of input (${J.shape[4]}) must match input depth for filter ${re.shape[3]}.`),i.hu((0,w.jT)(y,R),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${y} and dilations '${R}'`),i.hu("NDHWC"===L,()=>`Error in conv3d: got dataFormat of ${L} but only NDHWC is currently supported.`);const ue={x:J,filter:re},ie={strides:y,pad:W,dataFormat:L,dilations:R},F=g.BV.runKernel(n.x1,ue,ie);return ve?(0,I.X)(F,[F.shape[1],F.shape[2],F.shape[3],F.shape[4]]):F}})},2582:(b,u,e)=>{function g(R,K,re,J,ve="NHWC",ue){return i(R,[...K,R[3]],re,ue,J,null,null,L(ve))}function n(R,K,re,J,ve,ue,ie="channelsLast"){const[F,P]=I(K);let f;if("channelsLast"===ie)f=[F,P,R[3],R[3]];else{if("channelsFirst"!==ie)throw new Error(`Unknown dataFormat ${ie}`);f=[F,P,R[1],R[1]]}return i(R,f,re,J,ve,ue,false,ie)}function h(R,K,re,J,ve,ue,ie="NDHWC"){const[F,P,f]=T(K);let Q,oe;if("NDHWC"===ie)oe="channelsLast",Q=[F,P,f,R[4],R[4]];else{if("NCDHW"!==ie)throw new Error(`Unknown dataFormat ${ie}`);oe="channelsFirst",Q=[F,P,f,R[1],R[1]]}return w(R,Q,re,J,ve,false,oe,ue)}function i(R,K,re,J,ve,ue,ie=false,F="channelsLast"){let[P,f,Q,oe]=[-1,-1,-1,-1];if("channelsLast"===F)[P,f,Q,oe]=R;else{if("channelsFirst"!==F)throw new Error(`Unknown dataFormat ${F}`);[P,oe,f,Q]=R}const[se,o,,te]=K,[De,Ve]=I(re),[ze,Ke]=I(J),Ye=c(se,ze),rt=c(o,Ke),{padInfo:Qe,outHeight:tt,outWidth:Nt}=function(Ot,zt,Ht,tn,qt,Ut,Wt,Be,Fe){let Y,be,ke;if("number"==typeof Ot){Y={top:Ot,bottom:Ot,left:Ot,right:Ot,type:0===Ot?"VALID":"NUMBER"};const We=function(yt,_t,dt,Ft,Yt){null==Ft&&(Ft=k(yt,_t,dt));const fn=yt[0],an=yt[1],gn=p((fn-_t+2*Ft)/dt+1,Yt),Rt=p((an-_t+2*Ft)/dt+1,Yt);return[gn,Rt]}([zt,Ht],Ut,tn,Ot,Be);be=We[0],ke=We[1]}else if("same"===Ot){be=Math.ceil(zt/tn),ke=Math.ceil(Ht/qt);const We=Math.max(0,(be-1)*tn+Ut-zt),yt=Math.max(0,(ke-1)*qt+Wt-Ht),_t=Math.floor(We/2),dt=We-_t,Ft=Math.floor(yt/2);Y={top:_t,bottom:dt,left:Ft,right:yt-Ft,type:"SAME"}}else if("valid"===Ot)Y={top:0,bottom:0,left:0,right:0,type:"VALID"},be=Math.ceil((zt-Ut+1)/tn),ke=Math.ceil((Ht-Wt+1)/qt);else{if("object"!=typeof Ot)throw Error(`Unknown padding parameter: ${Ot}`);{const We="channelsLast"===Fe?Ot[1][0]:Ot[2][0],yt="channelsLast"===Fe?Ot[1][1]:Ot[2][1],_t="channelsLast"===Fe?Ot[2][0]:Ot[3][0],dt="channelsLast"===Fe?Ot[2][1]:Ot[3][1];Y={top:We,bottom:yt,left:_t,right:dt,type:0===We&&0===yt&&0===_t&&0===dt?"VALID":"EXPLICIT"},be=p((zt-Ut+We+yt)/tn+1,Be),ke=p((Ht-Wt+_t+dt)/qt+1,Be)}}return{padInfo:Y,outHeight:be,outWidth:ke}}(ve,f,Q,De,Ve,Ye,rt,ue,F),$t=ie?te*oe:te;let Ct;return"channelsFirst"===F?Ct=[P,$t,tt,Nt]:"channelsLast"===F&&(Ct=[P,tt,Nt,$t]),{batchSize:P,dataFormat:F,inHeight:f,inWidth:Q,inChannels:oe,outHeight:tt,outWidth:Nt,outChannels:$t,padInfo:Qe,strideHeight:De,strideWidth:Ve,filterHeight:se,filterWidth:o,effectiveFilterHeight:Ye,effectiveFilterWidth:rt,dilationHeight:ze,dilationWidth:Ke,inShape:R,outShape:Ct,filterShape:K}}function w(R,K,re,J,ve,ue=false,ie="channelsLast",F){let[P,f,Q,oe,se]=[-1,-1,-1,-1,-1];if("channelsLast"===ie)[P,f,Q,oe,se]=R;else{if("channelsFirst"!==ie)throw new Error(`Unknown dataFormat ${ie}`);[P,se,f,Q,oe]=R}const[o,te,De,,Ve]=K,[ze,Ke,Ye]=T(re),[rt,Qe,tt]=T(J),Nt=c(o,rt),$t=c(te,Qe),Ct=c(De,tt),{padInfo:Ot,outDepth:zt,outHeight:Ht,outWidth:tn}=function(Wt,Be,Fe,Y,be,ke,We,yt,_t,dt,Ft){let Yt,fn,an,gn;if("number"==typeof Wt){Yt={top:Wt,bottom:Wt,left:Wt,right:Wt,front:Wt,back:Wt,type:0===Wt?"VALID":"NUMBER"};const Rt=function(Xt,jt,Nn,yn,An,vn){null==An&&(An=k(Xt,jt,yn));const Tn=Xt[0],wn=Xt[1],Mn=Xt[2],fr=p((Tn-jt+2*An)/yn+1,vn),Jn=p((wn-jt+2*An)/yn+1,vn),Hr=p((Mn-jt+2*An)/yn+1,vn);return[fr,Jn,Hr,Nn]}([Be,Fe,Y,1],yt,1,be,Wt,Ft);fn=Rt[0],an=Rt[1],gn=Rt[2]}else if("same"===Wt){fn=Math.ceil(Be/be),an=Math.ceil(Fe/ke),gn=Math.ceil(Y/We);const Rt=(fn-1)*be+yt-Be,Xt=(an-1)*ke+_t-Fe,jt=(gn-1)*We+dt-Y,Nn=Math.floor(Rt/2),yn=Rt-Nn,An=Math.floor(Xt/2),vn=Xt-An,Tn=Math.floor(jt/2);Yt={top:An,bottom:vn,left:Tn,right:jt-Tn,front:Nn,back:yn,type:"SAME"}}else{if("valid"!==Wt)throw Error(`Unknown padding parameter: ${Wt}`);Yt={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},fn=Math.ceil((Be-yt+1)/be),an=Math.ceil((Fe-_t+1)/ke),gn=Math.ceil((Y-dt+1)/We)}return{padInfo:Yt,outDepth:fn,outHeight:an,outWidth:gn}}(ve,f,Q,oe,ze,Ke,Ye,Nt,$t,Ct,F),qt=ue?Ve*se:Ve;let Ut;return"channelsFirst"===ie?Ut=[P,qt,zt,Ht,tn]:"channelsLast"===ie&&(Ut=[P,zt,Ht,tn,qt]),{batchSize:P,dataFormat:ie,inDepth:f,inHeight:Q,inWidth:oe,inChannels:se,outDepth:zt,outHeight:Ht,outWidth:tn,outChannels:qt,padInfo:Ot,strideDepth:ze,strideHeight:Ke,strideWidth:Ye,filterDepth:o,filterHeight:te,filterWidth:De,effectiveFilterDepth:Nt,effectiveFilterHeight:$t,effectiveFilterWidth:Ct,dilationDepth:rt,dilationHeight:Qe,dilationWidth:tt,inShape:R,outShape:Ut,filterShape:K}}function k(R,K,re,J=1){const ve=c(K,J);return Math.floor((R[0]*(re-1)-re+ve)/2)}function I(R){return"number"==typeof R?[R,R,R]:2===R.length?[R[0],R[1],1]:R}function T(R){return"number"==typeof R?[R,R,R]:R}function c(R,K){return K<=1?R:R+(R-1)*(K-1)}function p(R,K){if(!K)return Math.trunc(R);switch(K){case"round":return Math.round(R);case"ceil":return Math.ceil(R);case"floor":return Math.floor(R);default:throw new Error(`Unknown roundingMode ${K}`)}}function y(R){const[K,re,J]=I(R);return 1===K&&1===re&&1===J}function W(R,K){return y(R)||y(K)}function L(R){if("NHWC"===R)return"channelsLast";if("NCHW"===R)return"channelsFirst";throw new Error(`Unknown dataFormat ${R}`)}e.d(u,{Rf:()=>g,Xw:()=>n,pl:()=>h,Ix:()=>i,jw:()=>w,aO:()=>k,I0:()=>y,jT:()=>W,sl:()=>L})},173:(b,u,e)=>{e.d(u,{m:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({cos_:function(w){const k={x:(0,h._1)(w,"x","cos")};return g.BV.runKernel(n.mc,k)}})},2699:(b,u,e)=>{e.d(u,{f:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({cosh_:function(w){const k={x:(0,h._1)(w,"x","cosh")};return g.BV.runKernel(n.TR,k)}})},7405:(b,u,e)=>{e.d(u,{z:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({cumsum_:function(w,k=0,I=false,T=false){const c={x:(0,h._1)(w,"x","cumsum")},p={axis:k,exclusive:I,reverse:T};return g.BV.runKernel(n.iH,c,p)}})},5746:(b,u,e)=>{e.d(u,{p:()=>w});var g=e(7097),n=e(9121),h=e(3740),i=e(569);const w=(0,e(2668).op)({denseBincount_:function(k,I,T,c=false){const p=(0,h._1)(k,"x","denseBincount"),y=(0,h._1)(I,"weights","denseBincount");i.hu("int32"===p.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${p.dtype}`),i.hu(p.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${p.rank}.`),i.hu(T>=0,()=>`size must be non-negative, but got ${T}.`),i.hu(y.size===p.size||0===y.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${p.shape}, weights shape: ${y.shape}.`);const W={x:p,weights:y},L={size:T,binaryOutput:c};return g.BV.runKernel(n.QR,W,L)}})},9112:(b,u,e)=>{e.d(u,{n:()=>w});var g=e(7097),n=e(9121),h=e(3740),i=e(569);const w=(0,e(2668).op)({depthToSpace_:function(k,I,T="NHWC"){const c=(0,h._1)(k,"x","depthToSpace"),p="NHWC"===T?c.shape[1]:c.shape[2],y="NHWC"===T?c.shape[2]:c.shape[3],W="NHWC"===T?c.shape[3]:c.shape[1];i.hu(p*I>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${p} and ${I}  for depthToSpace with input shape
    ${c.shape}`),i.hu(y*I>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${y} and ${I} for depthToSpace with input shape
        ${c.shape}`),i.hu(W%(I*I)==0,()=>`Dimension size must be evenly divisible by ${I*I} but is ${W} for depthToSpace with input shape ${c.shape}`);const L={x:c},R={blockSize:I,dataFormat:T};return g.BV.runKernel(n.T0,L,R)}})},4718:(b,u,e)=>{e.d(u,{B:()=>I});var g=e(7097),n=e(9121),h=e(3740),i=e(569),w=e(2668),k=e(4968);const I=(0,w.op)({depthwiseConv2d_:function(T,c,p,y,W="NHWC",L=[1,1],R){const K=(0,h._1)(T,"x","depthwiseConv2d"),re=(0,h._1)(c,"filter","depthwiseConv2d");let J=K,ve=false;3===K.rank&&(ve=true,J=(0,k.X)(K,[1,K.shape[0],K.shape[1],K.shape[2]])),i.hu(4===J.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${J.rank}.`),i.hu(4===re.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${re.rank}.`),i.hu(J.shape[3]===re.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${J.shape[3]}) must match the inChannels dimension in filter ${re.shape[2]}.`),null!=R&&i.hu(i.GN(y),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${R} but got pad ${y}.`);const ue={x:J,filter:re},ie={strides:p,pad:y,dataFormat:W,dilations:L,dimRoundingMode:R},F=g.BV.runKernel(n.ci,ue,ie);return ve?(0,k.X)(F,[F.shape[1],F.shape[2],F.shape[3]]):F}})},557:(b,u,e)=>{e.d(u,{W:()=>I});var g=e(7097),n=e(9121),h=e(3740),i=e(569),w=e(2668),k=e(4968);const I=(0,w.op)({dilation2d_:function(T,c,p,y,W=[1,1],L="NHWC"){const R=(0,h._1)(T,"x","dilation2d"),K=(0,h._1)(c,"filter","dilation2d");i.hu(3===R.rank||4===R.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${R.rank}.`),i.hu(3===K.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${K.rank}.`),i.hu("NHWC"===L,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${L}`);let re=R,J=false;3===R.rank&&(re=(0,k.X)(R,[1,R.shape[0],R.shape[1],R.shape[2]]),J=true);const ve={x:re,filter:K},ue={strides:p,pad:y,dilations:W},ie=g.BV.runKernel(n.p4,ve,ue);return J?(0,k.X)(ie,[ie.shape[1],ie.shape[2],ie.shape[3]]):ie}})},1274:(b,u,e)=>{e.d(u,{h:()=>k});var g=e(7097),n=e(9121),h=e(747),i=e(3740),w=e(9165);const k=(0,e(2668).op)({div_:function(I,T){let c=(0,i._1)(I,"a","div"),p=(0,i._1)(T,"b","div");if([c,p]=(0,h.makeTypesMatch)(c,p),"int32"===c.dtype&&"int32"===p.dtype)return(0,w.q)(c,p);const y={a:c,b:p};return g.BV.runKernel(n.oH,y,{})}})},9322:(b,u,e)=>{e.d(u,{N:()=>T});var g=e(747),n=e(3740),h=e(1274),i=e(6477),w=e(2668),k=e(5912),I=e(6577);const T=(0,w.op)({divNoNan_:function(c,p){let y=(0,n._1)(c,"a","div"),W=(0,n._1)(p,"b","div");[y,W]=(0,g.makeTypesMatch)(y,W);const L=(0,h.h)(y,W),R=(0,I.P)(L),K=(0,i.D)(W,R);return(0,k.a)(K,R,L)}})},4653:(b,u,e)=>{e.d(u,{W:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({einsum_:function(w,...k){const I=k.map((c,p)=>(0,h._1)(c,`tensors${p}`,"einsum")),T={equation:w};return g.BV.runKernel(n.$g,I,T)}})},3233:(b,u,e)=>{e.d(u,{p:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({elu_:function(w){const k={x:(0,h._1)(w,"x","elu")};return g.BV.runKernel(n.SX,k)}})},6477:(b,u,e)=>{e.d(u,{D:()=>k});var g=e(7097),n=e(9121),h=e(747),i=e(3740),w=e(2200);const k=(0,e(2668).op)({equal_:function(I,T){let c=(0,i._1)(I,"a","equal","string_or_numeric"),p=(0,i._1)(T,"b","equal","string_or_numeric");[c,p]=(0,h.makeTypesMatch)(c,p),(0,w.$N)(c.shape,p.shape);const y={a:c,b:p};return g.BV.runKernel(n.hd,y)}})},4650:(b,u,e)=>{e.d(u,{q:()=>k});var g=e(7097),n=e(9121),h=e(3740),i=e(569),w=e(2271);const k=(0,e(2668).op)({erf_:function(I){let T=(0,h._1)(I,"x","erf");i.hu("int32"===T.dtype||"float32"===T.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===T.dtype&&(T=(0,w.p)(T,"float32"));const c={x:T};return g.BV.runKernel(n.Om,c)}})},4842:(b,u,e)=>{e.d(u,{Q:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({exp_:function(w){const k={x:(0,h._1)(w,"x","exp")};return g.BV.runKernel(n.NE,k)}})},1300:(b,u,e)=>{e.d(u,{d:()=>w});var g=e(7097),n=e(9121),h=e(3740),i=e(569);const w=(0,e(2668).op)({expandDims_:function(k,I=0){const T=(0,h._1)(k,"x","expandDims","string_or_numeric");i.hu(I<=T.rank,()=>"Axis must be <= rank of the tensor");const c={input:T},p={dim:I};return g.BV.runKernel(n.YF,c,p)}})},3426:(b,u,e)=>{e.d(u,{t:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({expm1_:function(w){const k={x:(0,h._1)(w,"x","expm1")};return g.BV.runKernel(n.Y0,k)}})},4006:(b,u,e)=>{e.d(u,{h:()=>h});var g=e(7097),n=e(9121);function h(i,w,k){const I={shape:i,value:w,dtype:k};return g.BV.runKernel(n.de,{},I)}},6943:(b,u,e)=>{e.d(u,{G:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({floor_:function(w){const k={x:(0,h._1)(w,"x","floor")};return g.BV.runKernel(n.OR,k)}})},9165:(b,u,e)=>{e.d(u,{q:()=>w});var g=e(7097),n=e(9121),h=e(747),i=e(3740);const w=(0,e(2668).op)({floorDiv_:function(k,I){let T=(0,i._1)(k,"a","floorDiv"),c=(0,i._1)(I,"b","floorDiv");[T,c]=(0,h.makeTypesMatch)(T,c);const p={a:T,b:c};return g.BV.runKernel(n.je,p)}})},2277:(b,u,e)=>{e.r(u),e.d(u,{conv2d:()=>re,depthwiseConv2d:()=>ie,matMul:()=>P});var g=e(7097),n=e(633),h=e(9121),i=e(747),w=e(3740),k=e(569),I=e(6407),T=e(2200),c=e(4794),p=e(2668),y=e(4968);const W=(0,p.op)({conv2DBackpropFilter_:function(f,Q,oe,se,o,te="NHWC",De){let Ve=f;3===f.rank&&(Ve=(0,y.X)(f,[1,f.shape[0],f.shape[1],f.shape[2]]));let ze=Q;3===ze.rank&&(ze=(0,y.X)(Q,[1,Q.shape[0],Q.shape[1],Q.shape[2]])),k.hu(4===Ve.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${Ve.shape}.`),k.hu(4===ze.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${ze.shape}.`),k.hu(4===oe.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${oe}.`);const Ke="NHWC"===te?Ve.shape[3]:Ve.shape[1],Ye="NHWC"===te?ze.shape[3]:ze.shape[1];k.hu(Ke===oe[2],()=>`Error in conv2dDerFilter: depth of input ${Ke}) must match input depth in filter (${oe[2]}.`),k.hu(Ye===oe[3],()=>`Error in conv2dDerFilter: depth of dy (${Ye}) must match output depth for filter (${oe[3]}).`),null!=De&&k.hu(k.GN(o),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${De} but got pad ${o}.`);const rt={x:Ve,dy:ze},Qe={strides:se,pad:o,dataFormat:te,dimRoundingMode:De,filterShape:oe};return g.BV.runKernel(h.wU,rt,Qe)}});var L=e(9832),R=e(2582),K=e(9323);const re=(0,p.op)({fusedConv2d_:function({x:f,filter:Q,strides:oe,pad:se,dataFormat:o="NHWC",dilations:te=[1,1],dimRoundingMode:De,bias:Ve,activation:ze="linear",preluActivationWeights:Ke,leakyreluAlpha:Ye}){if(ze=ze||"linear",false===(0,K.uy)(g.BV.state.gradientDepth,ze)){let qt=(0,c.T)(f,Q,oe,se,o,te,De);return null!=Ve&&(qt=(0,I.I)(qt,Ve)),(0,K.QH)(qt,ze,Ke,Ye)}const rt=(0,w._1)(f,"x","conv2d"),Qe=(0,w._1)(Q,"filter","conv2d");let tt=rt,Nt=false;3===rt.rank&&(Nt=true,tt=(0,y.X)(rt,[1,rt.shape[0],rt.shape[1],rt.shape[2]])),k.hu(4===tt.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${tt.rank}.`),k.hu(4===Qe.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${Qe.rank}.`),null!=De&&k.hu(k.GN(se),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${De} but got pad ${se}.`),k.hu(tt.shape[3]===Qe.shape[2],()=>`Error in conv2d: depth of input (${tt.shape[3]}) must match input depth for filter ${Qe.shape[2]}.`),k.hu(R.jT(oe,te),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${oe} and dilations '${te}'`),k.hu("NHWC"===o,()=>`Error in conv2d: got dataFormat of ${o} but only NHWC is currently supported.`);const $t=R.Ix(tt.shape,Qe.shape,oe,te,se,De);let Ct,Ot;null!=Ve&&(Ct=(0,w._1)(Ve,"bias","fused conv2d"),[Ct]=(0,i.makeTypesMatch)(Ct,rt),T.$N($t.outShape,Ct.shape)),null!=Ke&&(Ot=(0,w._1)(Ke,"prelu weights","fused conv2d"));const zt=(qt,Ut)=>{const[Wt,Be,Fe,Y]=Ut,be=(0,K.Fr)(qt,Fe,ze);k.hu(R.I0(te),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${te}'`);const ke=[(0,L._)(Be.shape,be,Wt,oe,se),W(Be,be,Wt.shape,oe,se)];if(null!=Y){const We=(0,K.pf)(Y,be);ke.push(We)}return ke},Ht={x:tt,filter:Qe,bias:Ct,preluActivationWeights:Ot},tn={strides:oe,pad:se,dataFormat:o,dilations:te,dimRoundingMode:De,activation:ze,leakyreluAlpha:Ye};if(null==Ve){return(0,n.cb)((qt,Ut,Wt)=>{let Be=g.BV.runKernel(h._V,Ht,tn);return Wt([Ut,qt,Be]),Nt&&(Be=(0,y.X)(Be,[Be.shape[1],Be.shape[2],Be.shape[3]])),{value:Be,gradFunc:zt}})(tt,Qe)}return(0,n.cb)((qt,Ut,Wt,Be)=>{let Fe=g.BV.runKernel(h._V,Ht,tn);return Be([Ut,qt,Fe,Wt]),Nt&&(Fe=(0,y.X)(Fe,[Fe.shape[1],Fe.shape[2],Fe.shape[3]])),{value:Fe,gradFunc:zt}})(tt,Qe,Ct)}});var J=e(4718);const ve=(0,p.op)({depthwiseConv2dNativeBackpropFilter_:function(f,Q,oe,se,o,te=[1,1],De){let Ve=f;3===f.rank&&(Ve=(0,y.X)(f,[1,f.shape[0],f.shape[1],f.shape[2]]));let ze=Q;3===ze.rank&&(ze=(0,y.X)(Q,[1,Q.shape[0],Q.shape[1],Q.shape[2]]));const Ke={x:Ve,dy:ze},Ye={strides:se,pad:o,dimRoundingMode:De,dilations:te,filterShape:oe};return g.BV.runKernel(h.sL,Ke,Ye)}});const ue=(0,p.op)({depthwiseConv2dNativeBackpropInput_:function(f,Q,oe,se,o,te=[1,1],De){let Ve=Q,ze=false;3===Q.rank&&(ze=true,Ve=(0,y.X)(Q,[1,Q.shape[0],Q.shape[1],Q.shape[2]]));const Ke={dy:Ve,filter:oe},Ye={strides:se,pad:o,dimRoundingMode:De,dilations:te,inputShape:f},rt=g.BV.runKernel(h.y7,Ke,Ye);return ze?(0,y.X)(rt,[rt.shape[1],rt.shape[2],rt.shape[3]]):rt}});const ie=(0,p.op)({fusedDepthwiseConv2d_:function({x:f,filter:Q,strides:oe,pad:se,dataFormat:o="NHWC",dilations:te=[1,1],dimRoundingMode:De,bias:Ve,activation:ze="linear",preluActivationWeights:Ke,leakyreluAlpha:Ye}){if(false===(0,K.uy)(g.BV.state.gradientDepth,ze)){let qt=(0,J.B)(f,Q,oe,se,o,te,De);return null!=Ve&&(qt=(0,I.I)(qt,Ve)),(0,K.QH)(qt,ze,Ke,Ye)}const rt=(0,w._1)(f,"x","depthwiseConv2d"),Qe=(0,w._1)(Q,"filter","depthwiseConv2d");let tt=rt,Nt=false;3===rt.rank&&(Nt=true,tt=(0,y.X)(rt,[1,rt.shape[0],rt.shape[1],rt.shape[2]])),k.hu(4===tt.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${tt.rank}.`),k.hu(4===Qe.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${Qe.rank}.`),k.hu(tt.shape[3]===Qe.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${tt.shape[3]}) must match the inChannels dimension in filter ${Qe.shape[2]}.`),null==te&&(te=[1,1]),k.hu(R.jT(oe,te),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${oe} and dilations '${te}'`),null!=De&&k.hu(k.GN(se),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${De} but got pad ${se}.`);const $t=R.Ix(tt.shape,Qe.shape,oe,te,se,De,true);let Ct,Ot;null!=Ve&&(Ct=(0,w._1)(Ve,"bias","fused conv2d"),[Ct]=(0,i.makeTypesMatch)(Ct,rt),T.$N($t.outShape,Ct.shape)),null!=Ke&&(Ot=(0,w._1)(Ke,"prelu weights","fused depthwiseConv2d"));const zt=(qt,Ut)=>{k.hu(R.I0(te),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${te}'`);const[Wt,Be,Fe,Y]=Ut,be=(0,K.Fr)(qt,Fe,ze),ke=ue(Be.shape,be,Wt,oe,se,te,De),We=ve(Be,be,Wt.shape,oe,se,te,De);if(null!=Y){return[ke,We,(0,K.pf)(Ct,be)]}return[ke,We]},Ht={x:tt,filter:Qe,bias:Ct,preluActivationWeights:Ot},tn={strides:oe,pad:se,dataFormat:o,dilations:te,dimRoundingMode:De,activation:ze,leakyreluAlpha:Ye};if(null==Ve){return(0,n.cb)((qt,Ut,Wt)=>{let Be=g.BV.runKernel(h.lu,Ht,tn);return Wt([Ut,qt,Be]),Nt&&(Be=(0,y.X)(Be,[Be.shape[1],Be.shape[2],Be.shape[3]])),{value:Be,gradFunc:zt}})(tt,Qe)}return(0,n.cb)((qt,Ut,Wt,Be)=>{let Fe=g.BV.runKernel(h.lu,Ht,tn);return Be([Ut,qt,Fe,Wt]),Nt&&(Fe=(0,y.X)(Fe,[Fe.shape[1],Fe.shape[2],Fe.shape[3]])),{value:Fe,gradFunc:zt}})(tt,Qe,Ct)}});var F=e(8687);const P=(0,p.op)({fusedMatMul_:function({a:f,b:Q,transposeA:oe=false,transposeB:se=false,bias:o,activation:te="linear",preluActivationWeights:De,leakyreluAlpha:Ve}){if(false===(0,K.uy)(g.BV.state.gradientDepth,te)){let Y=(0,F.O)(f,Q,oe,se);return null!=o&&(Y=(0,I.I)(Y,o)),(0,K.QH)(Y,te,De,Ve)}let ze=(0,w._1)(f,"a","fused matMul"),Ke=(0,w._1)(Q,"b","fused matMul");[ze,Ke]=(0,i.makeTypesMatch)(ze,Ke);const Ye=oe?ze.shape[ze.rank-2]:ze.shape[ze.rank-1],rt=se?Ke.shape[Ke.rank-1]:Ke.shape[Ke.rank-2],Qe=oe?ze.shape[ze.rank-1]:ze.shape[ze.rank-2],tt=se?Ke.shape[Ke.rank-2]:Ke.shape[Ke.rank-1],Nt=ze.shape.slice(0,-2),$t=Ke.shape.slice(0,-2),Ct=k.NA(Nt),Ot=k.NA($t);k.hu(ze.rank>=2&&Ke.rank>=2&&ze.rank===Ke.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${ze.rank} and ${Ke.rank}.`),k.hu(k.cO(Nt,$t),()=>`Error in fused matMul: outer dimensions (${Nt}) and (${$t}) of Tensors with shapes ${ze.shape} and ${Ke.shape} must match.`),k.hu(Ye===rt,()=>`Error in fused matMul: inner shapes (${Ye}) and (${rt}) of Tensors with shapes ${ze.shape} and ${Ke.shape} and transposeA=${oe} and transposeB=${se} must match.`);const zt=ze.shape.slice(0,-2).concat([Qe,tt]),Ht=oe?(0,y.X)(ze,[Ct,Ye,Qe]):(0,y.X)(ze,[Ct,Qe,Ye]),tn=se?(0,y.X)(Ke,[Ot,tt,rt]):(0,y.X)(Ke,[Ot,rt,tt]);let qt,Ut;null!=o&&(qt=(0,w._1)(o,"bias","fused matMul"),[qt]=(0,i.makeTypesMatch)(qt,ze),T.$N(zt,qt.shape)),null!=De&&(Ut=(0,w._1)(De,"prelu weights","fused matMul"));const Wt=(Y,be)=>{const[ke,We,yt,_t]=be,dt=(0,K.Fr)((0,y.X)(Y,yt.shape),yt,te);let Ft,Yt;if(oe||se?!oe&&se?(Ft=(0,F.O)(dt,We,false,false),Yt=(0,F.O)(dt,ke,true,false)):oe&&!se?(Ft=(0,F.O)(We,dt,false,true),Yt=(0,F.O)(ke,dt,false,false)):(Ft=(0,F.O)(We,dt,true,true),Yt=(0,F.O)(dt,ke,true,true)):(Ft=(0,F.O)(dt,We,false,true),Yt=(0,F.O)(ke,dt,true,false)),null!=o){return[Ft,Yt,(0,K.pf)(_t,dt)]}return[Ft,Yt]},Be={a:Ht,b:tn,bias:qt,preluActivationWeights:Ut},Fe={transposeA:oe,transposeB:se,activation:te,leakyreluAlpha:Ve};if(null==o){return(0,n.cb)((Y,be,ke)=>{const We=g.BV.runKernel(h.us,Be,Fe);return ke([Y,be,We]),{value:(0,y.X)(We,zt),gradFunc:Wt}})(Ht,tn)}return(0,n.cb)((Y,be,ke,We)=>{const yt=g.BV.runKernel(h.us,Be,Fe);return We([Y,be,yt,ke]),{value:(0,y.X)(yt,zt),gradFunc:Wt}})(Ht,tn,qt)}})},9323:(b,u,e)=>{e.d(u,{Fr:()=>W,pf:()=>L,QH:()=>R,uy:()=>K});var g=e(2200),n=e(3233),h=e(9133),i=e(4841),w=e(8151),k=e(7409),I=e(3582),T=e(4968),c=e(625),p=e(1901),y=e(5475);function W(re,J,ve){if(null==ve||"linear"===ve)return re;if("relu"===ve)return(0,i.d)(re,(0,p.N)(J));throw new Error(`Cannot compute gradient for fused activation ${ve}.`)}function L(re,J){let ve=J;const ue=g.RR(re.shape,J.shape);return ue.length>0&&(ve=(0,y.S)(ve,ue)),(0,T.X)(ve,re.shape)}function R(re,J,ve,ue){if("linear"===J)return re;if("relu"===J)return(0,k.U)(re);if("elu"===J)return(0,n.p)(re);if("relu6"===J)return(0,I.b)(re);if("prelu"===J)return(0,w.A)(re,ve);if("leakyrelu"===J)return(0,h.h)(re,ue);if("sigmoid"===J)return(0,c.X)(re);throw new Error(`Unknown fused activation ${J}.`)}const K=(re,J)=>!(re>0)||"linear"===J},4926:(b,u,e)=>{e.d(u,{I:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({gather_:function(w,k,I=0,T=0){const c={x:(0,h._1)(w,"x","gather"),indices:(0,h._1)(k,"indices","gather","int32")},p={axis:I,batchDims:T};return g.BV.runKernel(n.qi,c,p)}})},7494:(b,u,e)=>{e.d(u,{d:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({gatherND_:function(w,k){const I=(0,h._1)(k,"indices","gatherND","int32"),T={params:(0,h._1)(w,"x","gatherND","string_or_numeric"),indices:I};return g.BV.runKernel(n.q1,T)}})},636:(b,u,e)=>{e.d(u,{p:()=>k});var g=e(7097),n=e(9121),h=e(747),i=e(3740),w=e(2200);const k=(0,e(2668).op)({greater_:function(I,T){let c=(0,i._1)(I,"a","greater","string_or_numeric"),p=(0,i._1)(T,"b","greater","string_or_numeric");[c,p]=(0,h.makeTypesMatch)(c,p),(0,w.$N)(c.shape,p.shape);const y={a:c,b:p};return g.BV.runKernel(n.iZ,y)}})},7630:(b,u,e)=>{e.d(u,{b:()=>k});var g=e(7097),n=e(9121),h=e(747),i=e(3740),w=e(2200);const k=(0,e(2668).op)({greaterEqual_:function(I,T){let c=(0,i._1)(I,"a","greaterEqual","string_or_numeric"),p=(0,i._1)(T,"b","greaterEqual","string_or_numeric");[c,p]=(0,h.makeTypesMatch)(c,p),(0,w.$N)(c.shape,p.shape);const y={a:c,b:p};return g.BV.runKernel(n.Ac,y)}})},4386:(b,u,e)=>{e.d(u,{a:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({imag_:function(w){const k={input:(0,h._1)(w,"input","imag")};return g.BV.runKernel(n.J_,k)}})},6230:(b,u,e)=>{e.d(u,{i:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({isNaN_:function(w){const k={x:(0,h._1)(w,"x","isNaN")};return g.BV.runKernel(n.r7,k)}})},9133:(b,u,e)=>{e.d(u,{h:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({leakyRelu_:function(w,k=.2){const I={x:(0,h._1)(w,"x","leakyRelu")},T={alpha:k};return g.BV.runKernel(n.J$,I,T)}})},6573:(b,u,e)=>{e.d(u,{d:()=>k});var g=e(7097),n=e(9121),h=e(747),i=e(3740),w=e(2200);const k=(0,e(2668).op)({less_:function(I,T){let c=(0,i._1)(I,"a","less","string_or_numeric"),p=(0,i._1)(T,"b","less","string_or_numeric");[c,p]=(0,h.makeTypesMatch)(c,p),(0,w.$N)(c.shape,p.shape);const y={a:c,b:p};return g.BV.runKernel(n.vt,y)}})},624:(b,u,e)=>{e.d(u,{z:()=>k});var g=e(7097),n=e(9121),h=e(747),i=e(3740),w=e(2200);const k=(0,e(2668).op)({lessEqual_:function(I,T){let c=(0,i._1)(I,"a","lessEqual","string_or_numeric"),p=(0,i._1)(T,"b","lessEqual","string_or_numeric");[c,p]=(0,h.makeTypesMatch)(c,p),(0,w.$N)(c.shape,p.shape);const y={a:c,b:p};return g.BV.runKernel(n.CA,y)}})},4135:(b,u,e)=>{e.d(u,{S:()=>h});var g=e(7097),n=e(9121);function h(i,w,k){if(k<=0)throw new Error("The number of values should be positive.");const I={start:i,stop:w,num:k};return g.BV.runKernel(n.e7,{},I)}},9648:(b,u,e)=>{e.d(u,{G:()=>I});var g=e(7097),n=e(9121),h=e(3740),i=e(569),w=e(2668),k=e(4968);const I=(0,w.op)({localResponseNormalization_:function(T,c=5,p=1,y=1,W=.5){const L=(0,h._1)(T,"x","localResponseNormalization");i.hu(4===L.rank||3===L.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${L.rank}.`),i.hu(i.GN(c),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${c}.`);let R=L,K=false;3===L.rank&&(K=true,R=(0,k.X)(L,[1,L.shape[0],L.shape[1],L.shape[2]]));const re={x:R},J={depthRadius:c,bias:p,alpha:y,beta:W},ve=g.BV.runKernel(n.eZ,re,J);return K?(0,k.X)(ve,[ve.shape[1],ve.shape[2],ve.shape[3]]):ve}})},2597:(b,u,e)=>{e.d(u,{c:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({log_:function(w){const k={x:(0,h._1)(w,"x","log")};return g.BV.runKernel(n.Zb,k)}})},7474:(b,u,e)=>{e.d(u,{K:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({log1p_:function(w){const k={x:(0,h._1)(w,"x","log1p")};return g.BV.runKernel(n.kU,k)}})},1510:(b,u,e)=>{e.d(u,{C:()=>y});var g=e(633),n=e(3740),h=e(2271),i=e(4842),w=e(2597),k=e(3307),I=e(4841),T=e(2668),c=e(827),p=e(5475);const y=(0,T.op)({logSoftmax_:function(W,L=-1){const R=(0,n._1)(W,"logits","logSoftmax");if(-1===L&&(L=R.rank-1),L!==R.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${R.rank} and axis was ${L}`);return(0,g.cb)((K,re)=>{const J=(0,k.F)(K,L,true),ve=(0,c.l)(K,J),ue=(0,c.l)((0,h.p)(ve,"float32"),(0,w.c)((0,p.S)((0,i.Q)(ve),L,true)));re([ue]);return{value:ue,gradFunc:(ie,F)=>{const[P]=F,f=(0,i.Q)(P);return(0,c.l)(ie,(0,I.d)((0,p.S)(ie,L,true),f))}}})(R)}})},2856:(b,u,e)=>{e.d(u,{H:()=>w});var g=e(7097),n=e(9121),h=e(3740),i=e(2200);const w=(0,e(2668).op)({logicalAnd_:function(k,I){const T=(0,h._1)(k,"a","logicalAnd","bool"),c=(0,h._1)(I,"b","logicalAnd","bool");(0,i.$N)(T.shape,c.shape);const p={a:T,b:c};return g.BV.runKernel(n.PY,p)}})},8651:(b,u,e)=>{e.d(u,{h:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({logicalNot_:function(w){const k={x:(0,h._1)(w,"x","logicalNot","bool")};return g.BV.runKernel(n.Vf,k)}})},5750:(b,u,e)=>{e.d(u,{K:()=>w});var g=e(7097),n=e(9121),h=e(3740),i=e(2200);const w=(0,e(2668).op)({logicalOr_:function(k,I){const T=(0,h._1)(k,"a","logicalOr","bool"),c=(0,h._1)(I,"b","logicalOr","bool");(0,i.$N)(T.shape,c.shape);const p={a:T,b:c};return g.BV.runKernel(n.MZ,p)}})},9876:(b,u,e)=>{var g;e.d(u,{I:()=>g}),function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(g||(g={}))},8687:(b,u,e)=>{e.d(u,{O:()=>w});var g=e(7097),n=e(9121),h=e(747),i=e(3740);const w=(0,e(2668).op)({matMul_:function(k,I,T=false,c=false){let p=(0,i._1)(k,"a","matMul"),y=(0,i._1)(I,"b","matMul");[p,y]=(0,h.makeTypesMatch)(p,y);const W={a:p,b:y},L={transposeA:T,transposeB:c};return g.BV.runKernel(n.XL,W,L)}})},3307:(b,u,e)=>{e.d(u,{F:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({max_:function(w,k=null,I=false){const T={x:(0,h._1)(w,"x","max")},c={reductionIndices:k,keepDims:I};return g.BV.runKernel(n.Yo,T,c)}})},1174:(b,u,e)=>{e.d(u,{_:()=>T});var g=e(7097),n=e(9121),h=e(3740),i=e(569),w=e(2582),k=e(2668),I=e(4968);const T=(0,k.op)({maxPool_:function(c,p,y,W,L){const R=(0,h._1)(c,"x","maxPool");let K=R,re=false;3===R.rank&&(re=true,K=(0,I.X)(R,[1,R.shape[0],R.shape[1],R.shape[2]])),i.hu(4===K.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${K.rank}.`),i.hu(w.jT(y,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${y} and dilations '1'`),null!=L&&i.hu(i.GN(W),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${L} but got pad ${W}.`);const J={x:K},ve={filterSize:p,strides:y,pad:W,dimRoundingMode:L},ue=g.BV.runKernel(n.mT,J,ve);return re?(0,I.X)(ue,[ue.shape[1],ue.shape[2],ue.shape[3]]):ue}})},5020:(b,u,e)=>{e.d(u,{Y:()=>I});var g=e(7097),n=e(9121),h=e(3740),i=e(569),w=e(2668),k=e(4968);const I=(0,w.op)({maxPool3d_:function(T,c=[1,1,1],p,y,W,L="NDHWC"){const R=(0,h._1)(T,"x","maxPool3d");let K=R,re=false;4===R.rank&&(re=true,K=(0,k.X)(R,[1,R.shape[0],R.shape[1],R.shape[2],R.shape[3]])),i.hu(5===K.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${K.rank}.`),i.hu("NDHWC"===L,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${L}`),null!=W&&i.hu(i.GN(y),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${W} but got pad ${y}.`);const J={x:K},ve={filterSize:c,strides:p,pad:y,dimRoundingMode:W,dataFormat:L},ue=g.BV.runKernel(n.OA,J,ve);return re?(0,k.X)(ue,[ue.shape[1],ue.shape[2],ue.shape[3],ue.shape[4]]):ue}})},6877:(b,u,e)=>{e.d(u,{I:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({maxPoolWithArgmax_:function(w,k,I,T,c=false){const p={x:(0,h._1)(w,"x","maxPoolWithArgmax")},y={filterSize:k,strides:I,pad:T,includeBatchInIndex:c},W=g.BV.runKernel(n.vF,p,y);return{result:W[0],indexes:W[1]}}})},632:(b,u,e)=>{e.d(u,{g:()=>I});var g=e(7097),n=e(9121),h=e(747),i=e(3740),w=e(2200),k=e(2271);const I=(0,e(2668).op)({maximum_:function(T,c){let p=(0,i._1)(T,"a","maximum"),y=(0,i._1)(c,"b","maximum");[p,y]=(0,h.makeTypesMatch)(p,y),"bool"===p.dtype&&(p=(0,k.p)(p,"int32"),y=(0,k.p)(y,"int32")),(0,w.$N)(p.shape,y.shape);const W={a:p,b:y};return g.BV.runKernel(n.BM,W)}})},5130:(b,u,e)=>{e.d(u,{J:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({mean_:function(w,k=null,I=false){const T={x:(0,h._1)(w,"x","mean")},c={axis:k,keepDims:I};return g.BV.runKernel(n.q2,T,c)}})},5735:(b,u,e)=>{e.d(u,{V:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({min_:function(w,k=null,I=false){const T={x:(0,h._1)(w,"x","min")},c={axis:k,keepDims:I};return g.BV.runKernel(n.c1,T,c)}})},4513:(b,u,e)=>{e.d(u,{L:()=>I});var g=e(7097),n=e(9121),h=e(747),i=e(3740),w=e(2200),k=e(2271);const I=(0,e(2668).op)({minimum_:function(T,c){let p=(0,i._1)(T,"a","minimum"),y=(0,i._1)(c,"b","minimum");[p,y]=(0,h.makeTypesMatch)(p,y),"bool"===p.dtype&&(p=(0,k.p)(p,"int32"),y=(0,k.p)(y,"int32")),(0,w.$N)(p.shape,y.shape);const W={a:p,b:y};return g.BV.runKernel(n.q8,W)}})},1483:(b,u,e)=>{e.d(u,{V:()=>w});var g=e(7097),n=e(9121),h=e(3740),i=e(569);const w=(0,e(2668).op)({mirrorPad_:function(k,I,T){i.hu("reflect"===T||"symmetric"===T,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${T}.`);const c=(0,h._1)(k,"x","mirrorPad");if(0===c.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");i.hu(I.length===c.rank,()=>`Padding doesn't match input. Must be ${c.rank}. Got ${I.length}.`);const p="reflect"===T?1:0;for(let L=0;L<c.rank;L++)i.hu(2===I[L].length,()=>"Invalid number of paddings. Must be length of 2 each."),i.hu(I[L][0]>=0&&I[L][0]<=c.shape[L]-p&&I[L][1]>=0&&I[L][1]<=c.shape[L]-p,()=>`Padding in dimension ${L} cannot be greater than or equal to ${c.shape[L]-p} or less than 0 for input of shape ${c.shape}`);const y={paddings:I,mode:T},W={x:c};return g.BV.runKernel(n.jQ,W,y)}})},5228:(b,u,e)=>{e.d(u,{w:()=>w});var g=e(7097),n=e(9121),h=e(747),i=e(3740);const w=(0,e(2668).op)({mod_:function(k,I){let T=(0,i._1)(k,"a","mod"),c=(0,i._1)(I,"b","mod");[T,c]=(0,h.makeTypesMatch)(T,c);const p={a:T,b:c};return g.BV.runKernel(n.Vb,p)}})},4841:(b,u,e)=>{e.d(u,{d:()=>w});var g=e(7097),n=e(9121),h=e(747),i=e(3740);const w=(0,e(2668).op)({mul_:function(k,I){let T=(0,i._1)(k,"a","mul"),c=(0,i._1)(I,"b","mul");[T,c]=(0,h.makeTypesMatch)(T,c);const p={a:T,b:c};return g.BV.runKernel(n.wY,p)}})},686:(b,u,e)=>{e.d(u,{S:()=>k});var g=e(7097),n=e(9121),h=e(3740),i=e(2668),w=e(4968);const k=(0,i.op)({multinomial_:function(I,T,c,p=false){const y=(0,h._1)(I,"logits","multinomial"),W=y.size,L=y.rank;if(W<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${W}.`);if(L>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${L}`);c=c||Math.random();const R={logits:1===L?(0,w.X)(y,[1,-1]):y},K={numSamples:T,seed:c,normalized:p},re=g.BV.runKernel(n.NZ,R,K);return 1===L?(0,w.X)(re,[re.size]):re}})},7370:(b,u,e)=>{e.d(u,{W:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({neg_:function(w){const k={x:(0,h._1)(w,"x","neg")};return g.BV.runKernel(n.ku,k)}})},6500:(b,u,e)=>{e.d(u,{Q:()=>k});var g=e(7097),n=e(9121),h=e(747),i=e(3740),w=e(2200);const k=(0,e(2668).op)({notEqual_:function(I,T){let c=(0,i._1)(I,"a","notEqual","string_or_numeric"),p=(0,i._1)(T,"b","notEqual","string_or_numeric");[c,p]=(0,h.makeTypesMatch)(c,p),(0,w.$N)(c.shape,p.shape);const y={a:c,b:p};return g.BV.runKernel(n.yQ,y)}})},6708:(b,u,e)=>{e.d(u,{l:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({oneHot_:function(w,k,I=1,T=0){if(k<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${k}`);const c={indices:(0,h._1)(w,"indices","oneHot","int32")},p={depth:k,onValue:I,offValue:T};return g.BV.runKernel(n.we,c,p)}})},4917:(b,u,e)=>{e.d(u,{i:()=>w});var g=e(7097),n=e(569),h=e(1661),i=e(9640);function w(k,I="float32"){if("complex64"===I){const c=w(k,"float32"),p=(0,i.l)(k,"float32");return(0,h.P)(c,p)}const T=(0,n.p8)((0,n.NA)(k),I);return g.BV.makeTensor(T,k,I)}},7846:(b,u,e)=>{e.d(u,{J:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({onesLike_:function(w){const k={x:(0,h._1)(w,"x","onesLike")};return g.BV.runKernel(n.qW,k)}})},2668:(b,u,e)=>{e.d(u,{z:()=>h,op:()=>i});var g=e(7097),n=e(569);const h="__op";function i(w){const k=Object.keys(w);if(1!==k.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${k.length} keys.`);let I=k[0];const T=w[I];I.endsWith("_")&&(I=I.substring(0,I.length-1)),I+=h;const c=(...p)=>{g.BV.startScope(I);try{const y=T(...p);return(0,n.tI)(y)&&console.error("Cannot return a Promise inside of tidy."),g.BV.endScope(y),y}catch(y){throw g.BV.endScope(null),y}};return Object.defineProperty(c,"name",{value:I,configurable:true}),c}},4885:(b,u,e)=>{e.d(u,{zvA:()=>F.z,WnP:()=>g.W,Khb:()=>n.K,__u:()=>h._,IHx:()=>i.I,QBD:()=>w.Q,$6P:()=>k.$,YjB:()=>I.Y,NqF:()=>T.N,vHJ:()=>c.v,ZRM:()=>p.Z,VfV:()=>y.V,z4N:()=>W.z,fvJ:()=>L.f,C80:()=>R.C,wS1:()=>K.w,uR5:()=>re.u,zEQ:()=>oe,tgs:()=>o.t,Dxk:()=>De,JY5:()=>Ve,p3b:()=>ze,E4h:()=>se.E,yE8:()=>Ke.y,anm:()=>Es,XsQ:()=>Ye.X,UFq:()=>rt.U,f3b:()=>Qe.f,pju:()=>tt.p,mDi:()=>Nt.m,iUl:()=>$t.i,d9v:()=>Ct.d,PYB:()=>Ot.P,zoF:()=>ve.z,gME:()=>zt,Izb:()=>Ht,MNy:()=>tn,ZaL:()=>qt,PAt:()=>Ut.P,Tek:()=>Wt.T,bc:()=>Be.b,pdZ:()=>Fe.p,$QV:()=>yt,mCk:()=>_t.m,f9Y:()=>dt.f,mew:()=>va,zbp:()=>Ft.z,ppE:()=>Yt.p,nTT:()=>fn.n,B10:()=>an.B,Ka3:()=>gn,WmZ:()=>Rt.W,hiC:()=>Xt.h,NTj:()=>jt.N,AKD:()=>Nn,rvX:()=>to,WYO:()=>yn.W,pyx:()=>An.p,GRh:()=>Fa,DgJ:()=>vn.D,qNN:()=>Tn.q,Qqt:()=>wn.Q,dt4:()=>Mn.d,t$B:()=>fr.t,iyy:()=>Hr,kp_:()=>Gs.k,hlL:()=>ir.h,GWj:()=>Ds.G,qPi:()=>hs.q,imm:()=>no,Iqj:()=>ur.I,dbB:()=>eo.d,pjt:()=>jr.p,brS:()=>Gr.b,Sxn:()=>Er.S,asL:()=>$n.a,BHj:()=>fo,V3u:()=>Js,wx0:()=>Ca.w,xVT:()=>Fs,UWc:()=>Os,i2d:()=>Bs.i,hi7:()=>Kr.h,d9m:()=>Xr.d,zN1:()=>Zr.z,$r2:()=>zo,SX3:()=>ps.S,G9k:()=>oa.G,cM7:()=>mr.c,Krr:()=>Ls.K,e_t:()=>Ps,CmS:()=>ms.C,l_t:()=>Gn,HvI:()=>Qr.H,hJK:()=>yr.h,K5V:()=>Jr.K,egP:()=>Rs,MB5:()=>Wo,OI3:()=>ue.O,Fp7:()=>Dr.F,_sB:()=>Vs._,YQQ:()=>zs.Y,Ip$:()=>gs.I,gWQ:()=>Fr.g,J69:()=>Yr.J,ry_:()=>ys,VV$:()=>lr.V,LTh:()=>ts.L,VdP:()=>bs.V,wQq:()=>ks.w,Gi7:()=>ns,p_:()=>Ja,dC7:()=>ie.d,rq4:()=>Ws,SJ_:()=>ws.S,W76:()=>Dn.W,KOy:()=>wa,Quu:()=>Us.Q,lfX:()=>Un.l,iUs:()=>Kn.i,JpU:()=>vs.J,op:()=>F.op,N2O:()=>Br,vku:()=>nr.v,pNR:()=>cr,koy:()=>Fn,t1L:()=>ua,lGY:()=>Tr,d_R:()=>ss,sQ3:()=>Lr.s,AL3:()=>la.A,S0v:()=>ca.S,WVs:()=>da.W,TN_:()=>Ns,wzB:()=>ha,nGf:()=>Hs,LGj:()=>xs.L,w6H:()=>Bt.w,kwC:()=>on.k,M25:()=>Yn.M,UYe:()=>Zt.U,btT:()=>Ir.b,XLQ:()=>ke.X,GYS:()=>Xn.G,SDf:()=>er,diP:()=>br,sx7:()=>kr,mG2:()=>dr,QEs:()=>Ar.Q,NMM:()=>Pr.N,bp0:()=>Ln.b,iD$:()=>un.i,snQ:()=>Da.s,U8D:()=>as.U,U_I:()=>wr,ODp:()=>vr.O,XD2:()=>P.X,Xxe:()=>pa.X,tdS:()=>Sa,O$l:()=>js.O,R_K:()=>Rr.R,tPi:()=>f.t,jZU:()=>hr,SmN:()=>os,CnO:()=>is,p0P:()=>us,XAC:()=>Ie.X,Wvh:()=>Sr.W,fBT:()=>rs.f,rVs:()=>Uo,ers:()=>Ya.e,uN7:()=>na,Vl2:()=>fa.V,_b3:()=>Pn._,h62:()=>Or.h,$i:()=>Ks.$,L9e:()=>Xs.L,knu:()=>_s.k,Nbs:()=>Nr.N,NXj:()=>Zs.N,Z_8:()=>qo,luU:()=>sn.l,Smz:()=>Ce.S,ORZ:()=>ma.O,AEp:()=>Q.A,XeE:()=>ga.X,RRF:()=>rr.R,odF:()=>Ts,wOQ:()=>Wa.w,yXz:()=>Ua,Bfx:()=>qa,xZs:()=>Ha,Gg6:()=>Jn.G,hg7:()=>ja.h,p4s:()=>As.p,Xu6:()=>Ga.X,Two:()=>$a.T,pUJ:()=>Ka,HHK:()=>ya.H,VD$:()=>Xa,arb:()=>Is.a,itS:()=>Qs.i,lls:()=>ba.l,P84:()=>Za.P});var g=e(6235),n=e(7839),h=e(1470),i=e(6407),w=e(3135),k=e(781),I=e(2998),T=e(47),c=e(7394),p=e(2421),y=e(1891),W=e(7037),L=e(9812),R=e(369),K=e(5176),re=e(1749),J=e(3740),ve=e(6884),ue=e(8687),ie=e(4841),F=e(2668),P=e(625),f=e(2676),Q=e(1869);const oe=(0,F.op)({basicLSTMCell_:function(ge,he,ce,ye,Ne,Se){const Ae=(0,J._1)(ge,"forgetBias","basicLSTMCell"),Pe=(0,J._1)(he,"lstmKernel","basicLSTMCell"),et=(0,J._1)(ce,"lstmBias","basicLSTMCell"),je=(0,J._1)(ye,"data","basicLSTMCell"),ft=(0,J._1)(Ne,"c","basicLSTMCell"),Tt=(0,J._1)(Se,"h","basicLSTMCell"),Vt=(0,ve.z)([je,Tt],1),bn=(0,ue.O)(Vt,Pe),dn=(0,i.I)(bn,et),Qt=dn.shape[0],Rn=dn.shape[1]/4,Zn=[Qt,Rn],Vn=(0,f.t)(dn,[0,0],Zn),Cr=(0,f.t)(dn,[0,Rn],Zn),zn=(0,f.t)(dn,[0,2*Rn],Zn),Wn=(0,f.t)(dn,[0,3*Rn],Zn),qn=(0,i.I)((0,ie.d)((0,P.X)(Vn),(0,Q.A)(Cr)),(0,ie.d)(ft,(0,P.X)((0,i.I)(Ae,zn))));return[qn,(0,ie.d)((0,Q.A)(qn),(0,P.X)(Wn))]}});var se=e(8441),o=e(7505),te=e(569);const De=(0,F.op)({batchNorm2d_:function(ge,he,ce,ye,Ne,Se){const Ae=(0,J._1)(ge,"x","batchNorm"),Pe=(0,J._1)(he,"mean","batchNorm"),et=(0,J._1)(ce,"variance","batchNorm");let je,ft;return null!=Ne&&(je=(0,J._1)(Ne,"scale","batchNorm")),null!=ye&&(ft=(0,J._1)(ye,"offset","batchNorm")),te.hu(2===Ae.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${Ae.rank}.`),te.hu(2===Pe.rank||1===Pe.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${Pe.rank}.`),te.hu(2===et.rank||1===et.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${et.rank}.`),null!=je&&te.hu(2===je.rank||1===je.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${je.rank}.`),null!=ft&&te.hu(2===ft.rank||1===ft.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${ft.rank}.`),(0,o.t)(Ae,Pe,et,ft,je,Se)}});const Ve=(0,F.op)({batchNorm3d_:function(ge,he,ce,ye,Ne,Se){const Ae=(0,J._1)(ge,"x","batchNorm"),Pe=(0,J._1)(he,"mean","batchNorm"),et=(0,J._1)(ce,"variance","batchNorm");let je,ft;return null!=Ne&&(je=(0,J._1)(Ne,"scale","batchNorm")),null!=ye&&(ft=(0,J._1)(ye,"offset","batchNorm")),te.hu(3===Ae.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${Ae.rank}.`),te.hu(3===Pe.rank||1===Pe.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${Pe.rank}.`),te.hu(3===et.rank||1===et.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${et.rank}.`),null!=je&&te.hu(3===je.rank||1===je.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${je.rank}.`),null!=ft&&te.hu(3===ft.rank||1===ft.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${ft.rank}.`),(0,o.t)(Ae,Pe,et,ft,je,Se)}});const ze=(0,F.op)({batchNorm4d_:function(ge,he,ce,ye,Ne,Se){const Ae=(0,J._1)(ge,"x","batchNorm"),Pe=(0,J._1)(he,"mean","batchNorm"),et=(0,J._1)(ce,"variance","batchNorm");let je,ft;return null!=Ne&&(je=(0,J._1)(Ne,"scale","batchNorm")),null!=ye&&(ft=(0,J._1)(ye,"offset","batchNorm")),te.hu(4===Ae.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${Ae.rank}.`),te.hu(4===Pe.rank||1===Pe.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${Pe.rank}.`),te.hu(4===et.rank||1===et.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${et.rank}.`),null!=je&&te.hu(4===je.rank||1===je.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${je.rank}.`),null!=ft&&te.hu(4===ft.rank||1===ft.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${ft.rank}.`),(0,o.t)(Ae,Pe,et,ft,je,Se)}});var Ke=e(3865),Ye=e(8194),rt=e(8247),Qe=e(2657),tt=e(2271),Nt=e(6825),$t=e(2279),Ct=e(8723),Ot=e(1661);const zt=(0,F.op)({concat1d_:function(ge){return(0,ve.z)(ge,0)}});const Ht=(0,F.op)({concat2d_:function(ge,he){return(0,ve.z)(ge,he)}});const tn=(0,F.op)({concat3d_:function(ge,he){return(0,ve.z)(ge,he)}});const qt=(0,F.op)({concat4d_:function(ge,he){return(0,ve.z)(ge,he)}});var Ut=e(1355),Wt=e(4794),Be=e(1405),Fe=e(473),Y=e(7097),be=e(9121),ke=e(4968);const We=(0,F.op)({conv3DBackpropInput_:function(ge,he,ce,ye,Ne){te.hu(ge.length===he.rank,()=>`Length of inShape (${ge.length}) and rank of dy (${he.rank}) must match`);let Se=ge,Ae=he,Pe=false;4===he.rank&&(Pe=true,Ae=(0,ke.X)(he,[1,he.shape[0],he.shape[1],he.shape[2],he.shape[3]]),Se=[1,ge[0],ge[1],ge[2],ge[3]]);const et=Se[4],je=Ae.shape[4];te.hu(5===Se.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${Se.length}.`),te.hu(5===Ae.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${Ae.rank}`),te.hu(5===ce.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${ce.rank}`),te.hu(et===ce.shape[3],()=>`Error in conv3dDerInput: depth of input (${et}) must match input depth for filter ${ce.shape[3]}.`),te.hu(je===ce.shape[4],()=>`Error in conv3dDerInput: depth of output (${je}) must match output depth for filter ${ce.shape[4]}.`);const ft={dy:Ae,filter:ce},Tt={pad:Ne,strides:ye,inputShape:Se},Vt=Y.BV.runKernel(be.ik,ft,Tt);return Pe?(0,ke.X)(Vt,[Vt.shape[1],Vt.shape[2],Vt.shape[3],Vt.shape[4]]):Vt}});const yt=(0,F.op)({conv3dTranspose_:function(ge,he,ce,ye,Ne){const Se=(0,J._1)(ge,"x","conv3dTranspose"),Ae=(0,J._1)(he,"filter","conv3dTranspose");return We(ce,Se,Ae,ye,Ne)}});var _t=e(173),dt=e(2699),Ft=e(7405),Yt=e(5746),fn=e(9112),an=e(4718);const gn=(0,F.op)({diag_:function(ge){const he={x:(0,J._1)(ge,"x","diag")};return Y.BV.runKernel(be.$w,he)}});var Rt=e(557),Xt=e(1274),jt=e(9322);const Nn=(0,F.op)({dot_:function(ge,he){const ce=(0,J._1)(ge,"t1","dot"),ye=(0,J._1)(he,"t2","dot");te.hu(!(1!==ce.rank&&2!==ce.rank||1!==ye.rank&&2!==ye.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${ce.rank} and ${ye.rank}.`);const Ne=1===ce.rank?ce.size:ce.shape[1],Se=1===ye.rank?ye.size:ye.shape[0];if(te.hu(Ne===Se,()=>`Error in dot: inner dimensions of inputs must match, but got ${Ne} and ${Se}.`),1===ce.rank&&1===ye.rank){const Ae=(0,ke.X)(ce,[1,-1]),Pe=(0,ke.X)(ye,[-1,1]),et=(0,ue.O)(Ae,Pe);return(0,ke.X)(et,[])}if(1===ce.rank&&2===ye.rank){const Ae=(0,ke.X)(ce,[1,-1]),Pe=(0,ke.X)(ye,[ye.shape[0],ye.shape[1]]),et=(0,ue.O)(Ae,Pe);return(0,ke.X)(et,[et.size])}if(2===ce.rank&&1===ye.rank){const Ae=(0,ke.X)(ye,[-1,1]),Pe=(0,ue.O)(ce,Ae);return(0,ke.X)(Pe,[Pe.size])}{const Ae=(0,ke.X)(ye,[ye.shape[0],ye.shape[1]]);return(0,ue.O)(ce,Ae)}}});var yn=e(4653),An=e(3233),vn=e(6477),Tn=e(4650),wn=e(4842),Mn=e(1300),fr=e(3426),Jn=e(7501);const Hr=(0,F.op)({eye_:function(ge,he,ce,ye="float32"){null==he&&(he=ge);const Ne=(0,Qe.f)([ge,he],ye),Se=ge<=he?ge:he;for(let Pe=0;Pe<Se;++Pe)Ne.set(1,Pe,Pe);const Ae=(0,ke.X)(Ne.toTensor(),[ge,he]);if(null==ce)return Ae;if(1===ce.length)return(0,Jn.G)((0,Mn.d)(Ae,0),[ce[0],1,1]);if(2===ce.length)return(0,Jn.G)((0,Mn.d)((0,Mn.d)(Ae,0),0),[ce[0],ce[1],1,1]);if(3===ce.length)return(0,Jn.G)((0,Mn.d)((0,Mn.d)((0,Mn.d)(Ae,0),0),0),[ce[0],ce[1],ce[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${ce.length}D.`)}});var ir=e(4006),Ds=e(6943),hs=e(9165),ur=e(4926),jr=e(636),Gr=e(7630),$n=e(4386);const Fs=(0,F.op)({isFinite_:function(ge){const he={x:(0,J._1)(ge,"x","isFinite")};return Y.BV.runKernel(be.av,he)}});const Os=(0,F.op)({isInf_:function(ge){const he={x:(0,J._1)(ge,"x","isInf")};return Y.BV.runKernel(be.iW,he)}});var Bs=e(6230),Kr=e(9133),Xr=e(6573),Zr=e(624),ps=e(4135),oa=e(9648),mr=e(2597),Ls=e(7474),fs=e(633),Dn=e(7370),Sr=e(3694);const Ps=(0,F.op)({logSigmoid_:function(ge){const he=(0,J._1)(ge,"x","logSigmoid");return(0,fs.cb)(ce=>({value:(0,Dn.W)((0,Sr.W)((0,Dn.W)(ce))),gradFunc:ye=>(0,ie.d)(ye,(0,P.X)((0,Dn.W)(ce)))}))(he)}});var ms=e(1510),gr=e(3591),Dr=e(3307),sn=e(827),Ce=e(5475);const Gn=(0,F.op)({logSumExp_:function(ge,he=null,ce=false){const ye=(0,J._1)(ge,"x","logSumExp"),Ne=(0,te.EC)(he,ye.shape),Se=(0,Dr.F)(ye,Ne,true),Ae=(0,sn.l)(ye,Se),Pe=(0,wn.Q)(Ae),et=(0,Ce.S)(Pe,Ne),je=(0,mr.c)(et),ft=(0,i.I)((0,ke.X)(Se,je.shape),je);if(ce){const Tt=(0,gr.rv)(ft.shape,Ne);return(0,ke.X)(ft,Tt)}return ft}});var Qr=e(2856),yr=e(8651),Jr=e(5750),ia=e(2200);const Rs=(0,F.op)({logicalXor_:function(ge,he){const ce=(0,J._1)(ge,"a","logicalXor","bool"),ye=(0,J._1)(he,"b","logicalXor","bool");return(0,ia.$N)(ce.shape,ye.shape),(0,Qr.H)((0,Jr.K)(ge,he),(0,yr.h)((0,Qr.H)(ge,he)))}});var Vs=e(1174),zs=e(5020),gs=e(6877),Fr=e(632),Yr=e(5130),Kn=e(4917),es=e(4077);function ys(ge,he,{indexing:ce="xy"}={}){if("xy"!==ce&&"ij"!==ce)throw new TypeError(`${ce} is not a valid third argument to meshgrid`);if(void 0===ge)return[];let ye=(0,J._1)(ge,"x","meshgrid",ge instanceof es.es?ge.dtype:"float32");if(void 0===he)return[ye];let Ne=(0,J._1)(he,"y","meshgrid",he instanceof es.es?he.dtype:"float32");const Se=(0,te.NA)(ye.shape),Ae=(0,te.NA)(Ne.shape);return"xy"===ce?(ye=(0,ke.X)(ye,[1,-1]),Ne=(0,ke.X)(Ne,[-1,1]),[(0,ue.O)((0,Kn.i)([Ae,1],ye.dtype),ye),(0,ue.O)(Ne,(0,Kn.i)([1,Se],Ne.dtype))]):(ye=(0,ke.X)(ye,[-1,1]),Ne=(0,ke.X)(Ne,[1,-1]),[(0,ue.O)(ye,(0,Kn.i)([1,Ae],ye.dtype)),(0,ue.O)((0,Kn.i)([Se,1],Ne.dtype),Ne)])}var lr=e(5735),ts=e(4513),bs=e(1483),ks=e(5228),Or=e(248);const ns=(0,F.op)({moments_:function(ge,he=null,ce=false){ge=(0,J._1)(ge,"x","moments");const ye=(0,te.EC)(he,ge.shape),Ne=(0,Yr.J)(ge,ye,ce);let Se=Ne.shape;ce||(Se=(0,gr.rv)(Ne.shape,ye));const Ae=(0,Or.h)((0,sn.l)((0,tt.p)(ge,"float32"),(0,ke.X)(Ne,Se)));return{mean:Ne,variance:(0,Yr.J)(Ae,ye,ce)}}});const Ws=(0,F.op)({multiRNNCell_:function(ge,he,ce,ye){const Ne=(0,J._1)(he,"data","multiRNNCell"),Se=(0,J.sI)(ce,"c","multiRNNCell"),Ae=(0,J.sI)(ye,"h","multiRNNCell");let Pe=Ne;const et=[];for(let Tt=0;Tt<ge.length;Tt++){const Vt=ge[Tt](Pe,Se[Tt],Ae[Tt]);et.push(Vt[0]),et.push(Vt[1]),Pe=Vt[1]}const je=[],ft=[];for(let Tt=0;Tt<et.length;Tt+=2)je.push(et[Tt]),ft.push(et[Tt+1]);return[je,ft]}});var ws=e(686),Us=e(6500),Un=e(6708),vs=e(7846);const Br=(0,F.op)({outerProduct_:function(ge,he){const ce=(0,J._1)(ge,"v1","outerProduct"),ye=(0,J._1)(he,"v2","outerProduct");te.hu(1===ce.rank&&1===ye.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${ce.rank} and ${ye.rank}.`);const Ne=(0,ke.X)(ce,[-1,1]),Se=(0,ke.X)(ye,[1,-1]);return(0,ue.O)(Ne,Se)}});var nr=e(9682);const cr=(0,F.op)({pad1d_:function(ge,he,ce=0){return(0,te.hu)(2===he.length,()=>"Invalid number of paddings. Must be length of 2."),(0,nr.v)(ge,[he],ce)}});const Fn=(0,F.op)({pad2d_:function(ge,he,ce=0){return(0,te.hu)(2===he.length&&2===he[0].length&&2===he[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,nr.v)(ge,he,ce)}});const ua=(0,F.op)({pad3d_:function(ge,he,ce=0){return(0,te.hu)(3===he.length&&2===he[0].length&&2===he[1].length&&2===he[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,nr.v)(ge,he,ce)}});const Tr=(0,F.op)({pad4d_:function(ge,he,ce=0){return(0,te.hu)(4===he.length&&2===he[0].length&&2===he[1].length&&2===he[2].length&&2===he[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,nr.v)(ge,he,ce)}});var cn=e(2582),rs=e(7918);const ss=(0,F.op)({pool_:function(ge,he,ce,ye,Ne,Se){null==Ne&&(Ne=[1,1]),null==Se&&(Se=1),0===ye&&(ye="valid");const Ae=(0,J._1)(ge,"x","maxPool");let Pe=Ae,et=false;3===Ae.rank&&(et=true,Pe=(0,ke.X)(Ae,[1,Ae.shape[0],Ae.shape[1],Ae.shape[2]])),te.hu(cn.jT(Se,Ne),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${Se} and dilations '${Ne}'`);const je=cn.Xw(Pe.shape,he,Se,Ne,ye),ft=[je.dilationHeight,je.dilationWidth];let Tt;Tt="same"===ye?function(Cr,zn){const Wn=Cr.map((Hn,sr)=>Hn+(Hn-1)*(zn[sr]-1)).map(Hn=>Hn-1),qn=Wn.map(Hn=>Math.floor(Hn/2)),xr=Wn.map((Hn,sr)=>Hn-qn[sr]);return Wn.map((Hn,sr)=>[qn[sr],xr[sr]])}([je.filterHeight,je.filterWidth],ft):[[0,0],[0,0]];const Vt=1===ft[0]&&1===ft[1],[bn,dn]=function(Cr,zn,Wn){const qn=Wn.map(_r=>_r[0]),xr=Wn.map(_r=>_r[1]),Hn=Cr.concat(qn,xr),sr=zn.map((_r,ls)=>(_r-Hn[ls]%_r)%_r),mo=xr.map((_r,ls)=>_r+sr[ls]),go=zn.map((_r,ls)=>[qn[ls],mo[ls]]),yo=zn.map((_r,ls)=>[0,sr[ls]]);return[go,yo]}([je.inHeight,je.inWidth],ft,Tt),Qt=Vt?ye:"valid",Rn=Vt?Pe:(0,rs.f)(Pe,ft,bn),Zn=("avg"===ce?()=>(0,K.w)(Rn,he,Se,Qt):()=>(0,Vs._)(Rn,he,Se,Qt))(),Vn=Vt?Zn:(0,se.E)(Zn,ft,dn);return et?(0,ke.X)(Vn,[Vn.shape[1],Vn.shape[2],Vn.shape[3]]):Vn}});var Lr=e(3453),la=e(8151),ca=e(9798),da=e(9451);const Ns=(0,F.op)({rand_:function(ge,he,ce){const ye=(0,te.NA)(ge);let Ne=null;if(null==ce||"float32"===ce)Ne=new Float32Array(ye);else if("int32"===ce)Ne=new Int32Array(ye);else{if("bool"!==ce)throw new Error(`Unknown data type ${ce}`);Ne=new Uint8Array(ye)}for(let Se=0;Se<ye;Se++)Ne[Se]=he();return Y.BV.makeTensor(Ne,ge,ce)}});var qs=e(6845);const ha=(0,F.op)({randomGamma_:function(ge,he,ce=1,ye="float32",Ne){if(null==ce&&(ce=1),null==ye&&(ye="float32"),"float32"!==ye&&"int32"!==ye)throw new Error(`Unsupported data type ${ye}`);const Se=new qs.T9(he,ce,ye,Ne),Ae=(0,Qe.f)(ge,ye);for(let Pe=0;Pe<Ae.values.length;Pe++)Ae.values[Pe]=Se.nextValue();return Ae.toTensor()}});const Hs=(0,F.op)({randomNormal_:function(ge,he=0,ce=1,ye,Ne){if(null!=ye&&"bool"===ye)throw new Error(`Unsupported data type ${ye}`);const Se=new qs.Yi(he,ce,ye,false,Ne),Ae=(0,Qe.f)(ge,ye);for(let Pe=0;Pe<Ae.values.length;Pe++)Ae.values[Pe]=Se.nextValue();return Ae.toTensor()}});var xs=e(5002),Bt=e(7245),on=e(766),Yn=e(9036),Zt=e(7409),Ir=e(3582),Xn=e(7486);const er=(0,F.op)({reverse1d_:function(ge){const he=(0,J._1)(ge,"x","reverse");return te.hu(1===he.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${he.rank}.`),(0,Xn.G)(he,0)}});const br=(0,F.op)({reverse2d_:function(ge,he){const ce=(0,J._1)(ge,"x","reverse");return te.hu(2===ce.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${ce.rank}.`),(0,Xn.G)(ce,he)}});const kr=(0,F.op)({reverse3d_:function(ge,he){const ce=(0,J._1)(ge,"x","reverse");return te.hu(3===ce.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${ce.rank}.`),(0,Xn.G)(ce,he)}});const dr=(0,F.op)({reverse4d_:function(ge,he){const ce=(0,J._1)(ge,"x","reverse");return te.hu(4===ce.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${ce.rank}.`),(0,Xn.G)(ce,he)}});var Pr=e(7809),Ln=e(2634),un=e(9494),as=e(5503);const wr=(0,F.op)({separableConv2d_:function(ge,he,ce,ye,Ne,Se=[1,1],Ae="NHWC"){const Pe=(0,J._1)(ge,"x","separableConv2d"),et=(0,J._1)(he,"depthwiseFilter","separableConv2d"),je=(0,J._1)(ce,"pointwiseFilter","separableConv2d");let ft=Pe,Tt=false;if(3===Pe.rank&&(Tt=true,ft=(0,ke.X)(Pe,[1,Pe.shape[0],Pe.shape[1],Pe.shape[2]])),"NCHW"===Ae)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");te.hu(4===ft.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${ft.rank}.`),te.hu(4===et.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${et.rank}.`),te.hu(4===je.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${et.rank}.`),te.hu(1===je.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${je.shape[0]}.`),te.hu(1===je.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${je.shape[1]}.`);const Vt=et.shape[2],bn=et.shape[3];te.hu(je.shape[2]===Vt*bn,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${Vt*bn}, but got ${je.shape[2]}.`);const dn=(0,an.B)(ft,et,ye,Ne,Ae,Se),Qt=(0,Wt.T)(dn,je,1,"valid",Ae);return Tt?(0,ke.X)(Qt,[Qt.shape[1],Qt.shape[2],Qt.shape[3]]):Qt}});var vr=e(6567),pa=e(4434),js=e(9331),Rr=e(3254);const hr=(0,F.op)({slice1d_:function(ge,he,ce){const ye=(0,J._1)(ge,"x","slice1d");return te.hu(1===ye.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${ye.rank} tensor`),(0,f.t)(ye,[he],[ce])}});const os=(0,F.op)({slice2d_:function(ge,he,ce){const ye=(0,J._1)(ge,"x","slice2d");return te.hu(2===ye.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${ye.rank} tensor`),(0,f.t)(ye,he,ce)}});const is=(0,F.op)({slice3d_:function(ge,he,ce){const ye=(0,J._1)(ge,"x","slice3d");return te.hu(3===ye.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${ye.rank} tensor`),(0,f.t)(ye,he,ce)}});const us=(0,F.op)({slice4d_:function(ge,he,ce){const ye=(0,J._1)(ge,"x","slice4d");return te.hu(4===ye.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${ye.rank} tensor`),(0,f.t)(ye,he,ce)}});var Ie=e(682),Gs=e(7020),Er=e(8447),Ca=e(4415),Ar=e(3710),fa=e(8644),Pn=e(3261),Ks=e(5265),Xs=e(9590),_s=e(2991),Nr=e(1901),Zs=e(5158),ma=e(1173),ga=e(701),rr=e(6092),Ss=e(7852);function Ts(ge,he,ce){if((0,te.Cq)(ge),null!=he&&2!==he.length)throw new Error("tensor2d() requires shape to have two numbers");const ye=(0,J.C)(ge,ce);if(2!==ye.length&&1!==ye.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===ye.length&&null==he)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return(0,Ss.H)(ge,he,ye,ce)}var Wa=e(9906);function Ua(ge,he,ce){if((0,te.Cq)(ge),null!=he&&4!==he.length)throw new Error("tensor4d() requires shape to have four numbers");const ye=(0,J.C)(ge,ce);if(4!==ye.length&&1!==ye.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===ye.length&&null==he)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return(0,Ss.H)(ge,he,ye,ce)}function qa(ge,he,ce){if((0,te.Cq)(ge),null!=he&&5!==he.length)throw new Error("tensor5d() requires shape to have five numbers");const ye=(0,J.C)(ge,ce);if(5!==ye.length&&1!==ye.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===ye.length&&null==he)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return(0,Ss.H)(ge,he,ye,ce)}function Ha(ge,he,ce){if((0,te.Cq)(ge),null!=he&&6!==he.length)throw new Error("tensor6d() requires shape to have six numbers");const ye=(0,J.C)(ge,ce);if(6!==ye.length&&1!==ye.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===ye.length&&null==he)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return he=he||ye,(0,Ss.H)(ge,he,ye,ce)}var ja=e(3243),Ga=e(3596),$a=e(9608);const Ka=(0,F.op)({unsortedSegmentSum_:function(ge,he,ce){const ye=(0,J._1)(ge,"x","unsortedSegmentSum"),Ne=(0,J._1)(he,"segmentIds","unsortedSegmentSum","int32");(0,te.hu)((0,te.GN)(ce),()=>"numSegments must be of dtype int");const Se={x:ye,segmentIds:Ne},Ae={numSegments:ce};return Y.BV.runKernel(be.Qv,Se,Ae)}});var ya=e(4136);function Xa(ge,he=true,ce,ye){return Y.BV.makeVariable(ge,he,ce,ye)}var Is=e(5912),Qs=e(6380),ba=e(9640),Za=e(6577);const Es=async function(ge,he,ce){const ye=(0,J._1)(ge,"tensor","boolMask"),Ne=(0,J._1)(he,"mask","boolMask","bool"),Se=null==ce?0:ce,Ae=Ne.rank,Pe=ye.shape;te.hu(Ae>0,()=>"mask cannot be scalar"),te.k5(Pe.slice(Se,Se+Ae),Ne.shape,"mask's shape must match the first K dimensions of tensor's shape,");let et=1;for(let Qt=Se;Qt<Se+Ae;Qt++)et*=Pe[Qt];const je=Pe.slice(0,Se).concat([et],Pe.slice(Se+Ae)),ft=(0,ke.X)(ye,je),Tt=(0,ke.X)(Ne,[-1]),Vt=await(0,Qs.i)(Tt),bn=(0,Xs.L)(Vt,[1]),dn=(0,ur.I)(ft,bn,Se);return ge!==ye&&ye.dispose(),he!==Ne&&Ne.dispose(),bn.dispose(),ft.dispose(),Tt.dispose(),Vt.dispose(),dn};var As=e(9065);function ka(ge,he,ce=null){if(0===ge.rank)return(0,g.W)(ge);if(1!==ge.rank&&null===ce)return ka((0,ke.X)(ge,[-1]),he,ce);if(1===ge.rank||"number"==typeof ce||Array.isArray(ce)&&1===ce.length){if(1===he)return(0,Ce.S)((0,g.W)(ge),ce);if(he===1/0)return(0,Dr.F)((0,g.W)(ge),ce);if(he===-1/0)return(0,lr.V)((0,g.W)(ge),ce);if("euclidean"===he||2===he)return(0,Pn._)((0,Ce.S)((0,Lr.s)((0,g.W)(ge),(0,un.i)(2,"int32")),ce));throw new Error(`Error in norm: invalid ord value: ${he}`)}if(Array.isArray(ce)&&2===ce.length){if(1===he)return(0,Dr.F)((0,Ce.S)((0,g.W)(ge),ce[0]),ce[1]-1);if(he===1/0)return(0,Dr.F)((0,Ce.S)((0,g.W)(ge),ce[1]),ce[0]);if(he===-1/0)return(0,lr.V)((0,Ce.S)((0,g.W)(ge),ce[1]),ce[0]);if("fro"===he||"euclidean"===he)return(0,Pn._)((0,Ce.S)((0,Or.h)(ge),ce));throw new Error(`Error in norm: invalid ord value: ${he}`)}throw new Error(`Error in norm: invalid axis: ${ce}`)}const wa=(0,F.op)({norm_:function(ge,he="euclidean",ce=null,ye=false){const Ne=ka(ge=(0,J._1)(ge,"x","norm"),he,ce);let Se=Ne.shape;if(ye){const Ae=(0,te.EC)(ce,ge.shape);Se=gr.rv(Ne.shape,Ae)}return(0,ke.X)(Ne,Se)}});var Qa=e(747);const Ja=(0,F.op)({movingAverage_:function(ge,he,ce,ye,Ne=true){const Se=(0,J._1)(ge,"v","movingAverage"),Ae=(0,J._1)(he,"x","movingAverage"),Pe=(0,J._1)(ce,"decay","movingAverage");(0,Qa.assertTypesMatch)(Se,Ae),te.hu(te.cO(Se.shape,Ae.shape),()=>"Shape mismatch in v and x");const et=(0,un.i)(1),je=(0,sn.l)(et,Pe);let ft=(0,ie.d)((0,sn.l)(Ae,Se),je);if(Ne){te.hu(null!=ye,()=>"When using zeroDebias: true, step is required.");const Tt=(0,J._1)(ye,"step","movingAverage");ft=(0,Xt.h)(ft,(0,sn.l)(et,(0,Lr.s)(Pe,Tt)))}return(0,i.I)(Se,ft)}});var Da=e(3100),Ya=e(9758),eo=e(7494);const to=(0,F.op)({dropout_:function(ge,he,ce,ye){const Ne=(0,J._1)(ge,"x","dropout");if(te.hu("float32"===Ne.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${Ne.dtype} tensor instead.`),te.hu(he>=0&&he<1,()=>`rate must be a float in the range [0, 1), but got ${he}.`),0===he)return ge instanceof es.es?Ne.clone():Ne;const Se=function(et,je){if(null==je)return et.shape.slice();if(te.cO(et.shape,je))return je;if(et.shape.length===je.length){const ft=[];for(let Tt=0;Tt<et.shape.length;Tt++)null==je[Tt]&&null!=et.shape[Tt]?ft.push(et.shape[Tt]):ft.push(je[Tt]);return ft}return je}(Ne,ce),Ae=1-he,Pe=(0,Xt.h)((0,Ds.G)((0,i.I)((0,xs.L)(Se,0,1,"float32",ye),Ae)),Ae);return(0,ie.d)(Ne,Pe)}});function Fa(ge){return Math.floor(Math.pow(2,Math.ceil(Math.log(ge)/Math.log(2))))}function va(ge,he,ce){const ye=1-ge%2,Ne=new Float32Array(ge);for(let Se=0;Se<ge;++Se){const Ae=2*Math.PI*Se/(ge+ye-1);Ne[Se]=he-ce*Math.cos(Ae)}return(0,rr.R)(Ne,"float32")}const Js=async function(ge,he,ce=1){const ye=(0,J._1)(ge,"predictions","inTopK"),Ne=(0,J._1)(he,"targets","inTopK");(0,te.hu)(ye.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${ye.rank}`),(0,te.hu)(ye.rank-1===Ne.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${ye.rank} and targets rank ${Ne.rank}`),(0,te.k5)(ye.shape.slice(0,ye.shape.length-1),Ne.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const Se=ye.shape[ye.shape.length-1];(0,te.hu)(ce>0&&ce<=Se,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${Se}), but got ${ce}`);const Ae=await ye.data(),Pe=await Ne.data(),[et,je]=[Ae.length/Se,Se],ft=(0,te.WP)("bool",et);for(let Tt=0;Tt<et;Tt++){const Vt=Tt*je,bn=Ae.subarray(Vt,Vt+je),dn=[];for(let Qt=0;Qt<bn.length;Qt++)dn.push({value:bn[Qt],index:Qt});dn.sort((Qt,Rn)=>Rn.value-Qt.value),ft[Tt]=0;for(let Qt=0;Qt<ce;Qt++)if(dn[Qt].index===Pe[Tt]){ft[Tt]=1;break}}return ge!==ye&&ye.dispose(),he!==Ne&&Ne.dispose(),(0,ga.X)(ft,Ne.shape,"bool")};var no=e(2277);const ro=(0,F.op)({hammingWindow_:function(ge){return va(ge,.54,.46)}});const Ys=(0,F.op)({hannWindow_:function(ge){return va(ge,.5,.5)}});const ea=(0,F.op)({frame_:function(ge,he,ce,ye=false,Ne=0){let Se=0;const Ae=[];for(;Se+he<=ge.size;)Ae.push((0,f.t)(ge,Se,he)),Se+=ce;if(ye)for(;Se<ge.size;){const Pe=Se+he-ge.size,et=(0,ve.z)([(0,f.t)(ge,Se,he-Pe),(0,ir.h)([Pe],Ne)]);Ae.push(et),Se+=ce}return 0===Ae.length?Ts([],[0,he]):(0,ke.X)((0,ve.z)(Ae),[Ae.length,he])}});const Oa=(0,F.op)({stft_:function(ge,he,ce,ye,Ne=Ys){null==ye&&(ye=Fa(he));const Se=ea(ge,he,ce),Ae=(0,ie.d)(Se,Ne(he));return(0,Ar.Q)(Ae,ye)}});const so=(0,F.op)({cropAndResize_:function(ge,he,ce,ye,Ne="bilinear",Se=0){const Ae=(0,J._1)(ge,"image","cropAndResize"),Pe=(0,J._1)(he,"boxes","cropAndResize","float32"),et=(0,J._1)(ce,"boxInd","cropAndResize","int32"),je=Pe.shape[0];te.hu(4===Ae.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${Ae.rank}.`),te.hu(2===Pe.rank&&4===Pe.shape[1],()=>`Error in cropAndResize: boxes must be have size [${je},4] but had shape ${Pe.shape}.`),te.hu(1===et.rank&&et.shape[0]===je,()=>`Error in cropAndResize: boxInd must be have size [${je}] but had shape ${Pe.shape}.`),te.hu(2===ye.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${ye.length}.`),te.hu(ye[0]>=1&&ye[1]>=1,()=>`cropSize must be atleast [1,1], but was ${ye}`),te.hu("bilinear"===Ne||"nearest"===Ne,()=>`method must be bilinear or nearest, but was ${Ne}`);const ft={image:Ae,boxes:Pe,boxInd:et},Tt={method:Ne,extrapolationValue:Se,cropSize:ye};return Y.BV.runKernel(be.Vc,ft,Tt)}});const Na=(0,F.op)({flipLeftRight_:function(ge){const he=(0,J._1)(ge,"image","flipLeftRight","float32");te.hu(4===he.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${he.rank}.`);const ce={image:he};return Y.BV.runKernel(be.Uy,ce,{})}});const xa=(0,F.op)({grayscaleToRGB_:function(ge){const he=(0,J._1)(ge,"image","grayscaleToRGB"),ce=he.rank-1,ye=he.shape[ce];te.hu(he.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${he.rank}.`),te.hu(1===ye,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${ye}.`);const Ne=new Array(he.rank);return Ne.fill(1,0,ce),Ne[ce]=3,(0,Jn.G)(he,Ne)}});const ta=(0,F.op)({rotateWithOffset_:function(ge,he,ce=0,ye=.5){const Ne=(0,J._1)(ge,"image","rotateWithOffset","float32");te.hu(4===Ne.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${Ne.rank}.`);const Se={image:Ne},Ae={radians:he,fillValue:ce,center:ye};return Y.BV.runKernel(be.b9,Se,Ae)}});function Mr(ge,he,ce,ye,Ne,Se){null==ye&&(ye=.5),null==Ne&&(Ne=Number.NEGATIVE_INFINITY),null==Se&&(Se=0);const Ae=ge.shape[0];return ce=Math.min(ce,Ae),te.hu(0<=ye&&ye<=1,()=>`iouThreshold must be in [0, 1], but was '${ye}'`),te.hu(2===ge.rank,()=>`boxes must be a 2D tensor, but was of rank '${ge.rank}'`),te.hu(4===ge.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${ge.shape[1]}`),te.hu(1===he.rank,()=>"scores must be a 1D tensor"),te.hu(he.shape[0]===Ae,()=>`scores has incompatible shape with boxes. Expected ${Ae}, but was ${he.shape[0]}`),te.hu(0<=Se&&Se<=1,()=>`softNmsSigma must be in [0, 1], but was '${Se}'`),{maxOutputSize:ce,iouThreshold:ye,scoreThreshold:Ne,softNmsSigma:Se}}const B=(0,F.op)({nonMaxSuppression_:function(ge,he,ce,ye=.5,Ne=Number.NEGATIVE_INFINITY){const Se=(0,J._1)(ge,"boxes","nonMaxSuppression"),Ae=(0,J._1)(he,"scores","nonMaxSuppression"),Pe=Mr(Se,Ae,ce,ye,Ne),et={maxOutputSize:ce=Pe.maxOutputSize,iouThreshold:ye=Pe.iouThreshold,scoreThreshold:Ne=Pe.scoreThreshold};return Y.BV.runKernel(be.uv,{boxes:Se,scores:Ae},et)}});var d=e(3337);const D=async function(ge,he,ce,ye=.5,Ne=Number.NEGATIVE_INFINITY){const Se=(0,J._1)(ge,"boxes","nonMaxSuppressionAsync"),Ae=(0,J._1)(he,"scores","nonMaxSuppressionAsync"),Pe=Mr(Se,Ae,ce,ye,Ne);ce=Pe.maxOutputSize,ye=Pe.iouThreshold,Ne=Pe.scoreThreshold;const et=await Promise.all([Se.data(),Ae.data()]),je=et[0],ft=et[1],{selectedIndices:Tt}=(0,d.GP)(je,ft,ce,ye,Ne);return Se!==ge&&Se.dispose(),Ae!==he&&Ae.dispose(),(0,rr.R)(Tt,"int32")};const H=(0,F.op)({nonMaxSuppressionWithScore_:function(ge,he,ce,ye=.5,Ne=Number.NEGATIVE_INFINITY,Se=0){const Ae=(0,J._1)(ge,"boxes","nonMaxSuppression"),Pe=(0,J._1)(he,"scores","nonMaxSuppression"),et=Mr(Ae,Pe,ce,ye,Ne,Se),je={boxes:Ae,scores:Pe},ft={maxOutputSize:ce=et.maxOutputSize,iouThreshold:ye=et.iouThreshold,scoreThreshold:Ne=et.scoreThreshold,softNmsSigma:Se=et.softNmsSigma},Tt=Y.BV.runKernel(be.W0,je,ft);return{selectedIndices:Tt[0],selectedScores:Tt[1]}}});const j=async function(ge,he,ce,ye=.5,Ne=Number.NEGATIVE_INFINITY,Se=0){const Ae=(0,J._1)(ge,"boxes","nonMaxSuppressionAsync"),Pe=(0,J._1)(he,"scores","nonMaxSuppressionAsync"),et=Mr(Ae,Pe,ce,ye,Ne,Se);ce=et.maxOutputSize,ye=et.iouThreshold,Ne=et.scoreThreshold,Se=et.softNmsSigma;const je=await Promise.all([Ae.data(),Pe.data()]),ft=je[0],Tt=je[1],{selectedIndices:Vt,selectedScores:bn}=(0,d.pA)(ft,Tt,ce,ye,Ne,Se);return Ae!==ge&&Ae.dispose(),Pe!==he&&Pe.dispose(),{selectedIndices:(0,rr.R)(Vt,"int32"),selectedScores:(0,rr.R)(bn)}};const de=(0,F.op)({nonMaxSuppressionPadded_:function(ge,he,ce,ye=.5,Ne=Number.NEGATIVE_INFINITY,Se=false){const Ae=(0,J._1)(ge,"boxes","nonMaxSuppression"),Pe=(0,J._1)(he,"scores","nonMaxSuppression"),et=Mr(Ae,Pe,ce,ye,Ne,null),je={boxes:Ae,scores:Pe},ft={maxOutputSize:et.maxOutputSize,iouThreshold:et.iouThreshold,scoreThreshold:et.scoreThreshold,padToMaxOutputSize:Se},Tt=Y.BV.runKernel(be.cy,je,ft);return{selectedIndices:Tt[0],validOutputs:Tt[1]}}});const xe=async function(ge,he,ce,ye=.5,Ne=Number.NEGATIVE_INFINITY,Se=false){const Ae=(0,J._1)(ge,"boxes","nonMaxSuppressionAsync"),Pe=(0,J._1)(he,"scores","nonMaxSuppressionAsync"),et=Mr(Ae,Pe,ce,ye,Ne,null),je=et.maxOutputSize,ft=et.iouThreshold,Tt=et.scoreThreshold,[Vt,bn]=await Promise.all([Ae.data(),Pe.data()]),{selectedIndices:dn,validOutputs:Qt}=(0,d.qP)(Vt,bn,je,ft,Tt,Se);return Ae!==ge&&Ae.dispose(),Pe!==he&&Pe.dispose(),{selectedIndices:(0,rr.R)(dn,"int32"),validOutputs:(0,un.i)(Qt,"int32")}};const Te=(0,F.op)({resizeBilinear_:function(ge,he,ce=false,ye=false){const Ne=(0,J._1)(ge,"images","resizeBilinear");te.hu(3===Ne.rank||4===Ne.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${Ne.rank}.`),te.hu(2===he.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${he}.`),te.hu(false===ye||false===ce,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let Se=Ne,Ae=false;3===Ne.rank&&(Ae=true,Se=(0,ke.X)(Ne,[1,Ne.shape[0],Ne.shape[1],Ne.shape[2]]));const Pe={images:Se},et={alignCorners:ce,halfPixelCenters:ye,size:he},je=Y.BV.runKernel(be._Y,Pe,et);return Ae?(0,ke.X)(je,[je.shape[1],je.shape[2],je.shape[3]]):je}});const Je=(0,F.op)({resizeNearestNeighbor_:function(ge,he,ce=false,ye=false){const Ne=(0,J._1)(ge,"images","resizeNearestNeighbor");te.hu(3===Ne.rank||4===Ne.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${Ne.rank}.`),te.hu(2===he.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${he}.`),te.hu("float32"===Ne.dtype||"int32"===Ne.dtype,()=>"`images` must have `int32` or `float32` as dtype"),te.hu(false===ye||false===ce,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let Se=Ne,Ae=false;3===Ne.rank&&(Ae=true,Se=(0,ke.X)(Ne,[1,Ne.shape[0],Ne.shape[1],Ne.shape[2]]));const Pe={images:Se},et={alignCorners:ce,halfPixelCenters:ye,size:he},je=Y.BV.runKernel(be.dp,Pe,et);return Ae?(0,ke.X)(je,[je.shape[1],je.shape[2],je.shape[3]]):je}});const it=(0,F.op)({threshold_:function(ge,he="binary",ce=false,ye=.5){const Ne=(0,J._1)(ge,"image","threshold"),Se=Ne.shape[0]*Ne.shape[1];let Ae,Pe,et,je,ft=(0,ie.d)((0,rr.R)([ye]),255);if(te.hu(3===Ne.rank,()=>`Error in threshold: image must be rank 3,but got rank ${Ne.rank}.`),te.hu(3===Ne.shape[2]||1===Ne.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${Ne.shape[2]}.`),te.hu("int32"===Ne.dtype||"float32"===Ne.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${Ne.dtype}.`),te.hu("otsu"===he||"binary"===he,()=>`Method must be binary or otsu, but was ${he}`),3===Ne.shape[2]){[Ae,Pe,et]=(0,fa.V)(Ne,[1,1,1],-1);const Vt=(0,ie.d)(Ae,.2989),bn=(0,ie.d)(Pe,.587),dn=(0,ie.d)(et,.114);je=(0,i.I)((0,i.I)(Vt,bn),dn)}else je=ge;if("otsu"===he){ft=function(Vt,bn){let dn,Qt,Rn,Zn,Vn,Cr,zn=(0,rr.R)([-1]),Wn=(0,rr.R)([0]),qn=(0,rr.R)([0]);for(let xr=0;xr<Vt.size-1;xr++){dn=(0,f.t)(Vt,0,xr+1),Qt=(0,f.t)(Vt,xr+1),Vn=(0,Xt.h)((0,Ce.S)(dn),bn),Cr=(0,Xt.h)((0,Ce.S)(Qt),bn);const Hn=(0,Ce.S)((0,ie.d)(dn,(0,Bt.w)(0,dn.size)));Rn=(0,Xt.h)(Hn,(0,Ce.S)(dn));const sr=(0,ir.h)(Qt.shape,dn.size),mo=(0,i.I)((0,Bt.w)(0,Qt.size),sr),go=(0,ie.d)(Qt,mo);Zn=(0,Xt.h)((0,Ce.S)(go),(0,Ce.S)(Qt));const yo=(0,sn.l)(Rn,Zn),_r=(0,sn.l)(Rn,Zn),ls=(0,ie.d)(Vn,Cr);qn=(0,ie.d)((0,ie.d)(ls,yo),_r);const _o=(0,jr.p)(qn,Wn);Wn=(0,Is.a)(_o,qn,Wn),zn=(0,Is.a)(_o,(0,rr.R)([xr]),zn)}return zn}((0,Ke.y)((0,tt.p)((0,Pr.N)(je),"int32"),(0,ga.X)([]),256),Se)}const Tt=ce?(0,Zr.z)(je,ft):(0,jr.p)(je,ft);return(0,tt.p)((0,ie.d)(Tt,255),"int32")}});const ut=(0,F.op)({transform_:function(ge,he,ce="nearest",ye="constant",Ne=0,Se){const Ae=(0,J._1)(ge,"image","transform","float32"),Pe=(0,J._1)(he,"transforms","transform","float32");te.hu(4===Ae.rank,()=>`Error in transform: image must be rank 4,but got rank ${Ae.rank}.`),te.hu(2===Pe.rank&&(Pe.shape[0]===Ae.shape[0]||1===Pe.shape[0])&&8===Pe.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),te.hu(null==Se||2===Se.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${Se}.`);const et={image:Ae,transforms:Pe},je={interpolation:ce,fillMode:ye,fillValue:Ne,outputShape:Se};return Y.BV.runKernel(be.wx,et,je)}});const Ue=(0,F.op)({bandPart_:function(ge,he,ce){(0,te.hu)(he%1==0,()=>`bandPart(): numLower must be an integer, got ${he}.`),(0,te.hu)(ce%1==0,()=>`bandPart(): numUpper must be an integer, got ${ce}.`);const ye=(0,J._1)(ge,"a","bandPart");(0,te.hu)(ye.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${ye.rank}.`);const Ne=ye.shape,[Se,Ae]=ye.shape.slice(-2);if(!(he<=Se))throw new Error(`bandPart(): numLower (${he}) must not be greater than the number of rows (${Se}).`);if(!(ce<=Ae))throw new Error(`bandPart(): numUpper (${ce}) must not be greater than the number of columns (${Ae}).`);he<0&&(he=Se),ce<0&&(ce=Ae);const Pe=(0,ke.X)((0,Bt.w)(0,Se,1,"int32"),[-1,1]),et=(0,Bt.w)(0,Ae,1,"int32"),je=(0,sn.l)(Pe,et),ft=(0,Qr.H)((0,Zr.z)(je,(0,un.i)(+he,"int32")),(0,Gr.b)(je,(0,un.i)(-ce,"int32"))),Tt=(0,ba.l)([Se,Ae],ye.dtype);return(0,ke.X)((0,_s.k)((0,ya.H)((0,ke.X)(ye,[-1,Se,Ae])).map(Vt=>(0,Is.a)(ft,Vt,Tt))),Ne)}});const ee=(0,F.op)({gramSchmidt_:function(ge){let he;if(Array.isArray(ge)){he=false,(0,te.hu)(null!=ge&&ge.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const Ne=ge[0].shape[0];for(let Se=1;Se<ge.length;++Se)(0,te.hu)(ge[Se].shape[0]===Ne,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${ge[Se].shape[0]} vs. ${Ne})`)}else he=true,ge=(0,fa.V)(ge,ge.shape[0],0).map(Ne=>(0,Xs.L)(Ne,[0]));(0,te.hu)(ge.length<=ge[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${ge.length}) exceeds number of dimensions (${ge[0].shape[0]}).`);const ce=[],ye=ge;for(let Ne=0;Ne<ge.length;++Ne)ce.push(Y.BV.tidy(()=>{let Se=ye[Ne];if(Ne>0)for(let Ae=0;Ae<Ne;++Ae){const Pe=(0,ie.d)((0,Ce.S)((0,ie.d)(ce[Ae],Se)),ce[Ae]);Se=(0,sn.l)(Se,Pe)}return(0,Xt.h)(Se,wa(Se,"euclidean"))}));return he?(0,_s.k)(ce,0):ce}});var l=e(4368);function M(ge,he=false){return Y.BV.tidy(()=>{(0,te.hu)(2===ge.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${ge.shape.length}D Tensor.`);const ce=ge.shape[0],ye=ge.shape[1];let Ne=Hr(ce),Se=(0,Ct.d)(ge);const Ae=Ts([[1]],[1,1]);let Pe=(0,Ct.d)(Ae);const et=ce>=ye?ye:ce;for(let je=0;je<et;++je){const ft=Se,Tt=Pe,Vt=Ne;[Pe,Se,Ne]=Y.BV.tidy(()=>{const bn=(0,f.t)(Se,[je,je],[ce-je,1]),dn=wa(bn),Qt=(0,f.t)(Se,[je,je],[1,1]),Rn=(0,Is.a)((0,jr.p)(Qt,0),Ts([[-1]]),Ts([[1]])),Zn=(0,sn.l)(Qt,(0,ie.d)(Rn,dn)),Vn=(0,Xt.h)(bn,Zn);Pe=1===Vn.shape[0]?(0,Ct.d)(Ae):(0,ve.z)([Ae,(0,f.t)(Vn,[1,0],[Vn.shape[0]-1,Vn.shape[1]])],0);const Cr=(0,Dn.W)((0,Xt.h)((0,ue.O)(Rn,Zn),dn)),zn=(0,f.t)(Se,[je,0],[ce-je,ye]),Wn=(0,ie.d)(Cr,Pe),qn=(0,As.p)(Pe);if(0===je)Se=(0,sn.l)(zn,(0,ue.O)(Wn,(0,ue.O)(qn,zn)));else{const sr=(0,sn.l)(zn,(0,ue.O)(Wn,(0,ue.O)(qn,zn)));Se=(0,ve.z)([(0,f.t)(Se,[0,0],[je,ye]),sr],0)}const xr=(0,As.p)(Wn),Hn=(0,f.t)(Ne,[0,je],[ce,Ne.shape[1]-je]);if(0===je)Ne=(0,sn.l)(Hn,(0,ue.O)((0,ue.O)(Hn,Pe),xr));else{const sr=(0,sn.l)(Hn,(0,ue.O)((0,ue.O)(Hn,Pe),xr));Ne=(0,ve.z)([(0,f.t)(Ne,[0,0],[ce,je]),sr],1)}return[Pe,Se,Ne]}),(0,l.B9)([ft,Tt,Vt])}return!he&&ce>ye&&(Ne=(0,f.t)(Ne,[0,0],[ce,ye]),Se=(0,f.t)(Se,[0,0],[ye,ye])),[Ne,Se]})}const X=(0,F.op)({qr_:function(ge,he=false){if((0,te.hu)(ge.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${ge.rank}`),2===ge.rank)return M(ge,he);{const ce=ge.shape.slice(0,ge.shape.length-2).reduce((Ae,Pe)=>Ae*Pe),ye=(0,ya.H)((0,ke.X)(ge,[ce,ge.shape[ge.shape.length-2],ge.shape[ge.shape.length-1]]),0),Ne=[],Se=[];ye.forEach(Ae=>{const[Pe,et]=M(Ae,he);Ne.push(Pe),Se.push(et)});return[(0,ke.X)((0,_s.k)(Ne,0),ge.shape),(0,ke.X)((0,_s.k)(Se,0),ge.shape)]}}});var we=e(9876);const me=(0,F.op)({computeWeightedLoss_:function(ge,he,ce=we.I.SUM_BY_NONZERO_WEIGHTS){const ye=(0,J._1)(ge,"losses","computeWeightedLoss");let Ne=null;null!=he&&(Ne=(0,J._1)(he,"weights","computeWeightedLoss"));const Se=null==Ne?ye:(0,ie.d)(ye,Ne);if(ce===we.I.NONE)return Se;if(ce===we.I.SUM)return(0,Ce.S)(Se);if(ce===we.I.MEAN){if(null==Ne)return(0,Yr.J)(Se);{const Ae=ye.size/Ne.size,Pe=(0,Xt.h)((0,Ce.S)(Se),(0,Ce.S)(Ne));return Ae>1?(0,Xt.h)(Pe,(0,un.i)(Ae)):Pe}}if(ce===we.I.SUM_BY_NONZERO_WEIGHTS){if(null==Ne)return(0,Xt.h)((0,Ce.S)(Se),(0,un.i)(ye.size));{const Ae=(0,ie.d)(Ne,(0,Kn.i)(ye.shape)),Pe=(0,tt.p)((0,Ce.S)((0,Us.Q)(Ae,(0,un.i)(0))),"float32");return(0,Xt.h)((0,Ce.S)(Se),Pe)}}throw Error(`Unknown reduction: ${ce}`)}});const He=(0,F.op)({absoluteDifference_:function(ge,he,ce,ye=we.I.SUM_BY_NONZERO_WEIGHTS){const Ne=(0,J._1)(ge,"labels","absoluteDifference"),Se=(0,J._1)(he,"predictions","absoluteDifference");let Ae=null;null!=ce&&(Ae=(0,J._1)(ce,"weights","absoluteDifference")),(0,te.k5)(Ne.shape,Se.shape,"Error in absoluteDifference: ");const Pe=(0,g.W)((0,sn.l)(Ne,Se));return me(Pe,Ae,ye)}});const Re=(0,F.op)({cosineDistance_:function(ge,he,ce,ye,Ne=we.I.SUM_BY_NONZERO_WEIGHTS){const Se=(0,J._1)(ge,"labels","cosineDistance"),Ae=(0,J._1)(he,"predictions","cosineDistance");let Pe=null;null!=ye&&(Pe=(0,J._1)(ye,"weights","cosineDistance")),(0,te.k5)(Se.shape,Ae.shape,"Error in cosineDistance: ");const et=(0,un.i)(1),je=(0,sn.l)(et,(0,Ce.S)((0,ie.d)(Se,Ae),ce,true));return me(je,Pe,Ne)}});const pt=(0,F.op)({hingeLoss_:function(ge,he,ce,ye=we.I.SUM_BY_NONZERO_WEIGHTS){let Ne=(0,J._1)(ge,"labels","hingeLoss");const Se=(0,J._1)(he,"predictions","hingeLoss");let Ae=null;null!=ce&&(Ae=(0,J._1)(ce,"weights","hingeLoss")),(0,te.k5)(Ne.shape,Se.shape,"Error in hingeLoss: ");const Pe=(0,un.i)(1);Ne=(0,sn.l)((0,ie.d)((0,un.i)(2),Ne),Pe);const et=(0,Zt.U)((0,sn.l)(Pe,(0,ie.d)(Ne,Se)));return me(et,Ae,ye)}});const _=(0,F.op)({huberLoss_:function(ge,he,ce,ye=1,Ne=we.I.SUM_BY_NONZERO_WEIGHTS){const Se=(0,J._1)(ge,"labels","huberLoss"),Ae=(0,J._1)(he,"predictions","huberLoss");let Pe=null;null!=ce&&(Pe=(0,J._1)(ce,"weights","huberLoss")),(0,te.k5)(Se.shape,Ae.shape,"Error in huberLoss: ");const et=(0,un.i)(ye),je=(0,g.W)((0,sn.l)(Ae,Se)),ft=(0,ts.L)(je,et),Tt=(0,sn.l)(je,ft),Vt=(0,i.I)((0,ie.d)((0,un.i)(.5),(0,Or.h)(ft)),(0,ie.d)(et,Tt));return me(Vt,Pe,Ne)}});const E=(0,F.op)({logLoss_:function(ge,he,ce,ye=1e-7,Ne=we.I.SUM_BY_NONZERO_WEIGHTS){const Se=(0,J._1)(ge,"labels","logLoss"),Ae=(0,J._1)(he,"predictions","logLoss");let Pe=null;null!=ce&&(Pe=(0,J._1)(ce,"weights","logLoss")),(0,te.k5)(Se.shape,Ae.shape,"Error in logLoss: ");const et=(0,un.i)(1),je=(0,un.i)(ye),ft=(0,Dn.W)((0,ie.d)(Se,(0,mr.c)((0,i.I)(Ae,je)))),Tt=(0,ie.d)((0,sn.l)(et,Se),(0,mr.c)((0,i.I)((0,sn.l)(et,Ae),je))),Vt=(0,sn.l)(ft,Tt);return me(Vt,Pe,Ne)}});const $=(0,F.op)({meanSquaredError_:function(ge,he,ce,ye=we.I.SUM_BY_NONZERO_WEIGHTS){const Ne=(0,J._1)(ge,"labels","meanSquaredError"),Se=(0,J._1)(he,"predictions","meanSquaredError");let Ae=null;null!=ce&&(Ae=(0,J._1)(ce,"weights","meanSquaredError")),(0,te.k5)(Ne.shape,Se.shape,"Error in meanSquaredError: ");const Pe=(0,Ks.$)(Ne,Se);return me(Pe,Ae,ye)}});const Ee=(0,F.op)({sigmoidCrossEntropy_:function(ge,he,ce,ye=0,Ne=we.I.SUM_BY_NONZERO_WEIGHTS){let Se=(0,J._1)(ge,"multiClassLabels","sigmoidCrossEntropy");const Ae=(0,J._1)(he,"logits","sigmoidCrossEntropy");let Pe=null;if(null!=ce&&(Pe=(0,J._1)(ce,"weights","sigmoidCrossEntropy")),(0,te.k5)(Se.shape,Ae.shape,"Error in sigmoidCrossEntropy: "),ye>0){const je=(0,un.i)(ye),ft=(0,un.i)(1),Tt=(0,un.i)(.5);Se=(0,i.I)((0,ie.d)(Se,(0,sn.l)(ft,je)),(0,ie.d)(Tt,je))}const et=function(je,ft){const Tt=(0,J._1)(je,"labels","sigmoidCrossEntropyWithLogits"),Vt=(0,J._1)(ft,"logits","sigmoidCrossEntropyWithLogits");(0,te.k5)(Tt.shape,Vt.shape,"Error in sigmoidCrossEntropyWithLogits: ");const bn=(0,Zt.U)(Vt),dn=(0,ie.d)(Vt,Tt),Qt=(0,Ls.K)((0,wn.Q)((0,Dn.W)((0,g.W)(Vt))));return(0,i.I)((0,sn.l)(bn,dn),Qt)}(Se,Ae);return me(et,Pe,Ne)}});const Le=(0,F.op)({softmaxCrossEntropy_:function(ge,he,ce,ye=0,Ne=we.I.SUM_BY_NONZERO_WEIGHTS){let Se=(0,J._1)(ge,"onehotLabels","softmaxCrossEntropy");const Ae=(0,J._1)(he,"logits","softmaxCrossEntropy");let Pe=null;if(null!=ce&&(Pe=(0,J._1)(ce,"weights","softmaxCrossEntropy")),(0,te.k5)(Se.shape,Ae.shape,"Error in softmaxCrossEntropy: "),ye>0){const je=(0,un.i)(ye),ft=(0,un.i)(1),Tt=(0,un.i)(Se.shape[1]);Se=(0,i.I)((0,ie.d)(Se,(0,sn.l)(ft,je)),(0,Xt.h)(je,Tt))}const et=function(je,ft,Tt=-1){if(-1===Tt&&(Tt=ft.rank-1),Tt!==ft.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${ft.rank} and dim was ${Tt}`);return(0,fs.cb)((Vt,bn,dn)=>{const Qt=Gn(bn,[Tt],true),Rn=(0,sn.l)((0,tt.p)(bn,"float32"),Qt);dn([Vt,Rn]);const Zn=(0,Dn.W)((0,ie.d)(Rn,Vt));return{value:(0,Ce.S)(Zn,[Tt]),gradFunc:(Vn,Cr)=>{const[zn,Wn]=Cr,qn=(0,gr.rv)(Vn.shape,[Tt]);return[(0,ie.d)((0,ke.X)(Vn,qn),(0,sn.l)((0,tt.p)(zn,"float32"),(0,wn.Q)(Wn))),(0,ie.d)((0,ke.X)(Vn,qn),(0,sn.l)((0,wn.Q)(Wn),(0,tt.p)(zn,"float32")))]}}})(je,ft)}(Se,Ae);return me(et,Pe,Ne)}});const Ze=(0,F.op)({sparseFillEmptyRows_:function(ge,he,ce,ye){const Ne=(0,J._1)(ge,"indices","sparseFillEmptyRows"),Se=(0,J._1)(he,"values","sparseFillEmptyRows"),Ae=(0,J._1)(ce,"denseShape","sparseFillEmptyRows"),Pe=(0,J._1)(ye,"defaultValue","sparseFillEmptyRows",Se.dtype);if(2!==Ne.rank)throw new Error(`Indices should be Tensor2D but received shape
        ${Ne.shape}`);if(1!==Se.rank)throw new Error(`Values should be Tensor1D but received shape ${Se.shape}`);if(1!==Ae.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${Ae.shape}`);if(0!==Pe.rank)throw new Error(`Default value should be a scalar but received shape ${Pe.shape}`);const et={indices:Ne,values:Se,denseShape:Ae,defaultValue:Pe},je=Y.BV.runKernel(be.O3,et);return{outputIndices:je[0],outputValues:je[1],emptyRowIndicator:je[2],reverseIndexMap:je[3]}}});const qe=(0,F.op)({sparseReshape_:function(ge,he,ce){const ye=(0,J._1)(ge,"inputIndices","sparseReshape"),Ne=(0,J._1)(he,"inputShape","sparseReshape"),Se=(0,J._1)(ce,"newShape","sparseReshape");if(2!==ye.rank)throw new Error(`Input indices should be Tensor2D but received shape
        ${ye.shape}`);if(1!==Ne.rank)throw new Error(`Input shape should be Tensor1D but received shape ${Ne.shape}`);if(1!==Se.rank)throw new Error(`New shape should be Tensor1D but received shape ${Se.shape}`);const Ae={inputIndices:ye,inputShape:Ne,newShape:Se},Pe=Y.BV.runKernel(be.nh,Ae);return{outputIndices:Pe[0],outputShape:Pe[1]}}});const ht=(0,F.op)({sparseSegmentMean_:function(ge,he,ce){const ye=(0,J._1)(ge,"data","sparseSegmentMean"),Ne=(0,J._1)(he,"indices","sparseSegmentMean"),Se=(0,J._1)(ce,"segmentIds","sparseSegmentMean");if(ye.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==Ne.rank)throw new Error(`Indices should be Tensor1D but received shape
          ${Ne.shape}`);if(1!==Se.rank)throw new Error(`Segment ids should be Tensor1D but received shape
          ${Se.shape}`);const Ae={data:ye,indices:Ne,segmentIds:Se};return Y.BV.runKernel(be.YW,Ae)}});const At=(0,F.op)({sparseSegmentSum_:function(ge,he,ce){const ye=(0,J._1)(ge,"data","sparseSegmentSum"),Ne=(0,J._1)(he,"indices","sparseSegmentSum"),Se=(0,J._1)(ce,"segmentIds","sparseSegmentSum");if(ye.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==Ne.rank)throw new Error(`Indices should be Tensor1D but received shape
         ${Ne.shape}`);if(1!==Se.rank)throw new Error(`Segment ids should be Tensor1D but received shape
         ${Se.shape}`);const Ae={data:ye,indices:Ne,segmentIds:Se};return Y.BV.runKernel(be.Zj,Ae)}});const rn=(0,F.op)({stringNGrams_:function(ge,he,ce,ye,Ne,Se,Ae,Pe){const et=(0,J._1)(ge,"data","stringNGrams","string");if("string"!==et.dtype)throw new Error("Data must be of datatype string");if(1!==et.shape.length)throw new Error(`Data must be a vector, saw: ${et.shape}`);const je=(0,J._1)(he,"dataSplits","stringNGrams");if("int32"!==je.dtype)throw new Error("Data splits must be of datatype int32");const ft={separator:ce,nGramWidths:ye,leftPad:Ne,rightPad:Se,padWidth:Ae,preserveShortSequences:Pe},Tt={data:et,dataSplits:je},Vt=Y.BV.runKernel(be._J,Tt,ft);return{nGrams:Vt[0],nGramsSplits:Vt[1]}}});const ln=(0,F.op)({stringSplit_:function(ge,he,ce=true){const ye=(0,J._1)(ge,"input","stringSplit","string"),Ne=(0,J._1)(he,"delimiter","stringSplit","string");if(1!==ye.rank)throw new Error(`Input should be Tensor1D but received shape ${ye.shape}`);if(0!==Ne.rank)throw new Error(`Delimiter should be a scalar but received shape ${Ne.shape}`);const Se={skipEmpty:ce},Ae={input:ye,delimiter:Ne},Pe=Y.BV.runKernel(be.s1,Ae,Se);return{indices:Pe[0],values:Pe[1],shape:Pe[2]}}});const _a=(0,F.op)({stringToHashBucketFast_:function(ge,he){const ce=(0,J._1)(ge,"input","stringToHashBucketFast","string"),ye={numBuckets:he};if(he<=0)throw new Error("Number of buckets must be at least 1");const Ne={input:ce};return Y.BV.runKernel(be.Xk,Ne,ye)}}),na={fft:Gs.k,ifft:Er.S,rfft:Ar.Q,irfft:Ca.w},Sa={hammingWindow:ro,hannWindow:Ys,frame:ea,stft:Oa},fo={flipLeftRight:Na,grayscaleToRGB:xa,resizeNearestNeighbor:Je,resizeBilinear:Te,rotateWithOffset:ta,cropAndResize:so,nonMaxSuppression:B,nonMaxSuppressionAsync:D,nonMaxSuppressionWithScore:H,nonMaxSuppressionWithScoreAsync:j,nonMaxSuppressionPadded:de,nonMaxSuppressionPaddedAsync:xe,threshold:it,transform:ut},zo={bandPart:Ue,gramSchmidt:ee,qr:X},Wo={absoluteDifference:He,computeWeightedLoss:me,cosineDistance:Re,hingeLoss:pt,huberLoss:_,logLoss:E,meanSquaredError:$,sigmoidCrossEntropy:Ee,softmaxCrossEntropy:Le},Uo={sparseFillEmptyRows:Ze,sparseReshape:qe,sparseSegmentMean:ht,sparseSegmentSum:At},qo={stringNGrams:rn,stringSplit:ln,stringToHashBucketFast:_a}},9682:(b,u,e)=>{e.d(u,{v:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({pad_:function(w,k,I=0){const T=(0,h._1)(w,"x","pad");if(0===T.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const c={paddings:k,constantValue:I},p={x:T};return g.BV.runKernel(n.ly,p,c)}})},3453:(b,u,e)=>{e.d(u,{s:()=>w});var g=e(7097),n=e(9121),h=e(747),i=e(3740);const w=(0,e(2668).op)({pow_:function(k,I){let T=(0,i._1)(k,"base","pow"),c=(0,i._1)(I,"exp","pow");[T,c]=(0,h.makeTypesMatch)(T,c);const p={a:T,b:c};return g.BV.runKernel(n.pe,p)}})},8151:(b,u,e)=>{e.d(u,{A:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({prelu_:function(w,k){const I={x:(0,h._1)(w,"x","prelu"),alpha:(0,h._1)(k,"alpha","prelu")};return g.BV.runKernel(n.o0,I)}})},9798:(b,u,e)=>{function g(n,h=false){console.log(n.toString(h))}e.d(u,{S:()=>g})},9451:(b,u,e)=>{e.d(u,{W:()=>w});var g=e(7097),n=e(9121),h=e(3740),i=e(2271);const w=(0,e(2668).op)({prod_:function(k,I=null,T=false){let c=(0,h._1)(k,"x","prod");"bool"===c.dtype&&(c=(0,i.p)(c,"int32"));const p={x:c},y={axis:I,keepDims:T};return g.BV.runKernel(n.Dl,p,y)}})},6845:(b,u,e)=>{e.d(u,{Yi:()=>n,T9:()=>h,wv:()=>i});var g=e(6377);class n{constructor(k,I,T,c,p){this.mean=k,this.stdDev=I,this.dtype=T,this.nextVal=NaN,this.truncated=c,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const y=p||Math.random();this.random=g.alea(y.toString())}nextValue(){if(!isNaN(this.nextVal)){const c=this.nextVal;return this.nextVal=NaN,c}let k,I,T=false;for(;!T;){let c,p,y;do{c=2*this.random()-1,p=2*this.random()-1,y=c*c+p*p}while(y>=1||0===y);const W=Math.sqrt(-2*Math.log(y)/y);k=this.mean+this.stdDev*c*W,I=this.mean+this.stdDev*p*W,this.truncated&&!this.isValidTruncated(k)||(T=true)}return this.truncated&&!this.isValidTruncated(I)||(this.nextVal=this.convertValue(I)),this.convertValue(k)}convertValue(k){return null==this.dtype||"float32"===this.dtype?k:Math.round(k)}isValidTruncated(k){return k<=this.upper&&k>=this.lower}}class h{constructor(k,I,T,c){this.alpha=k,this.beta=1/I,this.dtype=T;const p=c||Math.random();this.randu=g.alea(p.toString()),this.randn=new n(0,1,T,false,this.randu()),this.d=k<1?k+2/3:k-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let k,I,T,c,p,y;for(;;){do{c=this.randn.nextValue(),y=1+this.c*c}while(y<=0);if(y*=y*y,k=c*c,I=1-.331*k*k,T=.5*k+this.d*(1-y+Math.log(y)),p=this.randu(),p<I||Math.log(p)<T)break}return y=1/this.beta*this.d*y,this.alpha<1&&(y*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(y)}convertValue(k){return"float32"===this.dtype?k:Math.round(k)}}class i{constructor(k=0,I=1,T,c){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=k,this.range=I-k,this.dtype=T,null==c&&(c=Math.random()),"number"==typeof c&&(c=c.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${k} - ${I} <= 1 and dtype is not float`);this.random=g.alea(c)}convertValue(k){return this.canReturnFloat()?k:Math.round(k)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}},5002:(b,u,e)=>{e.d(u,{L:()=>i});var g=e(2657),n=e(2668),h=e(6845);const i=(0,n.op)({randomUniform_:function(w,k=0,I=1,T="float32",c){const p=(0,g.f)(w,T),y=new h.wv(k,I,null,c);for(let W=0;W<p.values.length;W++)p.values[W]=y.nextValue();return p.toTensor()}})},7245:(b,u,e)=>{e.d(u,{w:()=>h});var g=e(7097),n=e(9121);function h(i,w,k=1,I="float32"){if(0===k)throw new Error("Cannot have a step of zero");const T={start:i,stop:w,step:k,dtype:I};return g.BV.runKernel(n.e6,{},T)}},766:(b,u,e)=>{e.d(u,{k:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({real_:function(w){const k={input:(0,h._1)(w,"input","real")};return g.BV.runKernel(n.xJ,k)}})},9036:(b,u,e)=>{e.d(u,{M:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({reciprocal_:function(w){const k={x:(0,h._1)(w,"x","reciprocal")};return g.BV.runKernel(n.$H,k)}})},7409:(b,u,e)=>{e.d(u,{U:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({relu_:function(w){const k={x:(0,h._1)(w,"x","relu")};return g.BV.runKernel(n.qk,k)}})},3582:(b,u,e)=>{e.d(u,{b:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({relu6_:function(w){const k={x:(0,h._1)(w,"x","relu6")};return g.BV.runKernel(n.Sb,k)}})},4968:(b,u,e)=>{e.d(u,{X:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({reshape_:function(w,k){const I={x:(0,h._1)(w,"x","reshape","string_or_numeric")},T={shape:k};return g.BV.runKernel(n.HZ,I,T)}})},7486:(b,u,e)=>{e.d(u,{G:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({reverse_:function(w,k){const I={x:(0,h._1)(w,"x","reverse")},T={dims:k};return g.BV.runKernel(n.mK,I,T)}})},7809:(b,u,e)=>{e.d(u,{N:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({round_:function(w){const k={x:(0,h._1)(w,"x","round")};return g.BV.runKernel(n.e0,k)}})},2634:(b,u,e)=>{e.d(u,{b:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({rsqrt_:function(w){const k={x:(0,h._1)(w,"x","rsqrt")};return g.BV.runKernel(n.bV,k)}})},9494:(b,u,e)=>{e.d(u,{i:()=>h});var g=e(569),n=e(7852);function h(i,w){if(((0,g.fU)(i)&&"string"!==w||Array.isArray(i))&&"complex64"!==w)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===w&&(0,g.fU)(i)&&!(i instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return(0,n.H)(i,[],[],w)}},3100:(b,u,e)=>{e.d(u,{s:()=>k});var g=e(7097),n=e(9121),h=e(3740),i=e(2668),w=e(3028);const k=(0,i.op)({scatterND_:function(I,T,c){const p=(0,h._1)(I,"indices","scatterND","int32"),y=(0,h._1)(T,"updates","scatterND");w.validateInput(y,p,c);const W={indices:p,updates:y},L={shape:c};return g.BV.runKernel(n.xQ,W,L)}})},3028:(b,u,e)=>{e.r(u),e.d(u,{validateUpdateShape:()=>n,validateInput:()=>h,calculateShapes:()=>i});var g=e(569);function n(w,k,I){const T=k.rank>1?k.shape[k.rank-1]:1,c=k.rank>1?k.rank-1:1,p=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${I.shape}, indices.shape: ${k.shape}, shape: ${w}, sliceDim: ${T}, and batchDim: ${c}.`;if(I.rank<c)throw new Error(p+` update.rank < ${c}. `);if(w.length<T+(I.rank-c))throw new Error(p+` Output shape length < ${T+(I.rank-c)}`);if(I.rank!==c+w.length-T)throw new Error(p+" update.rank != "+(c+w.length-T));for(let y=0;y<c;++y)if(I.shape[y]!==k.shape[y])throw new Error(p+` updates.shape[${y}] (${I.shape[y]}) != indices.shape[${y}] (${k.shape[y]}).`);for(let y=0;y<I.rank-c;++y)if(I.shape[y+c]!==w[y+T])throw new Error(p+` updates.shape[${y+c}] (${I.shape[y+c]}) != shape[${y+c}] (${w[y+c]})`)}function h(w,k,I){if(k.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${k.rank}.`);if(w.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${w.rank}.`);if("int32"!==k.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${k.dtype}`);if(I.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${I}`);if(0===I.length){if(0===k.size)throw new Error(`Indices specified for empty output. indices shape: ${k.shape}`);if(0===w.size)throw new Error(`Updates specified for empty output. updates shape: ${w.shape}`)}n(I,k,w)}function i(w,k,I){const T=k.shape.length,c=T>1?k.shape[T-1]:1,p=I.length;let y=1;for(let L=c;L<p;++L)y*=I[L];const W=c<1?1:c;return{sliceRank:c,numUpdates:(0,g.NA)(k.shape)/W,sliceSize:y,strides:[...(0,g.e3)(I.slice(0,c)),1],outputSize:(0,g.NA)(I)}}},5503:(b,u,e)=>{e.d(u,{U:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({selu_:function(w){const k={x:(0,h._1)(w,"x","selu")};return g.BV.runKernel(n.oF,k)}})},6567:(b,u,e)=>{e.d(u,{O:()=>i});var g=e(4077),n=e(3740),h=e(569);const i=async function(w,k){const I=(0,n._1)(w,"x","setdiff1d"),T=(0,n._1)(k,"y","setdiff1d");h.hu(I.dtype===T.dtype,()=>`x and y should have the same dtype, but got x (${I.dtype}) and y (${T.dtype}).`),h.hu(1===I.rank,()=>`x should be 1D tensor, but got x (${I.shape}).`),h.hu(1===T.rank,()=>`y should be 1D tensor, but got y (${T.shape}).`);const c=await I.data(),p=await T.data(),y=new Set(p);let W=0;for(let K=0;K<c.length;K++)y.has(c[K])||W++;const L=new g.YD([W],I.dtype),R=new g.YD([W],"int32");for(let K=0,re=0;K<c.length;K++)y.has(c[K])||(L.values[re]=c[K],R.values[re]=K,re++);return[L.toTensor(),R.toTensor()]}},625:(b,u,e)=>{e.d(u,{X:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({sigmoid_:function(w){const k={x:(0,h._1)(w,"x","sigmoid")};return g.BV.runKernel(n.a5,k)}})},4434:(b,u,e)=>{e.d(u,{X:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({sign_:function(w){const k={x:(0,h._1)(w,"x","sign")};return g.BV.runKernel(n.i5,k)}})},9331:(b,u,e)=>{e.d(u,{O:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({sin_:function(w){const k={x:(0,h._1)(w,"x","sin")};return g.BV.runKernel(n.RQ,k)}})},3254:(b,u,e)=>{e.d(u,{R:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({sinh_:function(w){const k={x:(0,h._1)(w,"x","sinh")};return g.BV.runKernel(n.w3,k)}})},2676:(b,u,e)=>{e.d(u,{t:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({slice_:function(w,k,I){const T=(0,h._1)(w,"x","slice","string_or_numeric");if(0===T.rank)throw new Error("Slicing scalar is not possible");const c={x:T},p={begin:k,size:I};return g.BV.runKernel(n.p2,c,p)}})},682:(b,u,e)=>{e.d(u,{X:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({softmax_:function(w,k=-1){const I=(0,h._1)(w,"logits","softmax","float32");if(-1===k&&(k=I.rank-1),k!==I.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${I.rank} and dim was ${k}`);const T={logits:I},c={dim:k};return g.BV.runKernel(n.Gc,T,c)}})},3694:(b,u,e)=>{e.d(u,{W:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({softplus_:function(w){const k={x:(0,h._1)(w,"x","softplus")};return g.BV.runKernel(n.MR,k)}})},7918:(b,u,e)=>{e.d(u,{f:()=>w});var g=e(7097),n=e(9121),h=e(3740),i=e(569);const w=(0,e(2668).op)({spaceToBatchND_:function(k,I,T){const c=(0,h._1)(k,"x","spaceToBatchND");i.hu(c.rank>=1+I.length,()=>`input rank ${c.rank} should be > than [blockShape] ${I.length}`),i.hu(T.length===I.length,()=>`paddings.shape[0] ${T.length} must be equal to [blockShape] ${I.length}`),i.hu(c.shape.reduce((W,L,R)=>R>0&&R<=I.length?W&&(L+T[R-1][0]+T[R-1][1])%I[R-1]==0:W,true),()=>`input spatial dimensions ${c.shape.slice(1)} with paddings ${T.toString()} must be divisible by blockShapes ${I.toString()}`);const p={x:c},y={blockShape:I,paddings:T};return g.BV.runKernel(n.TQ,p,y)}})},9758:(b,u,e)=>{e.d(u,{e:()=>i});var g=e(7097),n=e(9121);var h=e(3740);const i=(0,e(2668).op)({sparseToDense_:function(w,k,I,T=0){const c=(0,h._1)(w,"sparseIndices","sparseToDense","int32"),p=(0,h._1)(k,"sparseValues","sparseToDense"),y=(0,h._1)(T,"defaultValue","sparseToDense",p.dtype);!function(R,K,re,J){if("int32"!==R.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${R.dtype}.`);if(R.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${R.shape}.`);const ve=R.rank>0?R.shape[0]:1,ue=R.rank>1?R.shape[1]:1;if(re.length!==ue)throw new Error(`outputShape has incorrect number of elements:, ${re.length}, should be: ${ue}.`);const ie=K.size;if(0!==K.rank&&(1!==K.rank||ie!==ve))throw new Error(`sparseValues has incorrect shape ${K.shape}, should be [] or [${ve}]`);if(K.dtype!==J.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(c,p,I,y);const W={sparseIndices:c,sparseValues:p,defaultValue:y},L={outputShape:I};return g.BV.runKernel(n.D2,W,L)}})},7020:(b,u,e)=>{e.d(u,{k:()=>i});var g=e(7097),n=e(9121),h=e(569);const i=(0,e(2668).op)({fft_:function(w){(0,h.hu)("complex64"===w.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${w.dtype}.`);const k={input:w};return g.BV.runKernel(n.vw,k)}})},8447:(b,u,e)=>{e.d(u,{S:()=>i});var g=e(7097),n=e(9121),h=e(569);const i=(0,e(2668).op)({ifft_:function(w){(0,h.hu)("complex64"===w.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${w.dtype}.`);const k={input:w};return g.BV.runKernel(n.Qg,k)}})},4415:(b,u,e)=>{e.d(u,{w:()=>W});var g=e(1661),n=e(6884),h=e(4386),i=e(4841),w=e(2668),k=e(766),I=e(4968),T=e(7486),c=e(9494),p=e(2676),y=e(8447);const W=(0,w.op)({irfft_:function(L){const R=L.shape[L.shape.length-1],K=L.size/R;let re;if(R<=2){const J=(0,I.X)(L,[K,R]);re=(0,y.S)(J)}else{const J=[K,2*(R-1)],ve=(0,I.X)((0,k.k)(L),[K,R]),ue=(0,I.X)((0,h.a)(L),[K,R]),ie=(0,T.G)((0,p.t)(ve,[0,1],[K,R-2]),1),F=(0,i.d)((0,T.G)((0,p.t)(ue,[0,1],[K,R-2]),1),(0,c.i)(-1)),P=(0,n.z)([ve,ie],1),f=(0,n.z)([ue,F],1),Q=(0,I.X)((0,g.P)(P,f),[J[0],J[1]]);re=(0,y.S)(Q)}if(re=(0,k.k)(re),3===L.rank&&0!==L.shape[0]){const J=re,ve=L.shape[0];re=(0,I.X)(re,[ve,re.shape[0]/ve,re.shape[1]]),J.dispose()}return re}})},3710:(b,u,e)=>{e.d(u,{Q:()=>L});var g=e(569),n=e(1661),h=e(6884),i=e(4386),w=e(2668),k=e(766),I=e(4968),T=e(2676),c=e(8644),p=e(9640),y=e(6577),W=e(7020);const L=(0,w.op)({rfft_:function(R,K){(0,g.hu)("float32"===R.dtype,()=>`The dtype for rfft() must be real value but got ${R.dtype}`);let re=R.shape[R.shape.length-1];const J=R.size/re;let ve;if(null!=K&&K<re){const te=R.shape.map(Ve=>0),De=R.shape.map(Ve=>Ve);De[R.shape.length-1]=K,ve=(0,T.t)(R,te,De),re=K}else if(null!=K&&K>re){const te=R.shape.map(De=>De);te[R.shape.length-1]=K-re,ve=(0,h.z)([R,(0,p.l)(te)],R.shape.length-1),re=K}else ve=R;const ue=(0,y.P)(ve),ie=(0,I.X)((0,n.P)(ve,ue),[J,re]),F=(0,W.k)(ie),P=Math.floor(re/2)+1,f=(0,k.k)(F),Q=(0,i.a)(F),oe=(0,c.V)(f,[P,re-P],f.shape.length-1),se=(0,c.V)(Q,[P,re-P],Q.shape.length-1),o=ve.shape.slice();return o[ve.shape.length-1]=P,(0,I.X)((0,n.P)(oe[0],se[0]),o)}})},8644:(b,u,e)=>{e.d(u,{V:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({split_:function(w,k,I=0){const T={x:(0,h._1)(w,"x","split")},c={numOrSizeSplits:k,axis:I};return g.BV.runKernel(n.L8,T,c)}})},3261:(b,u,e)=>{e.d(u,{_:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({sqrt_:function(w){const k={x:(0,h._1)(w,"x","sqrt")};return g.BV.runKernel(n.FK,k)}})},248:(b,u,e)=>{e.d(u,{h:()=>h});var g=e(7097),n=e(3740);const h=(0,e(2668).op)({square_:function(i){const w=(0,n._1)(i,"x","square");return g.BV.runKernel("Square",{x:w},{})}})},5265:(b,u,e)=>{e.d(u,{$:()=>k});var g=e(7097),n=e(9121),h=e(747),i=e(3740),w=e(2200);const k=(0,e(2668).op)({squaredDifference_:function(I,T){let c=(0,i._1)(I,"a","squaredDifference"),p=(0,i._1)(T,"b","squaredDifference");[c,p]=(0,h.makeTypesMatch)(c,p),(0,w.$N)(c.shape,p.shape);const y={a:c,b:p};return g.BV.runKernel(n._t,y,{})}})},9590:(b,u,e)=>{e.d(u,{L:()=>w});var g=e(3740),n=e(569),h=e(2668),i=e(4968);const w=(0,h.op)({squeeze_:function(k,I){const T=(0,g._1)(k,"x","squeeze");return(0,i.X)(T,(0,n.bp)(T.shape,I).newShape)}})},2991:(b,u,e)=>{e.d(u,{k:()=>w});var g=e(7097),n=e(9121),h=e(3740),i=e(569);const w=(0,e(2668).op)({stack_:function(k,I=0){const T=(0,h.sI)(k,"tensors","stack","string_or_numeric");i.hu(T.length>=1,()=>"Pass at least one tensor to tf.stack"),T.length>0&&i.hu(I<=T[0].rank,()=>"Axis must be <= rank of the tensor");const c=T,p={axis:I};return g.BV.runKernel(n.Qi,c,p)}})},1901:(b,u,e)=>{e.d(u,{N:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({step_:function(w,k=0){const I={x:(0,h._1)(w,"x","step")},T={alpha:k};return g.BV.runKernel(n.h8,I,T)}})},5158:(b,u,e)=>{e.d(u,{N:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({stridedSlice_:function(w,k,I,T,c=0,p=0,y=0,W=0,L=0){const R={x:(0,h._1)(w,"x","stridedSlice","string_or_numeric")},K={begin:k,end:I,strides:T,beginMask:c,endMask:p,ellipsisMask:y,newAxisMask:W,shrinkAxisMask:L};return g.BV.runKernel(n.m2,R,K)}})},827:(b,u,e)=>{e.d(u,{l:()=>w});var g=e(7097),n=e(9121),h=e(747),i=e(3740);const w=(0,e(2668).op)({sub_:function(k,I){let T=(0,i._1)(k,"a","sub"),c=(0,i._1)(I,"b","sub");[T,c]=(0,h.makeTypesMatch)(T,c);const p={a:T,b:c};return g.BV.runKernel(n.Tr,p)}})},5475:(b,u,e)=>{e.d(u,{S:()=>w});var g=e(7097),n=e(9121),h=e(3740),i=e(2271);const w=(0,e(2668).op)({sum_:function(k,I=null,T=false){let c=(0,h._1)(k,"x","sum");"bool"===c.dtype&&(c=(0,i.p)(c,"int32"));const p={x:c},y={axis:I,keepDims:T};return g.BV.runKernel(n.GB,p,y)}})},1173:(b,u,e)=>{e.d(u,{O:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({tan_:function(w){const k={x:(0,h._1)(w,"x","tan")};return g.BV.runKernel(n.sE,k)}})},1869:(b,u,e)=>{e.d(u,{A:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({tanh_:function(w){const k={x:(0,h._1)(w,"x","tanh")};return g.BV.runKernel(n.MI,k)}})},701:(b,u,e)=>{e.d(u,{X:()=>h});var g=e(3740),n=e(7852);function h(i,w,k){const I=(0,g.C)(i,k);return(0,n.H)(i,w,I,k)}},6092:(b,u,e)=>{e.d(u,{R:()=>i});var g=e(3740),n=e(569),h=e(7852);function i(w,k){(0,n.Cq)(w);const I=(0,g.C)(w,k);if(1!==I.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return(0,h.H)(w,null,I,k)}},9906:(b,u,e)=>{e.d(u,{w:()=>i});var g=e(3740),n=e(569),h=e(7852);function i(w,k,I){if((0,n.Cq)(w),null!=k&&3!==k.length)throw new Error("tensor3d() requires shape to have three numbers");const T=(0,g.C)(w,I);if(3!==T.length&&1!==T.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===T.length&&null==k)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return(0,h.H)(w,k,T,I)}},7852:(b,u,e)=>{e.d(u,{H:()=>i});var g=e(7097),n=e(569),h=e(9122);function i(w,k,I,T){if(null==T&&(T=(0,n.D2)(w)),"complex64"===T)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!(0,n.fU)(w)&&!Array.isArray(w)&&"number"!=typeof w&&"boolean"!=typeof w&&"string"!=typeof w)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=k){(0,n.Mu)(k);const c=(0,n.NA)(k),p=(0,n.NA)(I);(0,n.hu)(c===p,()=>`Based on the provided shape, [${k}], the tensor should have ${c} values but has ${p}`);for(let y=0;y<I.length;++y){const W=I[y],L=y!==I.length-1||W!==(0,n.NA)(k.slice(y));(0,n.hu)(I[y]===k[y]||!L,()=>`Error creating a new Tensor. Inferred shape (${I}) does not match the provided shape (${k}). `)}}return(0,n.fU)(w)||Array.isArray(w)||(w=[w]),k=k||I,w="string"!==T?(0,h.toTypedArray)(w,T):(0,n.xH)(w,[],true),g.BV.makeTensor(w,k,T)}},7501:(b,u,e)=>{e.d(u,{G:()=>w});var g=e(7097),n=e(9121),h=e(3740),i=e(569);const w=(0,e(2668).op)({tile_:function(k,I){const T=(0,h._1)(k,"x","tile","string_or_numeric");i.hu(T.rank===I.length,()=>`Error in transpose: rank of input ${T.rank} must match length of reps ${I}.`);const c={x:T},p={reps:I};return g.BV.runKernel(n.n9,c,p)}})},3243:(b,u,e)=>{e.d(u,{h:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({topk_:function(w,k=1,I=true){const T=(0,h._1)(w,"x","topk");if(0===T.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const c=T.shape[T.shape.length-1];if(k<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${k}`);if(k>c)throw new Error(`'k' passed to topk() must be <= the last dimension (${c}) but got ${k}`);const p={x:T},y={k,sorted:I},[W,L]=g.BV.runKernel(n.cW,p,y);return{values:W,indices:L}}})},9065:(b,u,e)=>{e.d(u,{p:()=>w});var g=e(7097),n=e(9121),h=e(3740),i=e(569);const w=(0,e(2668).op)({transpose_:function(k,I){const T=(0,h._1)(k,"x","transpose");if(null==I&&(I=T.shape.map((y,W)=>W).reverse()),i.hu(T.rank===I.length,()=>`Error in transpose: rank of input ${T.rank} must match length of perm ${I}.`),I.forEach(y=>{i.hu(y>=0&&y<T.rank,()=>"All entries in 'perm' must be between 0 and "+(T.rank-1)+` but got ${I}`)}),T.rank<=1)return T.clone();const c={x:T},p={perm:I};return g.BV.runKernel(n.G3,c,p)}})},3596:(b,u,e)=>{e.d(u,{X:()=>i});var g=e(2657),n=e(2668),h=e(6845);const i=(0,n.op)({truncatedNormal_:function(w,k=0,I=1,T,c){if(null!=T&&"bool"===T)throw new Error("Unsupported data type $ { dtype }");const p=new h.Yi(k,I,T,true,c),y=(0,g.f)(w,T);for(let W=0;W<y.values.length;W++)y.values[W]=p.nextValue();return y.toTensor()}})},9608:(b,u,e)=>{e.d(u,{T:()=>w});var g=e(7097),n=e(9121),h=e(3740),i=e(569);const w=(0,e(2668).op)({unique_:function(k,I=0){const T=(0,h._1)(k,"x","unique","string_or_numeric");(0,i.hu)(T.rank>0,()=>"The input tensor must be at least 1D");const c={x:T},p={axis:I},[y,W]=g.BV.runKernel(n.kp,c,p);return{values:y,indices:W}}})},4136:(b,u,e)=>{e.d(u,{H:()=>w});var g=e(7097),n=e(9121),h=e(3740),i=e(569);const w=(0,e(2668).op)({unstack_:function(k,I=0){const T=(0,h._1)(k,"x","unstack","string_or_numeric");i.hu(I>=-T.shape.length&&I<T.shape.length,()=>`Axis = ${I} is not in [-${T.shape.length}, ${T.shape.length})`);const c={value:T},p={axis:I};return g.BV.runKernel(n.To,c,p)}})},5912:(b,u,e)=>{e.d(u,{a:()=>k});var g=e(7097),n=e(9121),h=e(3740),i=e(8247),w=e(2200);const k=(0,e(2668).op)({where_:function(I,T,c){const p=(0,h._1)(T,"a","where"),y=(0,h._1)(c,"b","where"),W=(0,h._1)(I,"condition","where","bool"),L=(0,w.$N)((0,w.$N)(W.shape,p.shape),y.shape),R={condition:(0,i.U)(W,L),t:(0,i.U)(p,L),e:(0,i.U)(y,L)};return g.BV.runKernel(n.Ph,R)}})},6380:(b,u,e)=>{e.d(u,{i:()=>h});var g=e(8333),n=e(3740);const h=async function(i){const w=(0,n._1)(i,"condition","whereAsync","bool"),k=await w.data(),I=(0,g.Z)(w.shape,k);return i!==w&&w.dispose(),I}},9640:(b,u,e)=>{e.d(u,{l:()=>i});var g=e(7097),n=e(569),h=e(1661);function i(w,k="float32"){if("complex64"===k){const T=i(w,"float32"),c=i(w,"float32");return(0,h.P)(T,c)}const I=(0,n.wT)((0,n.NA)(w),k);return g.BV.makeTensor(I,w,k)}},6577:(b,u,e)=>{e.d(u,{P:()=>i});var g=e(7097),n=e(9121),h=e(3740);const i=(0,e(2668).op)({zerosLike_:function(w){const k={x:(0,h._1)(w,"x","zerosLike")};return g.BV.runKernel(n.Ru,k)}})},4077:(b,u,e)=>{e.d(u,{es:()=>re,YD:()=>c,_w:()=>J,FZ:()=>K,Vp:()=>R,Vi:()=>L});var g=e(5938),n=e(569);function h(ve,ue,ie,F){const P=(0,n.e3)(ue),f=function(o,te,De,Ve){const ze=(0,n.NA)(te),Ke=Ve[Ve.length-1],Ye=new Array(Ke).fill(0),rt=te.length,Qe="complex64"===De?I(o):o;if(rt>1)for(let tt=0;tt<ze/Ke;tt++){const Nt=tt*Ke;for(let $t=0;$t<Ke;$t++)Ye[$t]=Math.max(Ye[$t],i(Qe[Nt+$t],0,De).length)}return Ye}(ve,ue,ie,P),Q=ue.length,oe=k(ve,ue,ie,P,f),se=["Tensor"];return F&&(se.push(`  dtype: ${ie}`),se.push(`  rank: ${Q}`),se.push(`  shape: [${ue}]`),se.push("  values:")),se.push(oe.map(o=>"    "+o).join("\n")),se.join("\n")}function i(ve,ue,ie){let F;return F=Array.isArray(ve)?`${parseFloat(ve[0].toFixed(7))} + ${parseFloat(ve[1].toFixed(7))}j`:(0,n.HD)(ve)?`'${ve}'`:"bool"===ie?w(ve):parseFloat(ve.toFixed(7)).toString(),(0,n.oj)(F,ue)}function w(ve){return 0===ve?"false":"true"}function k(ve,ue,ie,F,P,f=true){const Q="complex64"===ie?2:1,oe=ue[0],se=ue.length;if(0===se){if("complex64"===ie){return[i(I(ve)[0],0,ie)]}return"bool"===ie?[w(ve[0])]:[ve[0].toString()]}if(1===se){if(oe>20){const Ye=3*Q;let rt=Array.from(ve.slice(0,Ye)),Qe=Array.from(ve.slice((oe-3)*Q,oe*Q));return"complex64"===ie&&(rt=I(rt),Qe=I(Qe)),["["+rt.map((tt,Nt)=>i(tt,P[Nt],ie)).join(", ")+", ..., "+Qe.map((tt,Nt)=>i(tt,P[oe-3+Nt],ie)).join(", ")+"]"]}return["["+("complex64"===ie?I(ve):Array.from(ve)).map((Ye,rt)=>i(Ye,P[rt],ie)).join(", ")+"]"]}const o=ue.slice(1),te=F.slice(1),De=F[0]*Q,Ve=[];if(oe>20){for(let Ye=0;Ye<3;Ye++){const rt=Ye*De,Qe=rt+De;Ve.push(...k(ve.slice(rt,Qe),o,ie,te,P,false))}Ve.push("...");for(let Ye=oe-3;Ye<oe;Ye++){const rt=Ye*De,Qe=rt+De;Ve.push(...k(ve.slice(rt,Qe),o,ie,te,P,Ye===oe-1))}}else for(let Ye=0;Ye<oe;Ye++){const rt=Ye*De,Qe=rt+De;Ve.push(...k(ve.slice(rt,Qe),o,ie,te,P,Ye===oe-1))}const ze=2===se?",":"";Ve[0]="["+Ve[0]+ze;for(let Ye=1;Ye<Ve.length-1;Ye++)Ve[Ye]=" "+Ve[Ye]+ze;let Ke=",\n";for(let Ye=2;Ye<se;Ye++)Ke+="\n";return Ve[Ve.length-1]=" "+Ve[Ve.length-1]+"]"+(f?"":Ke),Ve}function I(ve){const ue=[];for(let ie=0;ie<ve.length;ie+=2)ue.push([ve[ie],ve[ie+1]]);return ue}var T=e(9122);class c{constructor(ue,ie,F){if(this.dtype=ie,this.shape=ue.slice(),this.size=n.NA(ue),null!=F){const P=F.length;n.hu(P===this.size,()=>`Length of values '${P}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===ie)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=F||n.rQ(ie,this.size),this.strides=(0,n.e3)(ue)}set(ue,...ie){0===ie.length&&(ie=[0]),n.hu(ie.length===this.rank,()=>`The number of provided coordinates (${ie.length}) must match the rank (${this.rank})`);const F=this.locToIndex(ie);this.values[F]=ue}get(...ue){0===ue.length&&(ue=[0]);let ie=0;for(const P of ue){if(P<0||P>=this.shape[ie]){const f=`Requested out of range element at ${ue}.   Buffer shape=${this.shape}`;throw new Error(f)}ie++}let F=ue[ue.length-1];for(let P=0;P<ue.length-1;++P)F+=this.strides[P]*ue[P];return this.values[F]}locToIndex(ue){if(0===this.rank)return 0;if(1===this.rank)return ue[0];let ie=ue[ue.length-1];for(let F=0;F<ue.length-1;++F)ie+=this.strides[F]*ue[F];return ie}indexToLoc(ue){if(0===this.rank)return[];if(1===this.rank)return[ue];const ie=new Array(this.shape.length);for(let F=0;F<ie.length-1;++F)ie[F]=Math.floor(ue/this.strides[F]),ue-=ie[F]*this.strides[F];return ie[ie.length-1]=ue,ie}get rank(){return this.shape.length}toTensor(){return p().makeTensor(this.values,this.shape,this.dtype)}}let p=null,y=null,W=null;function L(ve){p=ve}function R(ve){y=ve}function K(ve){W=ve}class re{constructor(ue,ie,F,P){this.kept=false,this.isDisposedInternal=false,this.shape=ue.slice(),this.dtype=ie||"float32",this.size=n.NA(ue),this.strides=(0,n.e3)(ue),this.dataId=F,this.id=P,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const ue=await this.data();return y.buffer(this.shape,this.dtype,ue)}bufferSync(){return y.buffer(this.shape,this.dtype,this.dataSync())}async array(){const ue=await this.data();return(0,n.GX)(this.shape,ue,"complex64"===this.dtype)}arraySync(){return(0,n.GX)(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const ue=p().read(this.dataId);if("string"===this.dtype){const ie=await ue;try{return ie.map(F=>T.decodeString(F))}catch(F){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return ue}dataSync(){this.throwIfDisposed();const ue=p().readSync(this.dataId);if("string"===this.dtype)try{return ue.map(ie=>T.decodeString(ie))}catch(ie){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return ue}async bytes(){this.throwIfDisposed();const ue=await p().read(this.dataId);return"string"===this.dtype?ue:new Uint8Array(ue.buffer)}dispose(){this.isDisposed||(p().disposeTensor(this),this.isDisposedInternal=true)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(ue=false){return y.print(this,ue)}clone(){return this.throwIfDisposed(),y.clone(this)}toString(ue=false){return h(this.dataSync(),this.shape,this.dtype,ue)}cast(ue){return this.throwIfDisposed(),y.cast(this,ue)}variable(ue=true,ie,F){return this.throwIfDisposed(),p().makeVariable(this,ue,ie,F)}}Object.defineProperty(re,Symbol.hasInstance,{value:ve=>!!ve&&null!=ve.data&&null!=ve.dataSync&&null!=ve.throwIfDisposed}),(0,g.R)("Tensor",()=>re);class J extends re{constructor(ue,ie,F,P){super(ue.shape,ue.dtype,ue.dataId,P),this.trainable=ie,this.name=F}assign(ue){if(ue.dtype!==this.dtype)throw new Error(`dtype of the new value (${ue.dtype}) and previous value (${this.dtype}) must match`);if(!n.cO(ue.shape,this.shape))throw new Error(`shape of the new value (${ue.shape}) and previous value (${this.shape}) must match`);p().disposeTensor(this),this.dataId=ue.dataId,p().incRef(this,null)}dispose(){p().disposeVariable(this),this.isDisposedInternal=true}}Object.defineProperty(J,Symbol.hasInstance,{value:ve=>ve instanceof re&&null!=ve.assign&&ve.assign instanceof Function})},747:(b,u,e)=>{e.r(u),e.d(u,{makeTypesMatch:()=>i,assertTypesMatch:()=>w,isTensorInList:()=>k,getTensorsInContainer:()=>I});var g=e(4077),n=e(1221),h=e(569);function i(c,p){if(c.dtype===p.dtype)return[c,p];const y=(0,n.x8)(c.dtype,p.dtype);return[c.cast(y),p.cast(y)]}function w(c,p){(0,h.hu)(c.dtype===p.dtype,()=>`The dtypes of the first(${c.dtype}) and second(${p.dtype}) input must match`)}function k(c,p){return p.some(y=>y.id===c.id)}function I(c){const p=[];return T(c,p,new Set),p}function T(c,p,y){if(null==c)return;if(c instanceof g.es)return void p.push(c);if(W=c,!Array.isArray(W)&&"object"!=typeof W)return;var W;const L=c;for(const R in L){const K=L[R];y.has(K)||(y.add(K),T(K,p,y))}}},3740:(b,u,e)=>{e.d(u,{C:()=>k,_1:()=>c,sI:()=>p});var g=e(7097),n=e(2885),h=e(4077),i=e(569),w=e(9122);function k(y,W){let L=y;if((0,i.fU)(y))return"string"===W?[]:[y.length];if(!Array.isArray(y))return[];const R=[];for(;Array.isArray(L)||(0,i.fU)(L)&&"string"!==W;)R.push(L.length),L=L[0];return Array.isArray(y)&&(0,n.OB)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&I(y,R,[]),R}function I(y,W,L){if(L=L||[],!Array.isArray(y)&&!(0,i.fU)(y))return void(0,i.hu)(0===W.length,()=>`Element arr[${L.join("][")}] is a primitive, but should be an array/TypedArray of ${W[0]} elements`);(0,i.hu)(W.length>0,()=>`Element arr[${L.join("][")}] should be a primitive, but is an array of ${y.length} elements`),(0,i.hu)(y.length===W[0],()=>`Element arr[${L.join("][")}] should have ${W[0]} elements, but has ${y.length} elements`);const R=W.slice(1);for(let K=0;K<y.length;++K)I(y[K],R,L.concat(K))}function T(y,W,L,R){if("string_or_numeric"!==y){if(null==y)throw new Error("Expected dtype cannot be null.");if("numeric"!==y&&y!==W||"numeric"===y&&"string"===W)throw new Error(`Argument '${L}' passed to '${R}' must be ${y} tensor, but got ${W} tensor`)}}function c(y,W,L,R="numeric"){if(y instanceof h.es)return T(R,y.dtype,W,L),y;let K=(0,i.D2)(y);if("string"!==K&&["bool","int32","float32"].indexOf(R)>=0&&(K=R),T(R,K,W,L),null==y||!(0,i.fU)(y)&&!Array.isArray(y)&&"number"!=typeof y&&"boolean"!=typeof y&&"string"!=typeof y){const ve=null==y?"null":y.constructor.name;throw new Error(`Argument '${W}' passed to '${L}' must be a Tensor or TensorLike, but got '${ve}'`)}const re=k(y,K);(0,i.fU)(y)||Array.isArray(y)||(y=[y]);const J="string"!==K?(0,w.toTypedArray)(y,K):(0,i.xH)(y,[],true);return g.BV.makeTensor(J,re,K)}function p(y,W,L,R="numeric"){if(!Array.isArray(y))throw new Error(`Argument ${W} passed to ${L} must be a \`Tensor[]\` or \`TensorLike[]\``);return y.map((K,re)=>c(K,`${W}[${re}]`,L,R))}},1221:(b,u,e)=>{var g,n,h,i,w;e.d(u,{yw:()=>g,x8:()=>I,z4:()=>T}),function(c){c.R0="R0",c.R1="R1",c.R2="R2",c.R3="R3",c.R4="R4",c.R5="R5",c.R6="R6"}(g||(g={})),function(c){c.float32="float32",c.int32="int32",c.bool="int32",c.complex64="complex64"}(n||(n={})),function(c){c.float32="float32",c.int32="int32",c.bool="bool",c.complex64="complex64"}(h||(h={})),function(c){c.float32="float32",c.int32="float32",c.bool="float32",c.complex64="complex64"}(i||(i={})),function(c){c.float32="complex64",c.int32="complex64",c.bool="complex64",c.complex64="complex64"}(w||(w={}));const k={float32:i,int32:n,bool:h,complex64:w};function I(c,p){if("string"===c||"string"===p){if("string"===c&&"string"===p)return"string";throw new Error(`Can not upcast ${c} with ${p}`)}return k[c][p]}function T(c){return I(c,"int32")}},9122:(b,u,e)=>{e.r(u),e.d(u,{arraysEqual:()=>n.cO,assert:()=>n.hu,assertNonNegativeIntegerDimensions:()=>n.Mu,assertNonNull:()=>n.Cq,assertShapesMatch:()=>n.k5,bytesFromStringArray:()=>n.Ub,bytesPerElement:()=>n.bT,checkConversionForErrors:()=>n.D5,clamp:()=>n.uZ,computeStrides:()=>n.e3,createScalarValue:()=>J,createShuffledIndices:()=>n.U$,decodeString:()=>P,distSquared:()=>n.E7,encodeString:()=>F,fetch:()=>ie,fingerPrint64:()=>re,flatten:()=>n.xH,getArrayFromDType:()=>n.rQ,getTypedArrayFromDType:()=>n.WP,hasEncodingLoss:()=>n.QB,hexToLong:()=>w,indexToLoc:()=>n.NE,inferDtype:()=>n.D2,inferFromImplicitShape:()=>n.JZ,isBoolean:()=>n.jn,isFunction:()=>n.mf,isInt:()=>n.GN,isNumber:()=>n.hj,isPromise:()=>n.tI,isScalarShape:()=>n.N9,isString:()=>n.HD,isTypedArray:()=>n.fU,isValidDtype:()=>n.LP,locToIndex:()=>n.qy,makeOnesTypedArray:()=>n.p8,makeZerosNestedTypedArray:()=>n.l6,makeZerosTypedArray:()=>n.wT,nearestDivisor:()=>n.jP,nearestLargerEven:()=>n.nY,now:()=>ue,parseAxisParam:()=>n.EC,randUniform:()=>n.bj,repeatedTry:()=>n.WD,rightPad:()=>n.oj,shuffle:()=>n.TV,shuffleCombo:()=>n.d7,sizeFromShape:()=>n.NA,sizeToSquarishShape:()=>n.YP,squeezeShape:()=>n.bp,sum:()=>n.Sm,swap:()=>n.LF,tanh:()=>n.AE,toNestedArray:()=>n.GX,toTypedArray:()=>ve});var g=e(2885),n=e(569),h=e(3720);const i=e.n(h)()||h;function w(f){return i.fromString(f,true,16)}const k=w("c3a5c85c97cb3127"),I=w("b492b66fbe98f273"),T=w("9ae16a3b2f90404f");function c(f){return f.xor(f.shru(47))}function p(f,Q,oe){const se=f.slice(Q,Q+oe);return i.fromBytes(Array.from(se),true,true)}function y(f,Q){return p(f,Q,8)}function W(f,Q){return p(f,Q,4)}function L(f,Q){return 0===Q?f:f.shru(Q).or(f.shl(64-Q))}function R(f,Q,oe=w("9ddfea08eb382d69")){let se=f.xor(Q).mul(oe);se=se.xor(se.shru(47));let o=Q.xor(se).mul(oe);return o=o.xor(o.shru(47)),o=o.mul(oe),o}function K(f,Q,oe,se){return function(o,te,De,Ve,ze,Ke){ze=ze.add(o),Ke=L(Ke.add(ze).add(Ve),21);const Ye=ze;return ze=(ze=ze.add(te)).add(De),Ke=Ke.add(L(ze,44)),[ze.add(Ve),Ke.add(Ye)]}(y(f,Q),y(f,Q+8),y(f,Q+16),y(f,Q+24),oe,se)}function re(f,Q=f.length){const oe=i.fromNumber(81,true);if(Q<=32)return Q<=16?function(Qe,tt=Qe.length){if(tt>=8){const Nt=T.add(2*tt),$t=y(Qe,0).add(T),Ct=y(Qe,tt-8);return R(L(Ct,37).mul(Nt).add($t),L($t,25).add(Ct).mul(Nt),Nt)}if(tt>=4){const Nt=T.add(2*tt);return R(W(Qe,0).shl(3).add(tt),W(Qe,tt-4),Nt)}if(tt>0){const Nt=Qe[0]+(Qe[tt>>1]<<8),$t=tt+(Qe[tt-1]<<2);return c(T.mul(Nt).xor(k.mul($t))).mul(T)}return T}(f,Q):function(Qe,tt=Qe.length){const Nt=T.add(2*tt),$t=y(Qe,0).mul(I),Ct=y(Qe,8),Ot=y(Qe,tt-8).mul(Nt),zt=y(Qe,tt-16).mul(T);return R(L($t.add(Ct),43).add(L(Ot,30)).add(zt),$t.add(L(Ct.add(T),18)).add(Ot),Nt)}(f,Q);if(Q<=64)return function(Qe,tt=Qe.length){const Nt=T.add(2*tt),$t=y(Qe,0).mul(T),Ct=y(Qe,8),Ot=y(Qe,tt-8).mul(Nt),zt=y(Qe,tt-16).mul(T),Ht=L($t.add(Ct),43).add(L(Ot,30)).add(zt),tn=R(Ht,$t.add(L(Ct.add(T),18)).add(Ot),Nt),qt=y(Qe,16).mul(Nt),Ut=y(Qe,24),Wt=Ht.add(y(Qe,tt-32)).mul(Nt),Be=tn.add(y(Qe,tt-24)).mul(Nt);return R(L(qt.add(Ut),43).add(L(Wt,30)).add(Be),qt.add(L(Ut.add($t),18)).add(Wt),Nt)}(f,Q);let se=oe,o=oe.mul(I).add(113),te=c(o.mul(T).add(113)).mul(T),De=[i.UZERO,i.UZERO],Ve=[i.UZERO,i.UZERO];se=se.mul(T).add(y(f,0));let ze=0;const Ke=64*(Q-1>>6),Ye=Ke+(Q-1&63)-63;do{se=L(se.add(o).add(De[0]).add(y(f,ze+8)),37).mul(I),o=L(o.add(De[1]).add(y(f,ze+48)),42).mul(I),se=se.xor(Ve[1]),o=o.add(De[0]).add(y(f,ze+40)),te=L(te.add(Ve[0]),33).mul(I),De=K(f,ze,De[1].mul(I),se.add(Ve[0])),Ve=K(f,ze+32,te.add(Ve[1]),o.add(y(f,ze+16))),[te,se]=[se,te],ze+=64}while(ze!==Ke);const rt=I.add(te.and(255).shl(1));return ze=Ye,Ve[0]=Ve[0].add(Q-1&63),De[0]=De[0].add(Ve[0]),Ve[0]=Ve[0].add(De[0]),se=L(se.add(o).add(De[0]).add(y(f,ze+8)),37).mul(rt),o=L(o.add(De[1]).add(y(f,ze+48)),42).mul(rt),se=se.xor(Ve[1].mul(9)),o=o.add(De[0].mul(9).add(y(f,ze+40))),te=L(te.add(Ve[0]),33).mul(rt),De=K(f,ze,De[1].mul(rt),se.add(Ve[0])),Ve=K(f,ze+32,te.add(Ve[1]),o.add(y(f,ze+16))),[te,se]=[se,te],R(R(De[0],Ve[0],rt).add(c(o).mul(k)).add(te),R(De[1],Ve[1],rt).add(se),rt)}function J(f,Q){return"string"===Q?F(f):ve([f],Q)}function ve(f,Q){if("string"===Q)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(f)&&(f=n.xH(f)),(0,g.OB)().getBool("DEBUG")&&n.D5(f,Q),function(oe,se){return oe instanceof Float32Array&&"float32"===se||oe instanceof Int32Array&&"int32"===se||oe instanceof Uint8Array&&"bool"===se}(f,Q))return f;if(null==Q||"float32"===Q||"complex64"===Q)return new Float32Array(f);if("int32"===Q)return new Int32Array(f);if("bool"===Q){const oe=new Uint8Array(f.length);for(let se=0;se<oe.length;++se)0!==Math.round(f[se])&&(oe[se]=1);return oe}throw new Error(`Unknown data type ${Q}`)}function ue(){return(0,g.OB)().platform.now()}function ie(f,Q){return(0,g.OB)().platform.fetch(f,Q)}function F(f,Q="utf-8"){return Q=Q||"utf-8",(0,g.OB)().platform.encode(f,Q)}function P(f,Q="utf-8"){return Q=Q||"utf-8",(0,g.OB)().platform.decode(f,Q)}},569:(b,u,e)=>{function g(Y){let be=Y.length,ke=0;for(;be>0;)ke=Math.random()*be|0,be--,w(Y,be,ke)}function n(Y,be){if(Y.length!==be.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${Y.length}Second array length was ${be.length}`);let ke=Y.length,We=0;for(;ke>0;)We=Math.random()*ke|0,ke--,w(Y,ke,We),w(be,ke,We)}function h(Y,be,ke){return Math.max(Y,Math.min(be,ke))}function i(Y){return Y%2==0?Y:Y+1}function w(Y,be,ke){const We=Y[be];Y[be]=Y[ke],Y[ke]=We}function k(Y){let be=0;for(let ke=0;ke<Y.length;ke++)be+=Y[ke];return be}function I(Y,be){const ke=Math.random();return be*ke+(1-ke)*Y}function T(Y,be){let ke=0;for(let We=0;We<Y.length;We++){const yt=Number(Y[We])-Number(be[We]);ke+=yt*yt}return ke}function c(Y,be){if(!Y)throw new Error("string"==typeof be?be:be())}function p(Y,be,ke=""){c(K(Y,be),()=>ke+` Shapes ${Y} and ${be} must match`)}function y(Y){c(null!=Y,()=>"The input to the tensor constructor must be a non-null value.")}function W(Y,be=[],ke=false){if(null==be&&(be=[]),Array.isArray(Y)||Ve(Y)&&!ke)for(let We=0;We<Y.length;++We)W(Y[We],be,ke);else be.push(Y);return be}function L(Y){if(0===Y.length)return 1;let be=Y[0];for(let ke=1;ke<Y.length;ke++)be*=Y[ke];return be}function R(Y){return 0===Y.length}function K(Y,be){if(Y===be)return true;if(null==Y||null==be)return false;if(Y.length!==be.length)return false;for(let ke=0;ke<Y.length;ke++)if(Y[ke]!==be[ke])return false;return true}function re(Y){return Y%1==0}function J(Y){if(null!=Math.tanh)return Math.tanh(Y);if(Y===1/0)return 1;if(Y===-1/0)return-1;{const be=Math.exp(2*Y);return(be-1)/(be+1)}}function ve(Y){const be=Math.ceil(Math.sqrt(Y));return[be,Math.ceil(Y/be)]}function ue(Y){const be=new Uint32Array(Y);for(let ke=0;ke<Y;++ke)be[ke]=ke;return g(be),be}function ie(Y,be){return be<=Y.length?Y:Y+" ".repeat(be-Y.length)}function F(Y,be=We=>0,ke){return new Promise((We,yt)=>{let _t=0;const dt=()=>{if(Y())return void We();_t++;const Ft=be(_t);null!=ke&&_t>=ke?yt():setTimeout(dt,Ft)};dt()})}function P(Y,be){let ke=1,We=-1;for(let _t=0;_t<Y.length;++_t)if(Y[_t]>=0)ke*=Y[_t];else if(-1===Y[_t]){if(-1!==We)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${We} and dim ${_t}`);We=_t}else if(Y[_t]<0)throw Error(`Shapes can not be < 0. Found ${Y[_t]} at dim ${_t}`);if(-1===We){if(be>0&&be!==ke)throw Error(`Size(${be}) must match the product of shape ${Y}`);return Y}if(0===ke)throw Error(`Cannot infer the missing size in [${Y}] when there are 0 elements`);if(be%ke!=0)throw Error(`The implicit shape can't be a fractional number. Got ${be} / ${ke}`);const yt=Y.slice();return yt[We]=be/ke,yt}function f(Y,be){const ke=be.length;return c((Y=null==Y?be.map((We,yt)=>yt):[].concat(Y)).every(We=>We>=-ke&&We<ke),()=>`All values in axis param must be in range [-${ke}, ${ke}) but got axis ${Y}`),c(Y.every(We=>re(We)),()=>`All values in axis param must be integers but got axis ${Y}`),Y.map(We=>We<0?ke+We:We)}function Q(Y,be){const ke=[],We=[],yt=null!=be&&Array.isArray(be)&&0===be.length,_t=null==be||yt?null:f(be,Y).sort();let dt=0;for(let Ft=0;Ft<Y.length;++Ft){if(null!=_t){if(_t[dt]===Ft&&1!==Y[Ft])throw new Error(`Can't squeeze axis ${Ft} since its dim '${Y[Ft]}' is not 1`);(null==_t[dt]||_t[dt]>Ft)&&1===Y[Ft]&&(ke.push(Y[Ft]),We.push(Ft)),_t[dt]<=Ft&&dt++}1!==Y[Ft]&&(ke.push(Y[Ft]),We.push(Ft))}return{newShape:ke,keptDims:We}}function oe(Y,be){let ke=null;if(null==Y||"float32"===Y)ke=new Float32Array(be);else if("int32"===Y)ke=new Int32Array(be);else{if("bool"!==Y)throw new Error(`Unknown data type ${Y}`);ke=new Uint8Array(be)}return ke}function se(Y,be){let ke=null;if(null==Y||"float32"===Y)ke=new Float32Array(be);else if("int32"===Y)ke=new Int32Array(be);else if("bool"===Y)ke=new Uint8Array(be);else{if("string"!==Y)throw new Error(`Unknown data type ${Y}`);ke=new Array(be)}return ke}function o(Y,be){for(let ke=0;ke<Y.length;ke++){const We=Y[ke];if(isNaN(We)||!isFinite(We))throw Error(`A tensor of type ${be} being uploaded contains ${We}.`)}}function te(Y){return"bool"===Y||"complex64"===Y||"float32"===Y||"int32"===Y||"string"===Y}function De(Y,be){return"complex64"!==be&&(("float32"!==be||"complex64"===Y)&&(("int32"!==be||"float32"===Y||"complex64"===Y)&&("bool"!==be||"bool"!==Y)))}function Ve(Y){return Y instanceof Float32Array||Y instanceof Int32Array||Y instanceof Uint8Array}function ze(Y){if("float32"===Y||"int32"===Y)return 4;if("complex64"===Y)return 8;if("bool"===Y)return 1;throw new Error(`Unknown dtype ${Y}`)}function Ke(Y){if(null==Y)return 0;let be=0;return Y.forEach(ke=>be+=ke.length),be}function Ye(Y){return"string"==typeof Y||Y instanceof String}function rt(Y){return"boolean"==typeof Y}function Qe(Y){return"number"==typeof Y}function tt(Y){return Array.isArray(Y)?tt(Y[0]):Y instanceof Float32Array?"float32":Y instanceof Int32Array||Y instanceof Uint8Array?"int32":Qe(Y)?"float32":Ye(Y)?"string":rt(Y)?"bool":"float32"}function Nt(Y){return!!(Y&&Y.constructor&&Y.call&&Y.apply)}function $t(Y,be){for(let ke=be;ke<Y;++ke)if(Y%ke==0)return ke;return Y}function Ct(Y){const be=Y.length;if(be<2)return[];const ke=new Array(be-1);ke[be-2]=Y[be-1];for(let We=be-3;We>=0;--We)ke[We]=ke[We+1]*Y[We+1];return ke}function Ot(Y,be,ke,We=false){const yt=new Array;if(1===be.length){const _t=be[0]*(We?2:1);for(let dt=0;dt<_t;dt++)yt[dt]=ke[Y+dt]}else{const _t=be[0],dt=be.slice(1),Ft=dt.reduce((Yt,fn)=>Yt*fn)*(We?2:1);for(let Yt=0;Yt<_t;Yt++)yt[Yt]=Ot(Y+Yt*Ft,dt,ke,We)}return yt}function zt(Y,be,ke=false){if(0===Y.length)return be[0];const We=Y.reduce((yt,_t)=>yt*_t)*(ke?2:1);if(0===We)return[];if(We!==be.length)throw new Error(`[${Y}] does not match the input size ${be.length}${ke?" for a complex tensor":""}.`);return Ot(0,Y,be,ke)}function Ht(Y,be){const ke=tn(Y,be);for(let We=0;We<ke.length;We++)ke[We]=1;return ke}function tn(Y,be){if(null==be||"float32"===be||"complex64"===be)return new Float32Array(Y);if("int32"===be)return new Int32Array(Y);if("bool"===be)return new Uint8Array(Y);throw new Error(`Unknown data type ${be}`)}function qt(Y,be){const ke=Y.reduce((We,yt)=>We*yt,1);if(null==be||"float32"===be)return zt(Y,new Float32Array(ke));if("int32"===be)return zt(Y,new Int32Array(ke));if("bool"===be)return zt(Y,new Uint8Array(ke));throw new Error(`Unknown data type ${be}`)}function Ut(Y){Y.forEach(be=>{c(Number.isInteger(be)&&be>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${Y}].`)})}function Wt(Y,be,ke){if(0===be)return 0;if(1===be)return Y[0];let We=Y[Y.length-1];for(let yt=0;yt<Y.length-1;++yt)We+=ke[yt]*Y[yt];return We}function Be(Y,be,ke){if(0===be)return[];if(1===be)return[Y];const We=new Array(be);for(let yt=0;yt<We.length-1;++yt)We[yt]=Math.floor(Y/ke[yt]),Y-=We[yt]*ke[yt];return We[We.length-1]=Y,We}function Fe(Y){return Y&&Y.then&&"function"==typeof Y.then}e.d(u,{TV:()=>g,d7:()=>n,uZ:()=>h,nY:()=>i,LF:()=>w,Sm:()=>k,bj:()=>I,E7:()=>T,hu:()=>c,k5:()=>p,Cq:()=>y,xH:()=>W,NA:()=>L,N9:()=>R,cO:()=>K,GN:()=>re,AE:()=>J,YP:()=>ve,U$:()=>ue,oj:()=>ie,WD:()=>F,JZ:()=>P,EC:()=>f,bp:()=>Q,WP:()=>oe,rQ:()=>se,D5:()=>o,LP:()=>te,QB:()=>De,fU:()=>Ve,bT:()=>ze,Ub:()=>Ke,HD:()=>Ye,jn:()=>rt,hj:()=>Qe,D2:()=>tt,mf:()=>Nt,jP:()=>$t,e3:()=>Ct,GX:()=>zt,p8:()=>Ht,wT:()=>tn,l6:()=>qt,Mu:()=>Ut,qy:()=>Wt,NE:()=>Be,tI:()=>Fe})},3720:b=>{b.exports=e;var u=null;try{u=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(f){}function e(f,Q,oe){this.low=0|f,this.high=0|Q,this.unsigned=!!oe}function g(f){return true===(f&&f.__isLong__)}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:true}),e.isLong=g;var n={},h={};function i(f,Q){var oe,se,o;return Q?(o=0<=(f>>>=0)&&f<256)&&(se=h[f])?se:(oe=k(f,(0|f)<0?-1:0,true),o&&(h[f]=oe),oe):(o=-128<=(f|=0)&&f<128)&&(se=n[f])?se:(oe=k(f,f<0?-1:0,false),o&&(n[f]=oe),oe)}function w(f,Q){if(isNaN(f))return Q?K:R;if(Q){if(f<0)return K;if(f>=y)return ie}else{if(f<=-W)return F;if(f+1>=W)return ue}return f<0?w(-f,Q).neg():k(f%p|0,f/p|0,Q)}function k(f,Q,oe){return new e(f,Q,oe)}e.fromInt=i,e.fromNumber=w,e.fromBits=k;var I=Math.pow;function T(f,Q,oe){if(0===f.length)throw Error("empty string");if("NaN"===f||"Infinity"===f||"+Infinity"===f||"-Infinity"===f)return R;if("number"==typeof Q?(oe=Q,Q=false):Q=!!Q,(oe=oe||10)<2||36<oe)throw RangeError("radix");var se;if((se=f.indexOf("-"))>0)throw Error("interior hyphen");if(0===se)return T(f.substring(1),Q,oe).neg();for(var o=w(I(oe,8)),te=R,De=0;De<f.length;De+=8){var Ve=Math.min(8,f.length-De),ze=parseInt(f.substring(De,De+Ve),oe);if(Ve<8){var Ke=w(I(oe,Ve));te=te.mul(Ke).add(w(ze))}else te=(te=te.mul(o)).add(w(ze))}return te.unsigned=Q,te}function c(f,Q){return"number"==typeof f?w(f,Q):"string"==typeof f?T(f,Q):k(f.low,f.high,"boolean"==typeof Q?Q:f.unsigned)}e.fromString=T,e.fromValue=c;var p=4294967296,y=p*p,W=y/2,L=i(1<<24),R=i(0);e.ZERO=R;var K=i(0,true);e.UZERO=K;var re=i(1);e.ONE=re;var J=i(1,true);e.UONE=J;var ve=i(-1);e.NEG_ONE=ve;var ue=k(-1,2147483647,false);e.MAX_VALUE=ue;var ie=k(-1,-1,true);e.MAX_UNSIGNED_VALUE=ie;var F=k(0,-2147483648,false);e.MIN_VALUE=F;var P=e.prototype;P.toInt=function(){return this.unsigned?this.low>>>0:this.low},P.toNumber=function(){return this.unsigned?(this.high>>>0)*p+(this.low>>>0):this.high*p+(this.low>>>0)},P.toString=function(f){if((f=f||10)<2||36<f)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(F)){var Q=w(f),oe=this.div(Q),se=oe.mul(Q).sub(this);return oe.toString(f)+se.toInt().toString(f)}return"-"+this.neg().toString(f)}for(var o=w(I(f,6),this.unsigned),te=this,De="";;){var Ve=te.div(o),ze=(te.sub(Ve.mul(o)).toInt()>>>0).toString(f);if((te=Ve).isZero())return ze+De;for(;ze.length<6;)ze="0"+ze;De=""+ze+De}},P.getHighBits=function(){return this.high},P.getHighBitsUnsigned=function(){return this.high>>>0},P.getLowBits=function(){return this.low},P.getLowBitsUnsigned=function(){return this.low>>>0},P.getNumBitsAbs=function(){if(this.isNegative())return this.eq(F)?64:this.neg().getNumBitsAbs();for(var f=0!=this.high?this.high:this.low,Q=31;Q>0&&0==(f&1<<Q);Q--);return 0!=this.high?Q+33:Q+1},P.isZero=function(){return 0===this.high&&0===this.low},P.eqz=P.isZero,P.isNegative=function(){return!this.unsigned&&this.high<0},P.isPositive=function(){return this.unsigned||this.high>=0},P.isOdd=function(){return 1==(1&this.low)},P.isEven=function(){return 0==(1&this.low)},P.equals=function(f){return g(f)||(f=c(f)),(this.unsigned===f.unsigned||this.high>>>31!=1||f.high>>>31!=1)&&(this.high===f.high&&this.low===f.low)},P.eq=P.equals,P.notEquals=function(f){return!this.eq(f)},P.neq=P.notEquals,P.ne=P.notEquals,P.lessThan=function(f){return this.comp(f)<0},P.lt=P.lessThan,P.lessThanOrEqual=function(f){return this.comp(f)<=0},P.lte=P.lessThanOrEqual,P.le=P.lessThanOrEqual,P.greaterThan=function(f){return this.comp(f)>0},P.gt=P.greaterThan,P.greaterThanOrEqual=function(f){return this.comp(f)>=0},P.gte=P.greaterThanOrEqual,P.ge=P.greaterThanOrEqual,P.compare=function(f){if(g(f)||(f=c(f)),this.eq(f))return 0;var Q=this.isNegative(),oe=f.isNegative();return Q&&!oe?-1:!Q&&oe?1:this.unsigned?f.high>>>0>this.high>>>0||f.high===this.high&&f.low>>>0>this.low>>>0?-1:1:this.sub(f).isNegative()?-1:1},P.comp=P.compare,P.negate=function(){return!this.unsigned&&this.eq(F)?F:this.not().add(re)},P.neg=P.negate,P.add=function(f){g(f)||(f=c(f));var Q=this.high>>>16,oe=65535&this.high,se=this.low>>>16,o=65535&this.low,te=f.high>>>16,De=65535&f.high,Ve=f.low>>>16,ze=0,Ke=0,Ye=0,rt=0;return Ye+=(rt+=o+(65535&f.low))>>>16,Ke+=(Ye+=se+Ve)>>>16,ze+=(Ke+=oe+De)>>>16,ze+=Q+te,k((Ye&=65535)<<16|(rt&=65535),(ze&=65535)<<16|(Ke&=65535),this.unsigned)},P.subtract=function(f){return g(f)||(f=c(f)),this.add(f.neg())},P.sub=P.subtract,P.multiply=function(f){if(this.isZero())return R;if(g(f)||(f=c(f)),u)return k(u.mul(this.low,this.high,f.low,f.high),u.get_high(),this.unsigned);if(f.isZero())return R;if(this.eq(F))return f.isOdd()?F:R;if(f.eq(F))return this.isOdd()?F:R;if(this.isNegative())return f.isNegative()?this.neg().mul(f.neg()):this.neg().mul(f).neg();if(f.isNegative())return this.mul(f.neg()).neg();if(this.lt(L)&&f.lt(L))return w(this.toNumber()*f.toNumber(),this.unsigned);var Q=this.high>>>16,oe=65535&this.high,se=this.low>>>16,o=65535&this.low,te=f.high>>>16,De=65535&f.high,Ve=f.low>>>16,ze=65535&f.low,Ke=0,Ye=0,rt=0,Qe=0;return rt+=(Qe+=o*ze)>>>16,Ye+=(rt+=se*ze)>>>16,rt&=65535,Ye+=(rt+=o*Ve)>>>16,Ke+=(Ye+=oe*ze)>>>16,Ye&=65535,Ke+=(Ye+=se*Ve)>>>16,Ye&=65535,Ke+=(Ye+=o*De)>>>16,Ke+=Q*ze+oe*Ve+se*De+o*te,k((rt&=65535)<<16|(Qe&=65535),(Ke&=65535)<<16|(Ye&=65535),this.unsigned)},P.mul=P.multiply,P.divide=function(f){if(g(f)||(f=c(f)),f.isZero())throw Error("division by zero");var Q,oe,se;if(u)return this.unsigned||-2147483648!==this.high||-1!==f.low||-1!==f.high?k((this.unsigned?u.div_u:u.div_s)(this.low,this.high,f.low,f.high),u.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?K:R;if(this.unsigned){if(f.unsigned||(f=f.toUnsigned()),f.gt(this))return K;if(f.gt(this.shru(1)))return J;se=K}else{if(this.eq(F))return f.eq(re)||f.eq(ve)?F:f.eq(F)?re:(Q=this.shr(1).div(f).shl(1)).eq(R)?f.isNegative()?re:ve:(oe=this.sub(f.mul(Q)),se=Q.add(oe.div(f)));if(f.eq(F))return this.unsigned?K:R;if(this.isNegative())return f.isNegative()?this.neg().div(f.neg()):this.neg().div(f).neg();if(f.isNegative())return this.div(f.neg()).neg();se=R}for(oe=this;oe.gte(f);){Q=Math.max(1,Math.floor(oe.toNumber()/f.toNumber()));for(var o=Math.ceil(Math.log(Q)/Math.LN2),te=o<=48?1:I(2,o-48),De=w(Q),Ve=De.mul(f);Ve.isNegative()||Ve.gt(oe);)Ve=(De=w(Q-=te,this.unsigned)).mul(f);De.isZero()&&(De=re),se=se.add(De),oe=oe.sub(Ve)}return se},P.div=P.divide,P.modulo=function(f){return g(f)||(f=c(f)),u?k((this.unsigned?u.rem_u:u.rem_s)(this.low,this.high,f.low,f.high),u.get_high(),this.unsigned):this.sub(this.div(f).mul(f))},P.mod=P.modulo,P.rem=P.modulo,P.not=function(){return k(~this.low,~this.high,this.unsigned)},P.and=function(f){return g(f)||(f=c(f)),k(this.low&f.low,this.high&f.high,this.unsigned)},P.or=function(f){return g(f)||(f=c(f)),k(this.low|f.low,this.high|f.high,this.unsigned)},P.xor=function(f){return g(f)||(f=c(f)),k(this.low^f.low,this.high^f.high,this.unsigned)},P.shiftLeft=function(f){return g(f)&&(f=f.toInt()),0==(f&=63)?this:f<32?k(this.low<<f,this.high<<f|this.low>>>32-f,this.unsigned):k(0,this.low<<f-32,this.unsigned)},P.shl=P.shiftLeft,P.shiftRight=function(f){return g(f)&&(f=f.toInt()),0==(f&=63)?this:f<32?k(this.low>>>f|this.high<<32-f,this.high>>f,this.unsigned):k(this.high>>f-32,this.high>=0?0:-1,this.unsigned)},P.shr=P.shiftRight,P.shiftRightUnsigned=function(f){if(g(f)&&(f=f.toInt()),0===(f&=63))return this;var Q=this.high;return f<32?k(this.low>>>f|Q<<32-f,Q>>>f,this.unsigned):k(32===f?Q:Q>>>f-32,0,this.unsigned)},P.shru=P.shiftRightUnsigned,P.shr_u=P.shiftRightUnsigned,P.toSigned=function(){return this.unsigned?k(this.low,this.high,false):this},P.toUnsigned=function(){return this.unsigned?this:k(this.low,this.high,true)},P.toBytes=function(f){return f?this.toBytesLE():this.toBytesBE()},P.toBytesLE=function(){var f=this.high,Q=this.low;return[255&Q,Q>>>8&255,Q>>>16&255,Q>>>24,255&f,f>>>8&255,f>>>16&255,f>>>24]},P.toBytesBE=function(){var f=this.high,Q=this.low;return[f>>>24,f>>>16&255,f>>>8&255,255&f,Q>>>24,Q>>>16&255,Q>>>8&255,255&Q]},e.fromBytes=function(f,Q,oe){return oe?e.fromBytesLE(f,Q):e.fromBytesBE(f,Q)},e.fromBytesLE=function(f,Q){return new e(f[0]|f[1]<<8|f[2]<<16|f[3]<<24,f[4]|f[5]<<8|f[6]<<16|f[7]<<24,Q)},e.fromBytesBE=function(f,Q){return new e(f[4]<<24|f[5]<<16|f[6]<<8|f[7],f[0]<<24|f[1]<<16|f[2]<<8|f[3],Q)}},7854:(b,u,e)=>{e.r(u),e.d(u,{FetchError:()=>p,Headers:()=>o,Request:()=>zt,Response:()=>Qe,default:()=>Wt});const g=Ia,n=Ia,h=Ia,i=Ia,w=Ia,k=g.Readable,I=Symbol("buffer"),T=Symbol("type");class c{constructor(){this[T]="";const Fe=arguments[0],Y=arguments[1],be=[];let ke=0;if(Fe){const yt=Fe,_t=Number(yt.length);for(let dt=0;dt<_t;dt++){const Ft=yt[dt];let Yt;Yt=Ft instanceof Buffer?Ft:ArrayBuffer.isView(Ft)?Buffer.from(Ft.buffer,Ft.byteOffset,Ft.byteLength):Ft instanceof ArrayBuffer?Buffer.from(Ft):Ft instanceof c?Ft[I]:Buffer.from("string"==typeof Ft?Ft:String(Ft)),ke+=Yt.length,be.push(Yt)}}this[I]=Buffer.concat(be);let We=Y&&void 0!==Y.type&&String(Y.type).toLowerCase();We&&!/[^\u0020-\u007E]/.test(We)&&(this[T]=We)}get size(){return this[I].length}get type(){return this[T]}text(){return Promise.resolve(this[I].toString())}arrayBuffer(){const Fe=this[I],Y=Fe.buffer.slice(Fe.byteOffset,Fe.byteOffset+Fe.byteLength);return Promise.resolve(Y)}stream(){const Fe=new k;return Fe._read=function(){},Fe.push(this[I]),Fe.push(null),Fe}toString(){return"[object Blob]"}slice(){const Fe=this.size,Y=arguments[0],be=arguments[1];let ke,We;ke=void 0===Y?0:Y<0?Math.max(Fe+Y,0):Math.min(Y,Fe),We=void 0===be?Fe:be<0?Math.max(Fe+be,0):Math.min(be,Fe);const yt=Math.max(We-ke,0),_t=this[I].slice(ke,ke+yt),dt=new c([],{type:arguments[2]});return dt[I]=_t,dt}}function p(Be,Fe,Y){Error.call(this,Be),this.message=Be,this.type=Fe,Y&&(this.code=this.errno=Y.code),Error.captureStackTrace(this,this.constructor)}let y;Object.defineProperties(c.prototype,{size:{enumerable:true},type:{enumerable:true},slice:{enumerable:true}}),Object.defineProperty(c.prototype,Symbol.toStringTag,{value:"Blob",writable:false,enumerable:false,configurable:true}),p.prototype=Object.create(Error.prototype),p.prototype.constructor=p,p.prototype.name="FetchError";try{y=require("encoding").convert}catch(Be){}const W=Symbol("Body internals"),L=g.PassThrough;function R(Be){var Fe=this,Y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},be=Y.size;let ke=void 0===be?0:be;var We=Y.timeout;let yt=void 0===We?0:We;null==Be?Be=null:re(Be)?Be=Buffer.from(Be.toString()):J(Be)||Buffer.isBuffer(Be)||("[object ArrayBuffer]"===Object.prototype.toString.call(Be)?Be=Buffer.from(Be):ArrayBuffer.isView(Be)?Be=Buffer.from(Be.buffer,Be.byteOffset,Be.byteLength):Be instanceof g||(Be=Buffer.from(String(Be)))),this[W]={body:Be,disturbed:false,error:null},this.size=ke,this.timeout=yt,Be instanceof g&&Be.on("error",function(_t){const dt="AbortError"===_t.name?_t:new p(`Invalid response body while trying to fetch ${Fe.url}: ${_t.message}`,"system",_t);Fe[W].error=dt})}function K(){var Be=this;if(this[W].disturbed)return R.Promise.reject(new TypeError(`body used already for: ${this.url}`));if(this[W].disturbed=true,this[W].error)return R.Promise.reject(this[W].error);let Fe=this.body;if(null===Fe)return R.Promise.resolve(Buffer.alloc(0));if(J(Fe)&&(Fe=Fe.stream()),Buffer.isBuffer(Fe))return R.Promise.resolve(Fe);if(!(Fe instanceof g))return R.Promise.resolve(Buffer.alloc(0));let Y=[],be=0,ke=false;return new R.Promise(function(We,yt){let _t;Be.timeout&&(_t=setTimeout(function(){ke=true,yt(new p(`Response timeout while trying to fetch ${Be.url} (over ${Be.timeout}ms)`,"body-timeout"))},Be.timeout)),Fe.on("error",function(dt){"AbortError"===dt.name?(ke=true,yt(dt)):yt(new p(`Invalid response body while trying to fetch ${Be.url}: ${dt.message}`,"system",dt))}),Fe.on("data",function(dt){if(!ke&&null!==dt){if(Be.size&&be+dt.length>Be.size)return ke=true,void yt(new p(`content size at ${Be.url} over limit: ${Be.size}`,"max-size"));be+=dt.length,Y.push(dt)}}),Fe.on("end",function(){if(!ke){clearTimeout(_t);try{We(Buffer.concat(Y,be))}catch(dt){yt(new p(`Could not create Buffer from response body for ${Be.url}: ${dt.message}`,"system",dt))}}})})}function re(Be){return"object"==typeof Be&&"function"==typeof Be.append&&"function"==typeof Be.delete&&"function"==typeof Be.get&&"function"==typeof Be.getAll&&"function"==typeof Be.has&&"function"==typeof Be.set&&("URLSearchParams"===Be.constructor.name||"[object URLSearchParams]"===Object.prototype.toString.call(Be)||"function"==typeof Be.sort)}function J(Be){return"object"==typeof Be&&"function"==typeof Be.arrayBuffer&&"string"==typeof Be.type&&"function"==typeof Be.stream&&"function"==typeof Be.constructor&&"string"==typeof Be.constructor.name&&/^(Blob|File)$/.test(Be.constructor.name)&&/^(Blob|File)$/.test(Be[Symbol.toStringTag])}function ve(Be){let Fe,Y,be=Be.body;if(Be.bodyUsed)throw new Error("cannot clone body after it is used");return be instanceof g&&"function"!=typeof be.getBoundary&&(Fe=new L,Y=new L,be.pipe(Fe),be.pipe(Y),Be[W].body=Fe,be=Y),be}function ue(Be){return null===Be?null:"string"==typeof Be?"text/plain;charset=UTF-8":re(Be)?"application/x-www-form-urlencoded;charset=UTF-8":J(Be)?Be.type||null:Buffer.isBuffer(Be)||"[object ArrayBuffer]"===Object.prototype.toString.call(Be)||ArrayBuffer.isView(Be)?null:"function"==typeof Be.getBoundary?`multipart/form-data;boundary=${Be.getBoundary()}`:Be instanceof g?null:"text/plain;charset=UTF-8"}function ie(Be){const Fe=Be.body;return null===Fe?0:J(Fe)?Fe.size:Buffer.isBuffer(Fe)?Fe.length:Fe&&"function"==typeof Fe.getLengthSync&&(Fe._lengthRetrievers&&0==Fe._lengthRetrievers.length||Fe.hasKnownLength&&Fe.hasKnownLength())?Fe.getLengthSync():null}R.prototype={get body(){return this[W].body},get bodyUsed(){return this[W].disturbed},arrayBuffer(){return K.call(this).then(function(Be){return Be.buffer.slice(Be.byteOffset,Be.byteOffset+Be.byteLength)})},blob(){let Be=this.headers&&this.headers.get("content-type")||"";return K.call(this).then(function(Fe){return Object.assign(new c([],{type:Be.toLowerCase()}),{[I]:Fe})})},json(){var Be=this;return K.call(this).then(function(Fe){try{return JSON.parse(Fe.toString())}catch(Y){return R.Promise.reject(new p(`invalid json response body at ${Be.url} reason: ${Y.message}`,"invalid-json"))}})},text(){return K.call(this).then(function(Be){return Be.toString()})},buffer(){return K.call(this)},textConverted(){var Be=this;return K.call(this).then(function(Fe){return function(Y,be){if("function"!=typeof y)throw new Error("The package `encoding` must be installed to use the textConverted() function");const ke=be.get("content-type");let We,yt,_t="utf-8";ke&&(We=/charset=([^;]*)/i.exec(ke));yt=Y.slice(0,1024).toString(),!We&&yt&&(We=/<meta.+?charset=(['"])(.+?)\1/i.exec(yt));!We&&yt&&(We=/<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(yt),We||(We=/<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(yt),We&&We.pop()),We&&(We=/charset=(.*)/i.exec(We.pop())));!We&&yt&&(We=/<\?xml.+?encoding=(['"])(.+?)\1/i.exec(yt));We&&(_t=We.pop(),"gb2312"!==_t&&"gbk"!==_t||(_t="gb18030"));return y(Y,"UTF-8",_t).toString()}(Fe,Be.headers)})}},Object.defineProperties(R.prototype,{body:{enumerable:true},bodyUsed:{enumerable:true},arrayBuffer:{enumerable:true},blob:{enumerable:true},json:{enumerable:true},text:{enumerable:true}}),R.mixIn=function(Be){for(const Fe of Object.getOwnPropertyNames(R.prototype))if(!(Fe in Be)){const Y=Object.getOwnPropertyDescriptor(R.prototype,Fe);Object.defineProperty(Be,Fe,Y)}},R.Promise=ko.Promise;const F=/[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/,P=/[^\t\x20-\x7e\x80-\xff]/;function f(Be){if(Be=`${Be}`,F.test(Be)||""===Be)throw new TypeError(`${Be} is not a legal HTTP header name`)}function Q(Be){if(Be=`${Be}`,P.test(Be))throw new TypeError(`${Be} is not a legal HTTP header value`)}function oe(Be,Fe){Fe=Fe.toLowerCase();for(const Y in Be)if(Y.toLowerCase()===Fe)return Y}const se=Symbol("map");class o{constructor(){let Fe=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0;if(this[se]=Object.create(null),Fe instanceof o){const Y=Fe.raw(),be=Object.keys(Y);for(const ke of be)for(const We of Y[ke])this.append(ke,We)}else if(null==Fe);else{if("object"!=typeof Fe)throw new TypeError("Provided initializer must be an object");{const Y=Fe[Symbol.iterator];if(null!=Y){if("function"!=typeof Y)throw new TypeError("Header pairs must be iterable");const be=[];for(const ke of Fe){if("object"!=typeof ke||"function"!=typeof ke[Symbol.iterator])throw new TypeError("Each header pair must be iterable");be.push(Array.from(ke))}for(const ke of be){if(2!==ke.length)throw new TypeError("Each header pair must be a name/value tuple");this.append(ke[0],ke[1])}}else for(const be of Object.keys(Fe)){const ke=Fe[be];this.append(be,ke)}}}}get(Fe){f(Fe=`${Fe}`);const Y=oe(this[se],Fe);return void 0===Y?null:this[se][Y].join(", ")}forEach(Fe){let Y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,be=te(this),ke=0;for(;ke<be.length;){var We=be[ke];const yt=We[0],_t=We[1];Fe.call(Y,_t,yt,this),be=te(this),ke++}}set(Fe,Y){Y=`${Y}`,f(Fe=`${Fe}`),Q(Y);const be=oe(this[se],Fe);this[se][void 0!==be?be:Fe]=[Y]}append(Fe,Y){Y=`${Y}`,f(Fe=`${Fe}`),Q(Y);const be=oe(this[se],Fe);void 0!==be?this[se][be].push(Y):this[se][Fe]=[Y]}has(Fe){return f(Fe=`${Fe}`),void 0!==oe(this[se],Fe)}delete(Fe){f(Fe=`${Fe}`);const Y=oe(this[se],Fe);void 0!==Y&&delete this[se][Y]}raw(){return this[se]}keys(){return Ve(this,"key")}values(){return Ve(this,"value")}[Symbol.iterator](){return Ve(this,"key+value")}}function te(Be){let Fe=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"key+value";const Y=Object.keys(Be[se]).sort();return Y.map("key"===Fe?function(be){return be.toLowerCase()}:"value"===Fe?function(be){return Be[se][be].join(", ")}:function(be){return[be.toLowerCase(),Be[se][be].join(", ")]})}o.prototype.entries=o.prototype[Symbol.iterator],Object.defineProperty(o.prototype,Symbol.toStringTag,{value:"Headers",writable:false,enumerable:false,configurable:true}),Object.defineProperties(o.prototype,{get:{enumerable:true},forEach:{enumerable:true},set:{enumerable:true},append:{enumerable:true},has:{enumerable:true},delete:{enumerable:true},keys:{enumerable:true},values:{enumerable:true},entries:{enumerable:true}});const De=Symbol("internal");function Ve(Be,Fe){const Y=Object.create(ze);return Y[De]={target:Be,kind:Fe,index:0},Y}const ze=Object.setPrototypeOf({next(){if(!this||Object.getPrototypeOf(this)!==ze)throw new TypeError("Value of `this` is not a HeadersIterator");var Be=this[De];const Fe=Be.target,Y=Be.kind,be=Be.index,ke=te(Fe,Y);return be>=ke.length?{value:void 0,done:true}:(this[De].index=be+1,{value:ke[be],done:false})}},Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));function Ke(Be){const Fe=Object.assign({__proto__:null},Be[se]),Y=oe(Be[se],"Host");return void 0!==Y&&(Fe[Y]=Fe[Y][0]),Fe}Object.defineProperty(ze,Symbol.toStringTag,{value:"HeadersIterator",writable:false,enumerable:false,configurable:true});const Ye=Symbol("Response internals"),rt=n.STATUS_CODES;class Qe{constructor(){let Fe=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,Y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};R.call(this,Fe,Y);const be=Y.status||200,ke=new o(Y.headers);if(null!=Fe&&!ke.has("Content-Type")){const We=ue(Fe);We&&ke.append("Content-Type",We)}this[Ye]={url:Y.url,status:be,statusText:Y.statusText||rt[be],headers:ke,counter:Y.counter}}get url(){return this[Ye].url||""}get status(){return this[Ye].status}get ok(){return this[Ye].status>=200&&this[Ye].status<300}get redirected(){return this[Ye].counter>0}get statusText(){return this[Ye].statusText}get headers(){return this[Ye].headers}clone(){return new Qe(ve(this),{url:this.url,status:this.status,statusText:this.statusText,headers:this.headers,ok:this.ok,redirected:this.redirected})}}R.mixIn(Qe.prototype),Object.defineProperties(Qe.prototype,{url:{enumerable:true},status:{enumerable:true},ok:{enumerable:true},redirected:{enumerable:true},statusText:{enumerable:true},headers:{enumerable:true},clone:{enumerable:true}}),Object.defineProperty(Qe.prototype,Symbol.toStringTag,{value:"Response",writable:false,enumerable:false,configurable:true});const tt=Symbol("Request internals"),Nt=h.parse,$t=h.format,Ct="destroy"in g.Readable.prototype;function Ot(Be){return"object"==typeof Be&&"object"==typeof Be[tt]}class zt{constructor(Fe){let Y,be=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};Ot(Fe)?Y=Nt(Fe.url):(Y=Fe&&Fe.href?Nt(Fe.href):Nt(`${Fe}`),Fe={});let ke=be.method||Fe.method||"GET";if(ke=ke.toUpperCase(),(null!=be.body||Ot(Fe)&&null!==Fe.body)&&("GET"===ke||"HEAD"===ke))throw new TypeError("Request with GET/HEAD method cannot have body");let We=null!=be.body?be.body:Ot(Fe)&&null!==Fe.body?ve(Fe):null;R.call(this,We,{timeout:be.timeout||Fe.timeout||0,size:be.size||Fe.size||0});const yt=new o(be.headers||Fe.headers||{});if(null!=We&&!yt.has("Content-Type")){const dt=ue(We);dt&&yt.append("Content-Type",dt)}let _t=Ot(Fe)?Fe.signal:null;if("signal"in be&&(_t=be.signal),null!=_t&&!function(dt){const Ft=dt&&"object"==typeof dt&&Object.getPrototypeOf(dt);return!(!Ft||"AbortSignal"!==Ft.constructor.name)}(_t))throw new TypeError("Expected signal to be an instanceof AbortSignal");this[tt]={method:ke,redirect:be.redirect||Fe.redirect||"follow",headers:yt,parsedURL:Y,signal:_t},this.follow=void 0!==be.follow?be.follow:void 0!==Fe.follow?Fe.follow:20,this.compress=void 0!==be.compress?be.compress:void 0===Fe.compress||Fe.compress,this.counter=be.counter||Fe.counter||0,this.agent=be.agent||Fe.agent}get method(){return this[tt].method}get url(){return $t(this[tt].parsedURL)}get headers(){return this[tt].headers}get redirect(){return this[tt].redirect}get signal(){return this[tt].signal}clone(){return new zt(this)}}function Ht(Be){Error.call(this,Be),this.type="aborted",this.message=Be,Error.captureStackTrace(this,this.constructor)}R.mixIn(zt.prototype),Object.defineProperty(zt.prototype,Symbol.toStringTag,{value:"Request",writable:false,enumerable:false,configurable:true}),Object.defineProperties(zt.prototype,{method:{enumerable:true},url:{enumerable:true},headers:{enumerable:true},redirect:{enumerable:true},clone:{enumerable:true},signal:{enumerable:true}}),Ht.prototype=Object.create(Error.prototype),Ht.prototype.constructor=Ht,Ht.prototype.name="AbortError";const tn=g.PassThrough,qt=h.resolve;function Ut(Be,Fe){if(!Ut.Promise)throw new Error("native promise missing, set fetch.Promise to your favorite alternative");return R.Promise=Ut.Promise,new Ut.Promise(function(Y,be){const ke=new zt(Be,Fe),We=function(Rt){const Xt=Rt[tt].parsedURL,jt=new o(Rt[tt].headers);if(jt.has("Accept")||jt.set("Accept","*/*"),!Xt.protocol||!Xt.hostname)throw new TypeError("Only absolute URLs are supported");if(!/^https?:$/.test(Xt.protocol))throw new TypeError("Only HTTP(S) protocols are supported");if(Rt.signal&&Rt.body instanceof g.Readable&&!Ct)throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");let Nn=null;if(null==Rt.body&&/^(POST|PUT)$/i.test(Rt.method)&&(Nn="0"),null!=Rt.body){const An=ie(Rt);"number"==typeof An&&(Nn=String(An))}Nn&&jt.set("Content-Length",Nn),jt.has("User-Agent")||jt.set("User-Agent","node-fetch/1.0 (+https://github.com/bitinn/node-fetch)"),Rt.compress&&!jt.has("Accept-Encoding")&&jt.set("Accept-Encoding","gzip,deflate");let yn=Rt.agent;return"function"==typeof yn&&(yn=yn(Xt)),jt.has("Connection")||yn||jt.set("Connection","close"),Object.assign({},Xt,{method:Rt.method,headers:Ke(jt),agent:yn})}(ke),yt=("https:"===We.protocol?i:n).request,_t=ke.signal;let dt=null;const Ft=function(){let Rt=new Ht("The user aborted a request.");be(Rt),ke.body&&ke.body instanceof g.Readable&&ke.body.destroy(Rt),dt&&dt.body&&dt.body.emit("error",Rt)};if(_t&&_t.aborted)return void Ft();const Yt=function(){Ft(),gn()},fn=yt(We);let an;function gn(){fn.abort(),_t&&_t.removeEventListener("abort",Yt),clearTimeout(an)}_t&&_t.addEventListener("abort",Yt),ke.timeout&&fn.once("socket",function(Rt){an=setTimeout(function(){be(new p(`network timeout at: ${ke.url}`,"request-timeout")),gn()},ke.timeout)}),fn.on("error",function(Rt){be(new p(`request to ${ke.url} failed, reason: ${Rt.message}`,"system",Rt)),gn()}),fn.on("response",function(Rt){clearTimeout(an);const Xt=function(vn){const Tn=new o;for(const wn of Object.keys(vn))if(!F.test(wn))if(Array.isArray(vn[wn]))for(const Mn of vn[wn])P.test(Mn)||(void 0===Tn[se][wn]?Tn[se][wn]=[Mn]:Tn[se][wn].push(Mn));else P.test(vn[wn])||(Tn[se][wn]=[vn[wn]]);return Tn}(Rt.headers);if(Ut.isRedirect(Rt.statusCode)){const vn=Xt.get("Location"),Tn=null===vn?null:qt(ke.url,vn);switch(ke.redirect){case"error":return be(new p(`uri requested responds with a redirect, redirect mode is set to error: ${ke.url}`,"no-redirect")),void gn();case"manual":if(null!==Tn)try{Xt.set("Location",Tn)}catch(Mn){be(Mn)}break;case"follow":if(null===Tn)break;if(ke.counter>=ke.follow)return be(new p(`maximum redirect reached at: ${ke.url}`,"max-redirect")),void gn();const wn={headers:new o(ke.headers),follow:ke.follow,counter:ke.counter+1,agent:ke.agent,compress:ke.compress,method:ke.method,body:ke.body,signal:ke.signal,timeout:ke.timeout,size:ke.size};return 303!==Rt.statusCode&&ke.body&&null===ie(ke)?(be(new p("Cannot follow redirect with body being a readable stream","unsupported-redirect")),void gn()):(303!==Rt.statusCode&&(301!==Rt.statusCode&&302!==Rt.statusCode||"POST"!==ke.method)||(wn.method="GET",wn.body=void 0,wn.headers.delete("content-length")),Y(Ut(new zt(Tn,wn))),void gn())}}Rt.once("end",function(){_t&&_t.removeEventListener("abort",Yt)});let jt=Rt.pipe(new tn);const Nn={url:ke.url,status:Rt.statusCode,statusText:Rt.statusMessage,headers:Xt,size:ke.size,timeout:ke.timeout,counter:ke.counter},yn=Xt.get("Content-Encoding");if(!ke.compress||"HEAD"===ke.method||null===yn||204===Rt.statusCode||304===Rt.statusCode)return dt=new Qe(jt,Nn),void Y(dt);const An={flush:w.Z_SYNC_FLUSH,finishFlush:w.Z_SYNC_FLUSH};if("gzip"==yn||"x-gzip"==yn)return jt=jt.pipe(w.createGunzip(An)),dt=new Qe(jt,Nn),void Y(dt);if("deflate"!=yn&&"x-deflate"!=yn){if("br"==yn&&"function"==typeof w.createBrotliDecompress)return jt=jt.pipe(w.createBrotliDecompress()),dt=new Qe(jt,Nn),void Y(dt);dt=new Qe(jt,Nn),Y(dt)}else{Rt.pipe(new tn).once("data",function(vn){jt=8==(15&vn[0])?jt.pipe(w.createInflate()):jt.pipe(w.createInflateRaw()),dt=new Qe(jt,Nn),Y(dt)})}}),function(Rt,Xt){const jt=Xt.body;null===jt?Rt.end():J(jt)?jt.stream().pipe(Rt):Buffer.isBuffer(jt)?(Rt.write(jt),Rt.end()):jt.pipe(Rt)}(fn,ke)})}Ut.isRedirect=function(Be){return 301===Be||302===Be||303===Be||307===Be||308===Be},Ut.Promise=ko.Promise;const Wt=Ut},6377:(b,u,e)=>{var g=e(4832),n=e(8652),h=e(801),i=e(2030),w=e(3618),k=e(9049),I=e(1971);I.alea=g,I.xor128=n,I.xorwow=h,I.xorshift7=i,I.xor4096=w,I.tychei=k,b.exports=I},4832:function(b,u,e){var g;!function(n,h,i){function w(T){var c,p=this,y=(c=4022871197,function(W){W=W.toString();for(var L=0;L<W.length;L++){var R=.02519603282416938*(c+=W.charCodeAt(L));R-=c=R>>>0,c=(R*=c)>>>0,c+=4294967296*(R-=c)}return 23283064365386963e-26*(c>>>0)});p.next=function(){var W=2091639*p.s0+23283064365386963e-26*p.c;return p.s0=p.s1,p.s1=p.s2,p.s2=W-(p.c=0|W)},p.c=1,p.s0=y(" "),p.s1=y(" "),p.s2=y(" "),p.s0-=y(T),p.s0<0&&(p.s0+=1),p.s1-=y(T),p.s1<0&&(p.s1+=1),p.s2-=y(T),p.s2<0&&(p.s2+=1),y=null}function k(T,c){return c.c=T.c,c.s0=T.s0,c.s1=T.s1,c.s2=T.s2,c}function I(T,c){var p=new w(T),y=c&&c.state,W=p.next;return W.int32=function(){return 4294967296*p.next()|0},W.double=function(){return W()+11102230246251565e-32*(2097152*W()|0)},W.quick=W,y&&("object"==typeof y&&k(y,p),W.state=function(){return k(p,{})}),W}h&&h.exports?h.exports=I:e.amdD&&e.amdO?void 0===(g=function(){return I}.call(u,e,u,h))||(h.exports=g):this.alea=I}(0,b=e.nmd(b),e.amdD)},9049:function(b,u,e){var g;!function(n,h,i){function w(T){var c=this,p="";c.next=function(){var W=c.b,L=c.c,R=c.d,K=c.a;return W=W<<25^W>>>7^L,L=L-R|0,R=R<<24^R>>>8^K,K=K-W|0,c.b=W=W<<20^W>>>12^L,c.c=L=L-R|0,c.d=R<<16^L>>>16^K,c.a=K-W|0},c.a=0,c.b=0,c.c=-1640531527,c.d=1367130551,T===Math.floor(T)?(c.a=T/4294967296|0,c.b=0|T):p+=T;for(var y=0;y<p.length+20;y++)c.b^=0|p.charCodeAt(y),c.next()}function k(T,c){return c.a=T.a,c.b=T.b,c.c=T.c,c.d=T.d,c}function I(T,c){var p=new w(T),y=c&&c.state,W=function(){return(p.next()>>>0)/4294967296};return W.double=function(){do{var L=((p.next()>>>11)+(p.next()>>>0)/4294967296)/(1<<21)}while(0===L);return L},W.int32=p.next,W.quick=W,y&&("object"==typeof y&&k(y,p),W.state=function(){return k(p,{})}),W}h&&h.exports?h.exports=I:e.amdD&&e.amdO?void 0===(g=function(){return I}.call(u,e,u,h))||(h.exports=g):this.tychei=I}(0,b=e.nmd(b),e.amdD)},8652:function(b,u,e){var g;!function(n,h,i){function w(T){var c=this,p="";c.x=0,c.y=0,c.z=0,c.w=0,c.next=function(){var W=c.x^c.x<<11;return c.x=c.y,c.y=c.z,c.z=c.w,c.w^=c.w>>>19^W^W>>>8},T===(0|T)?c.x=T:p+=T;for(var y=0;y<p.length+64;y++)c.x^=0|p.charCodeAt(y),c.next()}function k(T,c){return c.x=T.x,c.y=T.y,c.z=T.z,c.w=T.w,c}function I(T,c){var p=new w(T),y=c&&c.state,W=function(){return(p.next()>>>0)/4294967296};return W.double=function(){do{var L=((p.next()>>>11)+(p.next()>>>0)/4294967296)/(1<<21)}while(0===L);return L},W.int32=p.next,W.quick=W,y&&("object"==typeof y&&k(y,p),W.state=function(){return k(p,{})}),W}h&&h.exports?h.exports=I:e.amdD&&e.amdO?void 0===(g=function(){return I}.call(u,e,u,h))||(h.exports=g):this.xor128=I}(0,b=e.nmd(b),e.amdD)},3618:function(b,u,e){var g;!function(n,h,i){function w(T){var c=this;c.next=function(){var p,y,W=c.w,L=c.X,R=c.i;return c.w=W=W+1640531527|0,y=L[R+34&127],p=L[R=R+1&127],y^=y<<13,p^=p<<17,y^=y>>>15,p^=p>>>12,y=L[R]=y^p,c.i=R,y+(W^W>>>16)|0},function(p,y){var W,L,R,K,re,J=[],ve=128;for(y===(0|y)?(L=y,y=null):(y+="\0",L=0,ve=Math.max(ve,y.length)),R=0,K=-32;K<ve;++K)y&&(L^=y.charCodeAt((K+32)%y.length)),0===K&&(re=L),L^=L<<10,L^=L>>>15,L^=L<<4,L^=L>>>13,K>=0&&(re=re+1640531527|0,R=0==(W=J[127&K]^=L+re)?R+1:0);for(R>=128&&(J[127&(y&&y.length||0)]=-1),R=127,K=512;K>0;--K)L=J[R+34&127],W=J[R=R+1&127],L^=L<<13,W^=W<<17,L^=L>>>15,W^=W>>>12,J[R]=L^W;p.w=re,p.X=J,p.i=R}(c,T)}function k(T,c){return c.i=T.i,c.w=T.w,c.X=T.X.slice(),c}function I(T,c){null==T&&(T=+new Date);var p=new w(T),y=c&&c.state,W=function(){return(p.next()>>>0)/4294967296};return W.double=function(){do{var L=((p.next()>>>11)+(p.next()>>>0)/4294967296)/(1<<21)}while(0===L);return L},W.int32=p.next,W.quick=W,y&&(y.X&&k(y,p),W.state=function(){return k(p,{})}),W}h&&h.exports?h.exports=I:e.amdD&&e.amdO?void 0===(g=function(){return I}.call(u,e,u,h))||(h.exports=g):this.xor4096=I}(0,b=e.nmd(b),e.amdD)},2030:function(b,u,e){var g;!function(n,h,i){function w(T){var c=this;c.next=function(){var p,y,W=c.x,L=c.i;return p=W[L],y=(p^=p>>>7)^p<<24,y^=(p=W[L+1&7])^p>>>10,y^=(p=W[L+3&7])^p>>>3,y^=(p=W[L+4&7])^p<<7,p=W[L+7&7],y^=(p^=p<<13)^p<<9,W[L]=y,c.i=L+1&7,y},function(p,y){var W,L=[];if(y===(0|y))L[0]=y;else for(y=""+y,W=0;W<y.length;++W)L[7&W]=L[7&W]<<15^y.charCodeAt(W)+L[W+1&7]<<13;for(;L.length<8;)L.push(0);for(W=0;W<8&&0===L[W];++W);for(8==W?L[7]=-1:L[W],p.x=L,p.i=0,W=256;W>0;--W)p.next()}(c,T)}function k(T,c){return c.x=T.x.slice(),c.i=T.i,c}function I(T,c){null==T&&(T=+new Date);var p=new w(T),y=c&&c.state,W=function(){return(p.next()>>>0)/4294967296};return W.double=function(){do{var L=((p.next()>>>11)+(p.next()>>>0)/4294967296)/(1<<21)}while(0===L);return L},W.int32=p.next,W.quick=W,y&&(y.x&&k(y,p),W.state=function(){return k(p,{})}),W}h&&h.exports?h.exports=I:e.amdD&&e.amdO?void 0===(g=function(){return I}.call(u,e,u,h))||(h.exports=g):this.xorshift7=I}(0,b=e.nmd(b),e.amdD)},801:function(b,u,e){var g;!function(n,h,i){function w(T){var c=this,p="";c.next=function(){var W=c.x^c.x>>>2;return c.x=c.y,c.y=c.z,c.z=c.w,c.w=c.v,(c.d=c.d+362437|0)+(c.v=c.v^c.v<<4^W^W<<1)|0},c.x=0,c.y=0,c.z=0,c.w=0,c.v=0,T===(0|T)?c.x=T:p+=T;for(var y=0;y<p.length+64;y++)c.x^=0|p.charCodeAt(y),y==p.length&&(c.d=c.x<<10^c.x>>>4),c.next()}function k(T,c){return c.x=T.x,c.y=T.y,c.z=T.z,c.w=T.w,c.v=T.v,c.d=T.d,c}function I(T,c){var p=new w(T),y=c&&c.state,W=function(){return(p.next()>>>0)/4294967296};return W.double=function(){do{var L=((p.next()>>>11)+(p.next()>>>0)/4294967296)/(1<<21)}while(0===L);return L},W.int32=p.next,W.quick=W,y&&("object"==typeof y&&k(y,p),W.state=function(){return k(p,{})}),W}h&&h.exports?h.exports=I:e.amdD&&e.amdO?void 0===(g=function(){return I}.call(u,e,u,h))||(h.exports=g):this.xorwow=I}(0,b=e.nmd(b),e.amdD)},1971:(b,u,e)=>{var g;!function(n,h){var i,w=this,k=256,I=h.pow(k,6),T=h.pow(2,52),c=2*T,p=255;function y(J,ve,ue){var ie=[],F=K(R((ve=1==ve?{entropy:true}:ve||{}).entropy?[J,re(n)]:null==J?function(){try{var Q;return i&&(Q=i.randomBytes)?Q=Q(k):(Q=new Uint8Array(k),(w.crypto||w.msCrypto).getRandomValues(Q)),re(Q)}catch(o){var oe=w.navigator,se=oe&&oe.plugins;return[+new Date,w,se,w.screen,re(n)]}}():J,3),ie),P=new W(ie),f=function(){for(var Q=P.g(6),oe=I,se=0;Q<T;)Q=(Q+se)*k,oe*=k,se=P.g(1);for(;Q>=c;)Q/=2,oe/=2,se>>>=1;return(Q+se)/oe};return f.int32=function(){return 0|P.g(4)},f.quick=function(){return P.g(4)/4294967296},f.double=f,K(re(P.S),n),(ve.pass||ue||function(Q,oe,se,o){return o&&(o.S&&L(o,P),Q.state=function(){return L(P,{})}),se?(h.random=Q,oe):Q})(f,F,"global"in ve?ve.global:this==h,ve.state)}function W(J){var ve,ue=J.length,ie=this,F=0,P=ie.i=ie.j=0,f=ie.S=[];for(ue||(J=[ue++]);F<k;)f[F]=F++;for(F=0;F<k;F++)f[F]=f[P=p&P+J[F%ue]+(ve=f[F])],f[P]=ve;(ie.g=function(Q){for(var oe,se=0,o=ie.i,te=ie.j,De=ie.S;Q--;)oe=De[o=p&o+1],se=se*k+De[p&(De[o]=De[te=p&te+oe])+(De[te]=oe)];return ie.i=o,ie.j=te,se})(k)}function L(J,ve){return ve.i=J.i,ve.j=J.j,ve.S=J.S.slice(),ve}function R(J,ve){var ue,ie=[],F=typeof J;if(ve&&"object"==F)for(ue in J)try{ie.push(R(J[ue],ve-1))}catch(P){}return ie.length?ie:"string"==F?J:J+"\0"}function K(J,ve){for(var ue,ie=J+"",F=0;F<ie.length;)ve[p&F]=p&(ue^=19*ve[p&F])+ie.charCodeAt(F++);return re(ve)}function re(J){return String.fromCharCode.apply(0,J)}if(h.seedrandom=y,K(h.random(),n),b.exports){b.exports=y;try{i=e(6417)}catch(J){}}else void 0===(g=function(){return y}.call(u,e,u,b))||(b.exports=g)}([],Math)},6086:function(b,u,e){var g=this&&this.__createBinding||(Object.create?function(p,y,W,L){void 0===L&&(L=W),Object.defineProperty(p,L,{enumerable:true,get:function(){return y[W]}})}:function(p,y,W,L){void 0===L&&(L=W),p[L]=y[W]}),n=this&&this.__setModuleDefault||(Object.create?function(p,y){Object.defineProperty(p,"default",{enumerable:true,value:y})}:function(p,y){p.default=y}),h=this&&this.__importStar||function(p){if(p&&p.__esModule)return p;var y={};if(null!=p)for(var W in p)"default"!==W&&Object.prototype.hasOwnProperty.call(p,W)&&g(y,p,W);return n(y,p),y},i=this&&this.__awaiter||function(p,y,W,L){return new(W||(W=Promise))(function(R,K){function re(ue){try{ve(L.next(ue))}catch(ie){K(ie)}}function J(ue){try{ve(L.throw(ue))}catch(ie){K(ie)}}function ve(ue){var ie;ue.done?R(ue.value):(ie=ue.value,ie instanceof W?ie:new W(function(F){F(ie)})).then(re,J)}ve((L=L.apply(p,y||[])).next())})},w=this&&this.__generator||function(p,y){var W,L,R,K,re={label:0,sent:function(){if(1&R[0])throw R[1];return R[1]},trys:[],ops:[]};return K={next:J(0),throw:J(1),return:J(2)},"function"==typeof Symbol&&(K[Symbol.iterator]=function(){return this}),K;function J(ve){return function(ue){return function(ie){if(W)throw new TypeError("Generator is already executing.");for(;re;)try{if(W=1,L&&(R=2&ie[0]?L.return:ie[0]?L.throw||((R=L.return)&&R.call(L),0):L.next)&&!(R=R.call(L,ie[1])).done)return R;switch(L=0,R&&(ie=[2&ie[0],R.value]),ie[0]){case 0:case 1:R=ie;break;case 4:return re.label++,{value:ie[1],done:false};case 5:re.label++,L=ie[1],ie=[0];continue;case 7:ie=re.ops.pop(),re.trys.pop();continue;default:if(!(R=re.trys,(R=R.length>0&&R[R.length-1])||6!==ie[0]&&2!==ie[0])){re=0;continue}if(3===ie[0]&&(!R||ie[1]>R[0]&&ie[1]<R[3])){re.label=ie[1];break}if(6===ie[0]&&re.label<R[1]){re.label=R[1],R=ie;break}if(R&&re.label<R[2]){re.label=R[2],re.ops.push(ie);break}R[2]&&re.ops.pop(),re.trys.pop();continue}ie=y.call(p,re)}catch(F){ie=[6,F],L=0}finally{W=R=0}if(5&ie[0])throw ie[1];return{value:ie[0]?ie[1]:void 0,done:true}}([ve,ue])}}};u.__esModule=true,u.ModelOperations=void 0;var k=e(5363),I=e(4933);e(5528);var T=function(){function p(y,W){this.modelJSON=y,this.weights=W}return p.prototype.load=function(){return i(this,void 0,void 0,function(){var y,W,L=this;return w(this,function(R){if(y=this.modelJSON.modelTopology,W=this.modelJSON.weightsManifest,null===y&&null===W)throw new Error("The model contains neither model topology or manifest for weights.");return[2,this.getModelArtifactsForJSON(this.modelJSON,function(K){return L.loadWeights(K)})]})})},p.prototype.getModelArtifactsForJSON=function(y,W){return i(this,void 0,void 0,function(){var L,R,K,re;return w(this,function(J){switch(J.label){case 0:return L={modelTopology:y.modelTopology,format:y.format,generatedBy:y.generatedBy,convertedBy:y.convertedBy},null!==y.trainingConfig&&(L.trainingConfig=y.trainingConfig),null===y.weightsManifest?[3,2]:[4,W(y.weightsManifest)];case 1:R=J.sent(),K=R[0],re=R[1],L.weightSpecs=K,L.weightData=re,J.label=2;case 2:return null!==y.signature&&(L.signature=y.signature),null!==y.userDefinedMetadata&&(L.userDefinedMetadata=y.userDefinedMetadata),null!==y.modelInitializer&&(L.modelInitializer=y.modelInitializer),[2,L]}})})},p.prototype.loadWeights=function(y){return i(this,void 0,void 0,function(){var W,L,R,K;return w(this,function(re){for(W=[],L=0,R=y;L<R.length;L++)K=R[L],W.push.apply(W,K.weights);return[2,[W,this.weights]]})})},p}(),c=function(){function p(y){var W,L,R,K,re;this._modelJsonLoaderFunc=null!==(W=null==y?void 0:y.modelJsonLoaderFunc)&&void 0!==W?W:p.NODE_MODEL_JSON_FUNC,this._weightsLoaderFunc=null!==(L=null==y?void 0:y.weightsLoaderFunc)&&void 0!==L?L:p.NODE_WEIGHTS_FUNC,this._minContentSize=null!==(R=null==y?void 0:y.minContentSize)&&void 0!==R?R:p.DEFAULT_MIN_CONTENT_SIZE,this._maxContentSize=null!==(K=null==y?void 0:y.maxContentSize)&&void 0!==K?K:p.DEFAULT_MAX_CONTENT_SIZE,this._normalizeNewline=null===(re=null==y?void 0:y.normalizeNewline)||void 0===re||re}return p.prototype.getModelJSON=function(){return i(this,void 0,void 0,function(){var y;return w(this,function(W){switch(W.label){case 0:return this._modelJson?[2,this._modelJson]:(y=this,[4,this._modelJsonLoaderFunc()]);case 1:return y._modelJson=W.sent(),[2,this._modelJson]}})})},p.prototype.getWeights=function(){return i(this,void 0,void 0,function(){var y;return w(this,function(W){switch(W.label){case 0:return this._weights?[2,this._weights]:(y=this,[4,this._weightsLoaderFunc()]);case 1:return y._weights=W.sent(),[2,this._weights]}})})},p.prototype.loadModel=function(){return i(this,void 0,void 0,function(){var y,W,L,R;return w(this,function(K){switch(K.label){case 0:return this._model?[2]:((y=k.env()).set("IS_NODE",false),y.set("PROD",true),[4,k.setBackend("cpu")]);case 1:if(!K.sent())throw new Error("Unable to set backend to CPU.");return[4,this.getModelJSON()];case 2:return W=K.sent(),[4,this.getWeights()];case 3:return L=K.sent(),R=this,[4,I.loadGraphModel(new T(W,L))];case 4:return R._model=K.sent(),[2]}})})},p.prototype.runModel=function(y){return i(this,void 0,void 0,function(){var W,L,R,K,re,J,ve,ue;return w(this,function(ie){switch(ie.label){case 0:return!y||y.length<this._minContentSize?[2,[]]:[4,this.loadModel()];case 1:return ie.sent(),y.length>=this._maxContentSize&&(y=y.substring(0,this._maxContentSize)),this._normalizeNewline&&(y=y.replace(/\r\n/g,"\n")),[4,this._model.executeAsync(k.tensor([y]))];case 2:for(W=ie.sent(),L=Array.isArray(W)?W[0]:W,R=Array.isArray(W)?W[1]:W,K=L.dataSync(),re=R.dataSync(),J=[],ue=0;ue<re.length;ue++)J.push({languageId:re[ue],confidence:K[ue]});for(ve=0,ue=0;ue<K.length;ue++)K[ue]>K[ve]&&(ve=ue);return[2,J.sort(function(F,P){return P.confidence-F.confidence})]}})})},p.prototype.dispose=function(){var y;null===(y=this._model)||void 0===y||y.dispose()},p.DEFAULT_MAX_CONTENT_SIZE=1e5,p.DEFAULT_MIN_CONTENT_SIZE=20,p.NODE_MODEL_JSON_FUNC=function(){return i(void 0,void 0,void 0,function(){var y,W;return w(this,function(L){switch(L.label){case 0:return[4,Promise.resolve().then(function(){return h(e(5747))})];case 1:return y=L.sent(),[4,Promise.resolve().then(function(){return h(e(5622))})];case 2:return W=L.sent(),[2,new Promise(function(R,K){y.readFile(W.join(__dirname,"..","..","model","model.json"),function(re,J){re?K(re):R(JSON.parse(J.toString()))})})]}})})},p.NODE_WEIGHTS_FUNC=function(){return i(void 0,void 0,void 0,function(){var y,W;return w(this,function(L){switch(L.label){case 0:return[4,Promise.resolve().then(function(){return h(e(5747))})];case 1:return y=L.sent(),[4,Promise.resolve().then(function(){return h(e(5622))})];case 2:return W=L.sent(),[2,new Promise(function(R,K){y.readFile(W.join(__dirname,"..","..","model","group1-shard1of1.bin"),function(re,J){re?K(re):R(J.buffer)})})]}})})},p}();u.ModelOperations=c},6417:b=>{b.exports=Ia},5747:b=>{b.exports=Ia},5622:b=>{b.exports=Ia},1669:b=>{b.exports=Ia}},x={};function q(b){var u=x[b];if(void 0!==u)return u.exports;var e=x[b]={id:b,loaded:false,exports:{}};return a[b].call(e.exports,e,e.exports,q),e.loaded=true,e.exports}return q.amdD=function(){throw new Error("define cannot be used indirect")},q.amdO={},q.n=b=>{var u=b&&b.__esModule?()=>b.default:()=>b;return q.d(u,{a:u}),u},q.d=(b,u)=>{for(var e in u)q.o(u,e)&&!q.o(b,e)&&Object.defineProperty(b,e,{enumerable:true,get:u[e]})},q.o=(b,u)=>Object.prototype.hasOwnProperty.call(b,u),q.r=b=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(b,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(b,"__esModule",{value:true})},q.nmd=b=>(b.paths=[],b.children||(b.children=[]),b),q(6086)})()})})(Ai);var Wu=Ai.exports;const Uu=globalThis.performance&&typeof globalThis.performance.now==="function";class Vo{static create(t){return new Vo(t)}constructor(t){this._now=Uu&&t===false?Date.now:globalThis.performance.now.bind(globalThis.performance);this._startTime=this._now();this._stopTime=-1}stop(){this._stopTime=this._now()}reset(){this._startTime=this._now();this._stopTime=-1}elapsed(){if(this._stopTime!==-1){return this._stopTime-this._startTime}return this._now()-this._startTime}}class Do{static{this.CHANNEL_NAME="languageDetectionWorkerHost"}static getChannel(t){return t.getChannel(Do.CHANNEL_NAME)}static setChannel(t,a){t.setChannel(Do.CHANNEL_NAME,a)}}function qu(m,t){const a=Object.create(null);for(const x of m){const q=t(x);let b=a[q];if(!b){b=a[q]=[]}b.push(x)}return a}class Hu{constructor(){this.listeners=[];this.unexpectedErrorHandler=function(t){setTimeout(()=>{if(t.stack){if(ho.isErrorNoTelemetry(t)){throw new ho(t.message+"\n\n"+t.stack)}throw new Error(t.message+"\n\n"+t.stack)}throw t},0)}}addListener(t){this.listeners.push(t);return()=>{this._removeListener(t)}}emit(t){this.listeners.forEach(a=>{a(t)})}_removeListener(t){this.listeners.splice(this.listeners.indexOf(t),1)}setUnexpectedErrorHandler(t){this.unexpectedErrorHandler=t}getUnexpectedErrorHandler(){return this.unexpectedErrorHandler}onUnexpectedError(t){this.unexpectedErrorHandler(t);this.emit(t)}onUnexpectedExternalError(t){this.unexpectedErrorHandler(t)}}const ju=new Hu;function Ao(m){if(!Gu(m)){ju.onUnexpectedError(m)}return void 0}function ci(m){if(m instanceof Error){const{name:t,message:a}=m;const x=m.stacktrace||m.stack;return{$isError:true,name:t,message:a,stack:x,noTelemetry:ho.isErrorNoTelemetry(m)}}return m}const Xo="Canceled";function Gu(m){if(m instanceof Ku){return true}return m instanceof Error&&m.name===Xo&&m.message===Xo}class Ku extends Error{constructor(){super(Xo);this.name=this.message}}class ho extends Error{constructor(t){super(t);this.name="CodeExpectedError"}static fromError(t){if(t instanceof ho){return t}const a=new ho;a.message=t.message;a.stack=t.stack;return a}static isErrorNoTelemetry(t){return t.name==="CodeExpectedError"}}function Xu(m,t){const a=this;let x=false;let q;return function(){if(x){return q}x=true;{q=m.apply(a,arguments)}return q}}function Zu(m,t,a=0,x=m.length){let q=a;let b=x;while(q<b){const u=Math.floor((q+b)/2);if(t(m[u])){q=u+1}else{b=u}}return q-1}class Mi{static{this.assertInvariants=false}constructor(t){this._array=t;this._findLastMonotonousLastIdx=0}findLastMonotonous(t){if(Mi.assertInvariants){if(this._prevFindLastPredicate){for(const x of this._array){if(this._prevFindLastPredicate(x)&&!t(x)){throw new Error("MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.")}}}this._prevFindLastPredicate=t}const a=Zu(this._array,t,this._findLastMonotonousLastIdx);this._findLastMonotonousLastIdx=a+1;return a===-1?void 0:this._array[a]}}var Zo;(function(m){function t(b){return b<0}m.isLessThan=t;function a(b){return b<=0}m.isLessThanOrEqual=a;function x(b){return b>0}m.isGreaterThan=x;function q(b){return b===0}m.isNeitherLessOrGreaterThan=q;m.greaterThan=1;m.lessThan=-1;m.neitherLessOrGreaterThan=0})(Zo||(Zo={}));function Qu(m,t){return(a,x)=>t(m(a),m(x))}const Ju=(m,t)=>m-t;class Mo{static{this.empty=new Mo(t=>{})}constructor(t){this.iterate=t}forEach(t){this.iterate(a=>{t(a);return true})}toArray(){const t=[];this.iterate(a=>{t.push(a);return true});return t}filter(t){return new Mo(a=>this.iterate(x=>t(x)?a(x):true))}map(t){return new Mo(a=>this.iterate(x=>a(t(x))))}some(t){let a=false;this.iterate(x=>{a=t(x);return!a});return a}findFirst(t){let a;this.iterate(x=>{if(t(x)){a=x;return false}return true});return a}findLast(t){let a;this.iterate(x=>{if(t(x)){a=x}return true});return a}findLastMaxBy(t){let a;let x=true;this.iterate(q=>{if(x||Zo.isGreaterThan(t(q,a))){x=false;a=q}return true});return a}}var di;class Yu{constructor(t,a){this.uri=t;this.value=a}}function el(m){return Array.isArray(m)}class lo{static{this.defaultToKey=t=>t.toString()}constructor(t,a){this[di]="ResourceMap";if(t instanceof lo){this.map=new Map(t.map);this.toKey=a??lo.defaultToKey}else if(el(t)){this.map=new Map;this.toKey=a??lo.defaultToKey;for(const[x,q]of t){this.set(x,q)}}else{this.map=new Map;this.toKey=t??lo.defaultToKey}}set(t,a){this.map.set(this.toKey(t),new Yu(t,a));return this}get(t){return this.map.get(this.toKey(t))?.value}has(t){return this.map.has(this.toKey(t))}get size(){return this.map.size}clear(){this.map.clear()}delete(t){return this.map.delete(this.toKey(t))}forEach(t,a){if(typeof a!=="undefined"){t=t.bind(a)}for(const[x,q]of this.map){t(q.value,q.uri,this)}}*values(){for(const t of this.map.values()){yield t.value}}*keys(){for(const t of this.map.values()){yield t.uri}}*entries(){for(const t of this.map.values()){yield[t.uri,t.value]}}*[(di=Symbol.toStringTag,Symbol.iterator)](){for(const[,t]of this.map){yield[t.uri,t.value]}}}class tl{constructor(){this.map=new Map}add(t,a){let x=this.map.get(t);if(!x){x=new Set;this.map.set(t,x)}x.add(a)}delete(t,a){const x=this.map.get(t);if(!x){return}x.delete(a);if(x.size===0){this.map.delete(t)}}forEach(t,a){const x=this.map.get(t);if(!x){return}x.forEach(a)}get(t){const a=this.map.get(t);if(!a){return new Set}return a}}var Fo;(function(m){function t(L){return L&&typeof L==="object"&&typeof L[Symbol.iterator]==="function"}m.is=t;const a=Object.freeze([]);function x(){return a}m.empty=x;function*q(L){yield L}m.single=q;function b(L){if(t(L)){return L}else{return q(L)}}m.wrap=b;function u(L){return L||a}m.from=u;function*e(L){for(let R=L.length-1;R>=0;R--){yield L[R]}}m.reverse=e;function g(L){return!L||L[Symbol.iterator]().next().done===true}m.isEmpty=g;function n(L){return L[Symbol.iterator]().next().value}m.first=n;function h(L,R){let K=0;for(const re of L){if(R(re,K++)){return true}}return false}m.some=h;function i(L,R){for(const K of L){if(R(K)){return K}}return void 0}m.find=i;function*w(L,R){for(const K of L){if(R(K)){yield K}}}m.filter=w;function*k(L,R){let K=0;for(const re of L){yield R(re,K++)}}m.map=k;function*I(L,R){let K=0;for(const re of L){yield*R(re,K++)}}m.flatMap=I;function*T(...L){for(const R of L){yield*R}}m.concat=T;function c(L,R,K){let re=K;for(const J of L){re=R(re,J)}return re}m.reduce=c;function*p(L,R,K=L.length){if(R<-L.length){R=0}if(R<0){R+=L.length}if(K<0){K+=L.length}else if(K>L.length){K=L.length}for(;R<K;R++){yield L[R]}}m.slice=p;function y(L,R=Number.POSITIVE_INFINITY){const K=[];if(R===0){return[K,L]}const re=L[Symbol.iterator]();for(let J=0;J<R;J++){const ve=re.next();if(ve.done){return[K,m.empty()]}K.push(ve.value)}return[K,{[Symbol.iterator](){return re}}]}m.consume=y;async function W(L){const R=[];for await(const K of L){R.push(K)}return Promise.resolve(R)}m.asyncToArray=W})(Fo||(Fo={}));class Ci{constructor(){this.livingDisposables=new Map}static{this.idx=0}getDisposableData(t){let a=this.livingDisposables.get(t);if(!a){a={parent:null,source:null,isSingleton:false,value:t,idx:Ci.idx++};this.livingDisposables.set(t,a)}return a}trackDisposable(t){const a=this.getDisposableData(t);if(!a.source){a.source=new Error().stack}}setParent(t,a){const x=this.getDisposableData(t);x.parent=a}markAsDisposed(t){this.livingDisposables.delete(t)}markAsSingleton(t){this.getDisposableData(t).isSingleton=true}getRootParent(t,a){const x=a.get(t);if(x){return x}const q=t.parent?this.getRootParent(this.getDisposableData(t.parent),a):t;a.set(t,q);return q}getTrackedDisposables(){const t=new Map;const a=[...this.livingDisposables.entries()].filter(([,x])=>x.source!==null&&!this.getRootParent(x,t).isSingleton).flatMap(([x])=>x);return a}computeLeakingDisposables(t=10,a){let x;if(a){x=a}else{const g=new Map;const n=[...this.livingDisposables.values()].filter(i=>i.source!==null&&!this.getRootParent(i,g).isSingleton);if(n.length===0){return}const h=new Set(n.map(i=>i.value));x=n.filter(i=>{return!(i.parent&&h.has(i.parent))});if(x.length===0){throw new Error("There are cyclic diposable chains!")}}if(!x){return void 0}function q(g){function n(i,w){while(i.length>0&&w.some(k=>typeof k==="string"?k===i[0]:i[0].match(k))){i.shift()}}const h=g.source.split("\n").map(i=>i.trim().replace("at ","")).filter(i=>i!=="");n(h,["Error",/^trackDisposable \(.*\)$/,/^DisposableTracker.trackDisposable \(.*\)$/]);return h.reverse()}const b=new tl;for(const g of x){const n=q(g);for(let h=0;h<=n.length;h++){b.add(n.slice(0,h).join("\n"),g)}}x.sort(Qu(g=>g.idx,Ju));let u="";let e=0;for(const g of x.slice(0,t)){e++;const n=q(g);const h=[];for(let i=0;i<n.length;i++){let w=n[i];const k=b.get(n.slice(0,i+1).join("\n"));w=`(shared with ${k.size}/${x.length} leaks) at ${w}`;const I=b.get(n.slice(0,i).join("\n"));const T=qu([...I].map(c=>q(c)[i]),c=>c);delete T[n[i]];for(const[c,p]of Object.entries(T)){h.unshift(`    - stacktraces of ${p.length} other leaks continue with ${c}`)}h.unshift(w)}u+=`


==================== Leaking disposable ${e}/${x.length}: ${g.value.constructor.name} ====================
${h.join("\n")}
============================================================

`}if(x.length>t){u+=`


... and ${x.length-t} more leaking disposables

`}return{leaks:x,details:u}}}function nl(m){return m}function rl(m,t){}function $i(m){if(Fo.is(m)){const t=[];for(const a of m){if(a){try{a.dispose()}catch(x){t.push(x)}}}if(t.length===1){throw t[0]}else if(t.length>1){throw new AggregateError(t,"Encountered errors while disposing of store")}return Array.isArray(m)?[]:m}else if(m){m.dispose();return m}}function sl(...m){const t=ri(()=>$i(m));return t}function ri(m){const t=nl({dispose:Xu(()=>{m()})});return t}class xo{static{this.DISABLE_DISPOSED_WARNING=false}constructor(){this._toDispose=new Set;this._isDisposed=false}dispose(){if(this._isDisposed){return}this._isDisposed=true;this.clear()}get isDisposed(){return this._isDisposed}clear(){if(this._toDispose.size===0){return}try{$i(this._toDispose)}finally{this._toDispose.clear()}}add(t){if(!t){return t}if(t===this){throw new Error("Cannot register a disposable on itself!")}if(this._isDisposed){if(!xo.DISABLE_DISPOSED_WARNING){console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack)}}else{this._toDispose.add(t)}return t}delete(t){if(!t){return}if(t===this){throw new Error("Cannot dispose a disposable on itself!")}this._toDispose.delete(t);t.dispose()}deleteAndLeak(t){if(!t){return}if(this._toDispose.has(t)){this._toDispose.delete(t)}}}class Qo{static{this.None=Object.freeze({dispose(){}})}constructor(){this._store=new xo;rl(this._store)}dispose(){this._store.dispose()}_register(t){if(t===this){throw new Error("Cannot register a disposable on itself!")}return this._store.add(t)}}class En{static{this.Undefined=new En(void 0)}constructor(t){this.element=t;this.next=En.Undefined;this.prev=En.Undefined}}class al{constructor(){this._first=En.Undefined;this._last=En.Undefined;this._size=0}get size(){return this._size}isEmpty(){return this._first===En.Undefined}clear(){let t=this._first;while(t!==En.Undefined){const a=t.next;t.prev=En.Undefined;t.next=En.Undefined;t=a}this._first=En.Undefined;this._last=En.Undefined;this._size=0}unshift(t){return this._insert(t,false)}push(t){return this._insert(t,true)}_insert(t,a){const x=new En(t);if(this._first===En.Undefined){this._first=x;this._last=x}else if(a){const b=this._last;this._last=x;x.prev=b;b.next=x}else{const b=this._first;this._first=x;x.next=b;b.prev=x}this._size+=1;let q=false;return()=>{if(!q){q=true;this._remove(x)}}}shift(){if(this._first===En.Undefined){return void 0}else{const t=this._first.element;this._remove(this._first);return t}}pop(){if(this._last===En.Undefined){return void 0}else{const t=this._last.element;this._remove(this._last);return t}}_remove(t){if(t.prev!==En.Undefined&&t.next!==En.Undefined){const a=t.prev;a.next=t.next;t.next.prev=a}else if(t.prev===En.Undefined&&t.next===En.Undefined){this._first=En.Undefined;this._last=En.Undefined}else if(t.next===En.Undefined){this._last=this._last.prev;this._last.next=En.Undefined}else if(t.prev===En.Undefined){this._first=this._first.next;this._first.prev=En.Undefined}this._size-=1}*[Symbol.iterator](){let t=this._first;while(t!==En.Undefined){yield t.element;t=t.next}}}var Oo;(function(m){m.None=()=>Qo.None;function t(P,f){return w(P,()=>void 0,0,void 0,true,void 0,f)}m.defer=t;function a(P){return(f,Q=null,oe)=>{let se=false;let o=void 0;o=P(te=>{if(se){return}else if(o){o.dispose()}else{se=true}return f.call(Q,te)},null,oe);if(se){o.dispose()}return o}}m.once=a;function x(P,f){return m.once(m.filter(P,f))}m.onceIf=x;function q(P,f,Q){return h((oe,se=null,o)=>P(te=>oe.call(se,f(te)),null,o),Q)}m.map=q;function b(P,f,Q){return h((oe,se=null,o)=>P(te=>{f(te);oe.call(se,te)},null,o),Q)}m.forEach=b;function u(P,f,Q){return h((oe,se=null,o)=>P(te=>f(te)&&oe.call(se,te),null,o),Q)}m.filter=u;function e(P){return P}m.signal=e;function g(...P){return(f,Q=null,oe)=>{const se=sl(...P.map(o=>o(te=>f.call(Q,te))));return i(se,oe)}}m.any=g;function n(P,f,Q,oe){let se=Q;return q(P,o=>{se=f(se,o);return se},oe)}m.reduce=n;function h(P,f){let Q;const oe={onWillAddFirstListener(){Q=P(se.fire,se)},onDidRemoveLastListener(){Q?.dispose()}};const se=new sa(oe);f?.add(se);return se.event}function i(P,f){if(f instanceof Array){f.push(P)}else if(f){f.add(P)}return P}function w(P,f,Q=100,oe=false,se=false,o,te){let De;let Ve=void 0;let ze=void 0;let Ke=0;let Ye;const rt={leakWarningThreshold:o,onWillAddFirstListener(){De=P(tt=>{Ke++;Ve=f(Ve,tt);if(oe&&!ze){Qe.fire(Ve);Ve=void 0}Ye=()=>{const Nt=Ve;Ve=void 0;ze=void 0;if(!oe||Ke>1){Qe.fire(Nt)}Ke=0};if(typeof Q==="number"){clearTimeout(ze);ze=setTimeout(Ye,Q)}else{if(ze===void 0){ze=0;queueMicrotask(Ye)}}})},onWillRemoveListener(){if(se&&Ke>0){Ye?.()}},onDidRemoveLastListener(){Ye=void 0;De.dispose()}};const Qe=new sa(rt);te?.add(Qe);return Qe.event}m.debounce=w;function k(P,f=0,Q){return m.debounce(P,(oe,se)=>{if(!oe){return[se]}oe.push(se);return oe},f,void 0,true,void 0,Q)}m.accumulate=k;function I(P,f=(oe,se)=>oe===se,Q){let oe=true;let se;return u(P,o=>{const te=oe||!f(o,se);oe=false;se=o;return te},Q)}m.latch=I;function T(P,f,Q){return[m.filter(P,f,Q),m.filter(P,oe=>!f(oe),Q)]}m.split=T;function c(P,f=false,Q=[],oe){let se=Q.slice();let o=P(Ve=>{if(se){se.push(Ve)}else{De.fire(Ve)}});if(oe){oe.add(o)}const te=()=>{se?.forEach(Ve=>De.fire(Ve));se=null};const De=new sa({onWillAddFirstListener(){if(!o){o=P(Ve=>De.fire(Ve));if(oe){oe.add(o)}}},onDidAddFirstListener(){if(se){if(f){setTimeout(te)}else{te()}}},onDidRemoveLastListener(){if(o){o.dispose()}o=null}});if(oe){oe.add(De)}return De.event}m.buffer=c;function p(P,f){const Q=(oe,se,o)=>{const te=f(new W);return P(function(De){const Ve=te.evaluate(De);if(Ve!==y){oe.call(se,Ve)}},void 0,o)};return Q}m.chain=p;const y=Symbol("HaltChainable");class W{constructor(){this.steps=[]}map(f){this.steps.push(f);return this}forEach(f){this.steps.push(Q=>{f(Q);return Q});return this}filter(f){this.steps.push(Q=>f(Q)?Q:y);return this}reduce(f,Q){let oe=Q;this.steps.push(se=>{oe=f(oe,se);return oe});return this}latch(f=(Q,oe)=>Q===oe){let Q=true;let oe;this.steps.push(se=>{const o=Q||!f(se,oe);Q=false;oe=se;return o?se:y});return this}evaluate(f){for(const Q of this.steps){f=Q(f);if(f===y){break}}return f}}function L(P,f,Q=oe=>oe){const oe=(...De)=>te.fire(Q(...De));const se=()=>P.on(f,oe);const o=()=>P.removeListener(f,oe);const te=new sa({onWillAddFirstListener:se,onDidRemoveLastListener:o});return te.event}m.fromNodeEventEmitter=L;function R(P,f,Q=oe=>oe){const oe=(...De)=>te.fire(Q(...De));const se=()=>P.addEventListener(f,oe);const o=()=>P.removeEventListener(f,oe);const te=new sa({onWillAddFirstListener:se,onDidRemoveLastListener:o});return te.event}m.fromDOMEventEmitter=R;function K(P){return new Promise(f=>a(P)(f))}m.toPromise=K;function re(P){const f=new sa;P.then(Q=>{f.fire(Q)},()=>{f.fire(void 0)}).finally(()=>{f.dispose()});return f.event}m.fromPromise=re;function J(P,f){return P(Q=>f.fire(Q))}m.forward=J;function ve(P,f,Q){f(Q);return P(oe=>f(oe))}m.runAndSubscribe=ve;class ue{constructor(f,Q){this._observable=f;this._counter=0;this._hasChanged=false;const oe={onWillAddFirstListener:()=>{f.addObserver(this);this._observable.reportChanges()},onDidRemoveLastListener:()=>{f.removeObserver(this)}};this.emitter=new sa(oe);if(Q){Q.add(this.emitter)}}beginUpdate(f){this._counter++}handlePossibleChange(f){}handleChange(f,Q){this._hasChanged=true}endUpdate(f){this._counter--;if(this._counter===0){this._observable.reportChanges();if(this._hasChanged){this._hasChanged=false;this.emitter.fire(this._observable.get())}}}}function ie(P,f){const Q=new ue(P,f);return Q.emitter.event}m.fromObservable=ie;function F(P){return(f,Q,oe)=>{let se=0;let o=false;const te={beginUpdate(){se++},endUpdate(){se--;if(se===0){P.reportChanges();if(o){o=false;f.call(Q)}}},handlePossibleChange(){},handleChange(){o=true}};P.addObserver(te);P.reportChanges();const De={dispose(){P.removeObserver(te)}};if(oe instanceof xo){oe.add(De)}else if(Array.isArray(oe)){oe.push(De)}return De}}m.fromObservableLight=F})(Oo||(Oo={}));class Bo{static{this.all=new Set}static{this._idPool=0}constructor(t){this.listenerCount=0;this.invocationCount=0;this.elapsedOverall=0;this.durations=[];this.name=`${t}_${Bo._idPool++}`;Bo.all.add(this)}start(t){this._stopWatch=new Vo;this.listenerCount=t}stop(){if(this._stopWatch){const t=this._stopWatch.elapsed();this.durations.push(t);this.elapsedOverall+=t;this.invocationCount+=1;this._stopWatch=void 0}}}let hi=-1;class si{static{this._idPool=1}constructor(t,a,x=(si._idPool++).toString(16).padStart(3,"0")){this._errorHandler=t;this.threshold=a;this.name=x;this._warnCountdown=0}dispose(){this._stacks?.clear()}check(t,a){const x=this.threshold;if(x<=0||a<x){return void 0}if(!this._stacks){this._stacks=new Map}const q=this._stacks.get(t.value)||0;this._stacks.set(t.value,q+1);this._warnCountdown-=1;if(this._warnCountdown<=0){this._warnCountdown=x*.5;const[b,u]=this.getMostFrequentStack();const e=`[${this.name}] potential listener LEAK detected, having ${a} listeners already. MOST frequent listener (${u}):`;console.warn(e);console.warn(b);const g=new ol(e,b);this._errorHandler(g)}return()=>{const b=this._stacks.get(t.value)||0;this._stacks.set(t.value,b-1)}}getMostFrequentStack(){if(!this._stacks){return void 0}let t;let a=0;for(const[x,q]of this._stacks){if(!t||a<q){t=[x,q];a=q}}return t}}class ai{static create(){const t=new Error;return new ai(t.stack??"")}constructor(t){this.value=t}print(){console.warn(this.value.split("\n").slice(2).join("\n"))}}class ol extends Error{constructor(t,a){super(t);this.name="ListenerLeakError";this.stack=a}}class il extends Error{constructor(t,a){super(t);this.name="ListenerRefusalError";this.stack=a}}let ul=0;class Ho{constructor(t){this.value=t;this.id=ul++}}const ll=2;class sa{constructor(t){this._size=0;this._options=t;this._leakageMon=hi>0||this._options?.leakWarningThreshold?new si(t?.onListenerError??Ao,this._options?.leakWarningThreshold??hi):void 0;this._perfMon=this._options?._profName?new Bo(this._options._profName):void 0;this._deliveryQueue=this._options?.deliveryQueue}dispose(){if(!this._disposed){this._disposed=true;if(this._deliveryQueue?.current===this){this._deliveryQueue.reset()}if(this._listeners){this._listeners=void 0;this._size=0}this._options?.onDidRemoveLastListener?.();this._leakageMon?.dispose()}}get event(){this._event??=(t,a,x)=>{if(this._leakageMon&&this._size>this._leakageMon.threshold**2){const e=`[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;console.warn(e);const g=this._leakageMon.getMostFrequentStack()??["UNKNOWN stack",-1];const n=new il(`${e}. HINT: Stack shows most frequent listener (${g[1]}-times)`,g[0]);const h=this._options?.onListenerError||Ao;h(n);return Qo.None}if(this._disposed){return Qo.None}if(a){t=t.bind(a)}const q=new Ho(t);let b;if(this._leakageMon&&this._size>=Math.ceil(this._leakageMon.threshold*.2)){q.stack=ai.create();b=this._leakageMon.check(q.stack,this._size+1)}if(!this._listeners){this._options?.onWillAddFirstListener?.(this);this._listeners=q;this._options?.onDidAddFirstListener?.(this)}else if(this._listeners instanceof Ho){this._deliveryQueue??=new cl;this._listeners=[this._listeners,q]}else{this._listeners.push(q)}this._options?.onDidAddListener?.(this);this._size++;const u=ri(()=>{b?.();this._removeListener(q)});if(x instanceof xo){x.add(u)}else if(Array.isArray(x)){x.push(u)}return u};return this._event}_removeListener(t){this._options?.onWillRemoveListener?.(this);if(!this._listeners){return}if(this._size===1){this._listeners=void 0;this._options?.onDidRemoveLastListener?.(this);this._size=0;return}const a=this._listeners;const x=a.indexOf(t);if(x===-1){console.log("disposed?",this._disposed);console.log("size?",this._size);console.log("arr?",JSON.stringify(this._listeners));throw new Error("Attempted to dispose unknown listener")}this._size--;a[x]=void 0;const q=this._deliveryQueue.current===this;if(this._size*ll<=a.length){let b=0;for(let u=0;u<a.length;u++){if(a[u]){a[b++]=a[u]}else if(q&&b<this._deliveryQueue.end){this._deliveryQueue.end--;if(b<this._deliveryQueue.i){this._deliveryQueue.i--}}}a.length=b}}_deliver(t,a){if(!t){return}const x=this._options?.onListenerError||Ao;if(!x){t.value(a);return}try{t.value(a)}catch(q){x(q)}}_deliverQueue(t){const a=t.current._listeners;while(t.i<t.end){this._deliver(a[t.i++],t.value)}t.reset()}fire(t){if(this._deliveryQueue?.current){this._deliverQueue(this._deliveryQueue);this._perfMon?.stop()}this._perfMon?.start(this._size);if(!this._listeners);else if(this._listeners instanceof Ho){this._deliver(this._listeners,t)}else{const a=this._deliveryQueue;a.enqueue(this,t,this._listeners.length);this._deliverQueue(a)}this._perfMon?.stop()}hasListeners(){return this._size>0}}class cl{constructor(){this.i=-1;this.end=0}enqueue(t,a,x){this.i=0;this.end=x;this.current=t;this.value=a}reset(){this.i=this.end;this.current=void 0;this.value=void 0}}const Di=Object.freeze(function(m,t){const a=setTimeout(m.bind(t),0);return{dispose(){clearTimeout(a)}}});var pi;(function(m){function t(a){if(a===m.None||a===m.Cancelled){return true}if(a instanceof dl){return true}if(!a||typeof a!=="object"){return false}return typeof a.isCancellationRequested==="boolean"&&typeof a.onCancellationRequested==="function"}m.isCancellationToken=t;m.None=Object.freeze({isCancellationRequested:false,onCancellationRequested:Oo.None});m.Cancelled=Object.freeze({isCancellationRequested:true,onCancellationRequested:Di})})(pi||(pi={}));class dl{constructor(){this._isCancelled=false;this._emitter=null}cancel(){if(!this._isCancelled){this._isCancelled=true;if(this._emitter){this._emitter.fire(void 0);this.dispose()}}}get isCancellationRequested(){return this._isCancelled}get onCancellationRequested(){if(this._isCancelled){return Di}if(!this._emitter){this._emitter=new sa}return this._emitter.event}dispose(){if(this._emitter){this._emitter.dispose();this._emitter=null}}}function Fi(){return globalThis._VSCODE_NLS_LANGUAGE}Fi()==="pseudo"||typeof document!=="undefined"&&document.location&&typeof document.location.hash==="string"&&document.location.hash.indexOf("pseudo=true")>=0;const co="en";let Jo=false;let Yo=false;let jo=false;let Oi=false;let oi=false;let Io=void 0;let Co=co;let fi=co;let hl=void 0;let Aa=void 0;const Ma=globalThis;let qr=void 0;if(typeof Ma.vscode!=="undefined"&&typeof Ma.vscode.process!=="undefined"){qr=Ma.vscode.process}else if(typeof process!=="undefined"&&typeof process?.versions?.node==="string"){qr=process}const pl=typeof qr?.versions?.electron==="string";const fl=pl&&qr?.type==="renderer";if(typeof qr==="object"){Jo=qr.platform==="win32";Yo=qr.platform==="darwin";jo=qr.platform==="linux";jo&&!!qr.env["SNAP"]&&!!qr.env["SNAP_REVISION"];!!qr.env["CI"]||!!qr.env["BUILD_ARTIFACTSTAGINGDIRECTORY"];Io=co;Co=co;const m=qr.env["VSCODE_NLS_CONFIG"];if(m){try{const t=JSON.parse(m);Io=t.userLocale;fi=t.osLocale;Co=t.resolvedLanguage||co;hl=t.languagePack?.translationsConfigFile}catch(t){}}Oi=true}else if(typeof navigator==="object"&&!fl){Aa=navigator.userAgent;Jo=Aa.indexOf("Windows")>=0;Yo=Aa.indexOf("Macintosh")>=0;(Aa.indexOf("Macintosh")>=0||Aa.indexOf("iPad")>=0||Aa.indexOf("iPhone")>=0)&&!!navigator.maxTouchPoints&&navigator.maxTouchPoints>0;jo=Aa.indexOf("Linux")>=0;Aa?.indexOf("Mobi")>=0;oi=true;Co=Fi()||co;Io=navigator.language.toLowerCase();fi=Io}else{console.error("Unable to resolve platform.")}const po=Jo;const ml=Yo;const gl=Oi;const yl=oi;const bl=oi&&typeof Ma.importScripts==="function";const kl=bl?Ma.origin:void 0;const aa=Aa;const La=Co;var mi;(function(m){function t(){return La}m.value=t;function a(){if(La.length===2){return La==="en"}else if(La.length>=3){return La[0]==="e"&&La[1]==="n"&&La[2]==="-"}else{return false}}m.isDefaultVariant=a;function x(){return La==="en"}m.isDefault=x})(mi||(mi={}));const wl=typeof Ma.postMessage==="function"&&!Ma.importScripts;(()=>{if(wl){const m=[];Ma.addEventListener("message",a=>{if(a.data&&a.data.vscodeScheduleAsyncWork){for(let x=0,q=m.length;x<q;x++){const b=m[x];if(b.id===a.data.vscodeScheduleAsyncWork){m.splice(x,1);b.callback();return}}}});let t=0;return a=>{const x=++t;m.push({id:x,callback:a});Ma.postMessage({vscodeScheduleAsyncWork:x},"*")}}return m=>setTimeout(m)})();const vl=!!(aa&&aa.indexOf("Chrome")>=0);!!(aa&&aa.indexOf("Firefox")>=0);!!(!vl&&(aa&&aa.indexOf("Safari")>=0));!!(aa&&aa.indexOf("Edg/")>=0);!!(aa&&aa.indexOf("Android")>=0);var gi={};let oo;const Go=globalThis.vscode;if(typeof Go!=="undefined"&&typeof Go.process!=="undefined"){const m=Go.process;oo={get platform(){return m.platform},get arch(){return m.arch},get env(){return m.env},cwd(){return m.cwd()}}}else if(typeof process!=="undefined"&&typeof process?.versions?.node==="string"){oo={get platform(){return process.platform},get arch(){return process.arch},get env(){return gi},cwd(){return gi["VSCODE_CWD"]||process.cwd()}}}else{oo={get platform(){return po?"win32":ml?"darwin":"linux"},get arch(){return void 0},get env(){return{}},cwd(){return"/"}}}const Lo=oo.cwd;const Nl=oo.env;const xl=oo.platform;oo.arch;const _l=65;const Sl=97;const Tl=90;const Il=122;const za=46;const tr=47;const $r=92;const Pa=58;const El=63;class Bi extends Error{constructor(t,a,x){let q;if(typeof a==="string"&&a.indexOf("not ")===0){q="must not be";a=a.replace(/^not /,"")}else{q="must be"}const b=t.indexOf(".")!==-1?"property":"argument";let u=`The "${t}" ${b} ${q} of type ${a}`;u+=`. Received type ${typeof x}`;super(u);this.code="ERR_INVALID_ARG_TYPE"}}function Al(m,t){if(m===null||typeof m!=="object"){throw new Bi(t,"Object",m)}}function Bn(m,t){if(typeof m!=="string"){throw new Bi(t,"string",m)}}const ds=xl==="win32";function en(m){return m===tr||m===$r}function ei(m){return m===tr}function Ra(m){return m>=_l&&m<=Tl||m>=Sl&&m<=Il}function Po(m,t,a,x){let q="";let b=0;let u=-1;let e=0;let g=0;for(let n=0;n<=m.length;++n){if(n<m.length){g=m.charCodeAt(n)}else if(x(g)){break}else{g=tr}if(x(g)){if(u===n-1||e===1);else if(e===2){if(q.length<2||b!==2||q.charCodeAt(q.length-1)!==za||q.charCodeAt(q.length-2)!==za){if(q.length>2){const h=q.lastIndexOf(a);if(h===-1){q="";b=0}else{q=q.slice(0,h);b=q.length-1-q.lastIndexOf(a)}u=n;e=0;continue}else if(q.length!==0){q="";b=0;u=n;e=0;continue}}if(t){q+=q.length>0?`${a}..`:"..";b=2}}else{if(q.length>0){q+=`${a}${m.slice(u+1,n)}`}else{q=m.slice(u+1,n)}b=n-u-1}u=n;e=0}else if(g===za&&e!==-1){++e}else{e=-1}}return q}function Ml(m){return m?`${m[0]==="."?"":"."}${m}`:""}function Li(m,t){Al(t,"pathObject");const a=t.dir||t.root;const x=t.base||`${t.name||""}${Ml(t.ext)}`;if(!a){return x}return a===t.root?`${a}${x}`:`${a}${m}${x}`}const Qn={resolve(...m){let t="";let a="";let x=false;for(let q=m.length-1;q>=-1;q--){let b;if(q>=0){b=m[q];Bn(b,`paths[${q}]`);if(b.length===0){continue}}else if(t.length===0){b=Lo()}else{b=Nl[`=${t}`]||Lo();if(b===void 0||b.slice(0,2).toLowerCase()!==t.toLowerCase()&&b.charCodeAt(2)===$r){b=`${t}\\`}}const u=b.length;let e=0;let g="";let n=false;const h=b.charCodeAt(0);if(u===1){if(en(h)){e=1;n=true}}else if(en(h)){n=true;if(en(b.charCodeAt(1))){let i=2;let w=i;while(i<u&&!en(b.charCodeAt(i))){i++}if(i<u&&i!==w){const k=b.slice(w,i);w=i;while(i<u&&en(b.charCodeAt(i))){i++}if(i<u&&i!==w){w=i;while(i<u&&!en(b.charCodeAt(i))){i++}if(i===u||i!==w){g=`\\\\${k}\\${b.slice(w,i)}`;e=i}}}}else{e=1}}else if(Ra(h)&&b.charCodeAt(1)===Pa){g=b.slice(0,2);e=2;if(u>2&&en(b.charCodeAt(2))){n=true;e=3}}if(g.length>0){if(t.length>0){if(g.toLowerCase()!==t.toLowerCase()){continue}}else{t=g}}if(x){if(t.length>0){break}}else{a=`${b.slice(e)}\\${a}`;x=n;if(n&&t.length>0){break}}}a=Po(a,!x,"\\",en);return x?`${t}\\${a}`:`${t}${a}`||"."},normalize(m){Bn(m,"path");const t=m.length;if(t===0){return"."}let a=0;let x;let q=false;const b=m.charCodeAt(0);if(t===1){return ei(b)?"\\":m}if(en(b)){q=true;if(en(m.charCodeAt(1))){let e=2;let g=e;while(e<t&&!en(m.charCodeAt(e))){e++}if(e<t&&e!==g){const n=m.slice(g,e);g=e;while(e<t&&en(m.charCodeAt(e))){e++}if(e<t&&e!==g){g=e;while(e<t&&!en(m.charCodeAt(e))){e++}if(e===t){return`\\\\${n}\\${m.slice(g)}\\`}if(e!==g){x=`\\\\${n}\\${m.slice(g,e)}`;a=e}}}}else{a=1}}else if(Ra(b)&&m.charCodeAt(1)===Pa){x=m.slice(0,2);a=2;if(t>2&&en(m.charCodeAt(2))){q=true;a=3}}let u=a<t?Po(m.slice(a),!q,"\\",en):"";if(u.length===0&&!q){u="."}if(u.length>0&&en(m.charCodeAt(t-1))){u+="\\"}if(x===void 0){return q?`\\${u}`:u}return q?`${x}\\${u}`:`${x}${u}`},isAbsolute(m){Bn(m,"path");const t=m.length;if(t===0){return false}const a=m.charCodeAt(0);return en(a)||t>2&&Ra(a)&&m.charCodeAt(1)===Pa&&en(m.charCodeAt(2))},join(...m){if(m.length===0){return"."}let t;let a;for(let b=0;b<m.length;++b){const u=m[b];Bn(u,"path");if(u.length>0){if(t===void 0){t=a=u}else{t+=`\\${u}`}}}if(t===void 0){return"."}let x=true;let q=0;if(typeof a==="string"&&en(a.charCodeAt(0))){++q;const b=a.length;if(b>1&&en(a.charCodeAt(1))){++q;if(b>2){if(en(a.charCodeAt(2))){++q}else{x=false}}}}if(x){while(q<t.length&&en(t.charCodeAt(q))){q++}if(q>=2){t=`\\${t.slice(q)}`}}return Qn.normalize(t)},relative(m,t){Bn(m,"from");Bn(t,"to");if(m===t){return""}const a=Qn.resolve(m);const x=Qn.resolve(t);if(a===x){return""}m=a.toLowerCase();t=x.toLowerCase();if(m===t){return""}let q=0;while(q<m.length&&m.charCodeAt(q)===$r){q++}let b=m.length;while(b-1>q&&m.charCodeAt(b-1)===$r){b--}const u=b-q;let e=0;while(e<t.length&&t.charCodeAt(e)===$r){e++}let g=t.length;while(g-1>e&&t.charCodeAt(g-1)===$r){g--}const n=g-e;const h=u<n?u:n;let i=-1;let w=0;for(;w<h;w++){const I=m.charCodeAt(q+w);if(I!==t.charCodeAt(e+w)){break}else if(I===$r){i=w}}if(w!==h){if(i===-1){return x}}else{if(n>h){if(t.charCodeAt(e+w)===$r){return x.slice(e+w+1)}if(w===2){return x.slice(e+w)}}if(u>h){if(m.charCodeAt(q+w)===$r){i=w}else if(w===2){i=3}}if(i===-1){i=0}}let k="";for(w=q+i+1;w<=b;++w){if(w===b||m.charCodeAt(w)===$r){k+=k.length===0?"..":"\\.."}}e+=i;if(k.length>0){return`${k}${x.slice(e,g)}`}if(x.charCodeAt(e)===$r){++e}return x.slice(e,g)},toNamespacedPath(m){if(typeof m!=="string"||m.length===0){return m}const t=Qn.resolve(m);if(t.length<=2){return m}if(t.charCodeAt(0)===$r){if(t.charCodeAt(1)===$r){const a=t.charCodeAt(2);if(a!==El&&a!==za){return`\\\\?\\UNC\\${t.slice(2)}`}}}else if(Ra(t.charCodeAt(0))&&t.charCodeAt(1)===Pa&&t.charCodeAt(2)===$r){return`\\\\?\\${t}`}return m},dirname(m){Bn(m,"path");const t=m.length;if(t===0){return"."}let a=-1;let x=0;const q=m.charCodeAt(0);if(t===1){return en(q)?m:"."}if(en(q)){a=x=1;if(en(m.charCodeAt(1))){let e=2;let g=e;while(e<t&&!en(m.charCodeAt(e))){e++}if(e<t&&e!==g){g=e;while(e<t&&en(m.charCodeAt(e))){e++}if(e<t&&e!==g){g=e;while(e<t&&!en(m.charCodeAt(e))){e++}if(e===t){return m}if(e!==g){a=x=e+1}}}}}else if(Ra(q)&&m.charCodeAt(1)===Pa){a=t>2&&en(m.charCodeAt(2))?3:2;x=a}let b=-1;let u=true;for(let e=t-1;e>=x;--e){if(en(m.charCodeAt(e))){if(!u){b=e;break}}else{u=false}}if(b===-1){if(a===-1){return"."}b=a}return m.slice(0,b)},basename(m,t){if(t!==void 0){Bn(t,"suffix")}Bn(m,"path");let a=0;let x=-1;let q=true;let b;if(m.length>=2&&Ra(m.charCodeAt(0))&&m.charCodeAt(1)===Pa){a=2}if(t!==void 0&&t.length>0&&t.length<=m.length){if(t===m){return""}let u=t.length-1;let e=-1;for(b=m.length-1;b>=a;--b){const g=m.charCodeAt(b);if(en(g)){if(!q){a=b+1;break}}else{if(e===-1){q=false;e=b+1}if(u>=0){if(g===t.charCodeAt(u)){if(--u===-1){x=b}}else{u=-1;x=e}}}}if(a===x){x=e}else if(x===-1){x=m.length}return m.slice(a,x)}for(b=m.length-1;b>=a;--b){if(en(m.charCodeAt(b))){if(!q){a=b+1;break}}else if(x===-1){q=false;x=b+1}}if(x===-1){return""}return m.slice(a,x)},extname(m){Bn(m,"path");let t=0;let a=-1;let x=0;let q=-1;let b=true;let u=0;if(m.length>=2&&m.charCodeAt(1)===Pa&&Ra(m.charCodeAt(0))){t=x=2}for(let e=m.length-1;e>=t;--e){const g=m.charCodeAt(e);if(en(g)){if(!b){x=e+1;break}continue}if(q===-1){b=false;q=e+1}if(g===za){if(a===-1){a=e}else if(u!==1){u=1}}else if(a!==-1){u=-1}}if(a===-1||q===-1||u===0||u===1&&a===q-1&&a===x+1){return""}return m.slice(a,q)},format:Li.bind(null,"\\"),parse(m){Bn(m,"path");const t={root:"",dir:"",base:"",ext:"",name:""};if(m.length===0){return t}const a=m.length;let x=0;let q=m.charCodeAt(0);if(a===1){if(en(q)){t.root=t.dir=m;return t}t.base=t.name=m;return t}if(en(q)){x=1;if(en(m.charCodeAt(1))){let i=2;let w=i;while(i<a&&!en(m.charCodeAt(i))){i++}if(i<a&&i!==w){w=i;while(i<a&&en(m.charCodeAt(i))){i++}if(i<a&&i!==w){w=i;while(i<a&&!en(m.charCodeAt(i))){i++}if(i===a){x=i}else if(i!==w){x=i+1}}}}}else if(Ra(q)&&m.charCodeAt(1)===Pa){if(a<=2){t.root=t.dir=m;return t}x=2;if(en(m.charCodeAt(2))){if(a===3){t.root=t.dir=m;return t}x=3}}if(x>0){t.root=m.slice(0,x)}let b=-1;let u=x;let e=-1;let g=true;let n=m.length-1;let h=0;for(;n>=x;--n){q=m.charCodeAt(n);if(en(q)){if(!g){u=n+1;break}continue}if(e===-1){g=false;e=n+1}if(q===za){if(b===-1){b=n}else if(h!==1){h=1}}else if(b!==-1){h=-1}}if(e!==-1){if(b===-1||h===0||h===1&&b===e-1&&b===u+1){t.base=t.name=m.slice(u,e)}else{t.name=m.slice(u,b);t.base=m.slice(u,e);t.ext=m.slice(b,e)}}if(u>0&&u!==x){t.dir=m.slice(0,u-1)}else{t.dir=t.root}return t},sep:"\\",delimiter:";",win32:null,posix:null};const Cl=(()=>{if(ds){const m=/\\/g;return()=>{const t=Lo().replace(m,"/");return t.slice(t.indexOf("/"))}}return()=>Lo()})();const Sn={resolve(...m){let t="";let a=false;for(let x=m.length-1;x>=-1&&!a;x--){const q=x>=0?m[x]:Cl();Bn(q,`paths[${x}]`);if(q.length===0){continue}t=`${q}/${t}`;a=q.charCodeAt(0)===tr}t=Po(t,!a,"/",ei);if(a){return`/${t}`}return t.length>0?t:"."},normalize(m){Bn(m,"path");if(m.length===0){return"."}const t=m.charCodeAt(0)===tr;const a=m.charCodeAt(m.length-1)===tr;m=Po(m,!t,"/",ei);if(m.length===0){if(t){return"/"}return a?"./":"."}if(a){m+="/"}return t?`/${m}`:m},isAbsolute(m){Bn(m,"path");return m.length>0&&m.charCodeAt(0)===tr},join(...m){if(m.length===0){return"."}let t;for(let a=0;a<m.length;++a){const x=m[a];Bn(x,"path");if(x.length>0){if(t===void 0){t=x}else{t+=`/${x}`}}}if(t===void 0){return"."}return Sn.normalize(t)},relative(m,t){Bn(m,"from");Bn(t,"to");if(m===t){return""}m=Sn.resolve(m);t=Sn.resolve(t);if(m===t){return""}const a=1;const x=m.length;const q=x-a;const b=1;const u=t.length-b;const e=q<u?q:u;let g=-1;let n=0;for(;n<e;n++){const i=m.charCodeAt(a+n);if(i!==t.charCodeAt(b+n)){break}else if(i===tr){g=n}}if(n===e){if(u>e){if(t.charCodeAt(b+n)===tr){return t.slice(b+n+1)}if(n===0){return t.slice(b+n)}}else if(q>e){if(m.charCodeAt(a+n)===tr){g=n}else if(n===0){g=0}}}let h="";for(n=a+g+1;n<=x;++n){if(n===x||m.charCodeAt(n)===tr){h+=h.length===0?"..":"/.."}}return`${h}${t.slice(b+g)}`},toNamespacedPath(m){return m},dirname(m){Bn(m,"path");if(m.length===0){return"."}const t=m.charCodeAt(0)===tr;let a=-1;let x=true;for(let q=m.length-1;q>=1;--q){if(m.charCodeAt(q)===tr){if(!x){a=q;break}}else{x=false}}if(a===-1){return t?"/":"."}if(t&&a===1){return"//"}return m.slice(0,a)},basename(m,t){if(t!==void 0){Bn(t,"ext")}Bn(m,"path");let a=0;let x=-1;let q=true;let b;if(t!==void 0&&t.length>0&&t.length<=m.length){if(t===m){return""}let u=t.length-1;let e=-1;for(b=m.length-1;b>=0;--b){const g=m.charCodeAt(b);if(g===tr){if(!q){a=b+1;break}}else{if(e===-1){q=false;e=b+1}if(u>=0){if(g===t.charCodeAt(u)){if(--u===-1){x=b}}else{u=-1;x=e}}}}if(a===x){x=e}else if(x===-1){x=m.length}return m.slice(a,x)}for(b=m.length-1;b>=0;--b){if(m.charCodeAt(b)===tr){if(!q){a=b+1;break}}else if(x===-1){q=false;x=b+1}}if(x===-1){return""}return m.slice(a,x)},extname(m){Bn(m,"path");let t=-1;let a=0;let x=-1;let q=true;let b=0;for(let u=m.length-1;u>=0;--u){const e=m.charCodeAt(u);if(e===tr){if(!q){a=u+1;break}continue}if(x===-1){q=false;x=u+1}if(e===za){if(t===-1){t=u}else if(b!==1){b=1}}else if(t!==-1){b=-1}}if(t===-1||x===-1||b===0||b===1&&t===x-1&&t===a+1){return""}return m.slice(t,x)},format:Li.bind(null,"/"),parse(m){Bn(m,"path");const t={root:"",dir:"",base:"",ext:"",name:""};if(m.length===0){return t}const a=m.charCodeAt(0)===tr;let x;if(a){t.root="/";x=1}else{x=0}let q=-1;let b=0;let u=-1;let e=true;let g=m.length-1;let n=0;for(;g>=x;--g){const h=m.charCodeAt(g);if(h===tr){if(!e){b=g+1;break}continue}if(u===-1){e=false;u=g+1}if(h===za){if(q===-1){q=g}else if(n!==1){n=1}}else if(q!==-1){n=-1}}if(u!==-1){const h=b===0&&a?1:b;if(q===-1||n===0||n===1&&q===u-1&&q===b+1){t.base=t.name=m.slice(h,u)}else{t.name=m.slice(h,q);t.base=m.slice(h,u);t.ext=m.slice(q,u)}}if(b>0){t.dir=m.slice(0,b-1)}else if(a){t.dir="/"}return t},sep:"/",delimiter:":",win32:null,posix:null};Sn.win32=Qn.win32=Qn;Sn.posix=Qn.posix=Sn;const $l=ds?Qn.normalize:Sn.normalize;ds?Qn.isAbsolute:Sn.isAbsolute;const Dl=ds?Qn.join:Sn.join;const Fl=ds?Qn.resolve:Sn.resolve;const Ol=ds?Qn.relative:Sn.relative;const Bl=ds?Qn.dirname:Sn.dirname;ds?Qn.basename:Sn.basename;ds?Qn.extname:Sn.extname;ds?Qn.parse:Sn.parse;const $o=ds?Qn.sep:Sn.sep;ds?Qn.delimiter:Sn.delimiter;function Ll(m){return m}class Pl{constructor(t,a){this.lastCache=void 0;this.lastArgKey=void 0;if(typeof t==="function"){this._fn=t;this._computeKey=Ll}else{this._fn=a;this._computeKey=t.getCacheKey}}get(t){const a=this._computeKey(t);if(this.lastArgKey!==a){this.lastArgKey=a;this.lastCache=this._fn(t)}return this.lastCache}}class yi{constructor(t){this.executor=t;this._didRun=false}get hasValue(){return this._didRun}get value(){if(!this._didRun){try{this._value=this.executor()}catch(t){this._error=t}finally{this._didRun=true}}if(this._error){throw this._error}return this._value}get rawValue(){return this._value}}function Rl(m){return m.split(/\r\n|\r|\n/)}function Vl(m,t){if(m<t){return-1}else if(m>t){return 1}else{return 0}}function zl(m,t,a=0,x=m.length,q=0,b=t.length){for(;a<x&&q<b;a++,q++){const g=m.charCodeAt(a);const n=t.charCodeAt(q);if(g<n){return-1}else if(g>n){return 1}}const u=x-a;const e=b-q;if(u<e){return-1}else if(u>e){return 1}return 0}function Pi(m,t,a=0,x=m.length,q=0,b=t.length){for(;a<x&&q<b;a++,q++){let g=m.charCodeAt(a);let n=t.charCodeAt(q);if(g===n){continue}if(g>=128||n>=128){return zl(m.toLowerCase(),t.toLowerCase(),a,x,q,b)}if(bi(g)){g-=32}if(bi(n)){n-=32}const h=g-n;if(h===0){continue}return h}const u=x-a;const e=b-q;if(u<e){return-1}else if(u>e){return 1}return 0}function bi(m){return m>=97&&m<=122}function Ri(m){return m>=65&&m<=90}function Wl(m,t){return m.length===t.length&&Pi(m,t)===0}function Ul(m,t){const a=t.length;if(t.length>m.length){return false}return Pi(m,t,0,a)===0}class wo{static{this.ambiguousCharacterData=new yi(()=>{return JSON.parse('{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],"_default":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"cs":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"es":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"fr":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"it":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ja":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],"ko":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pt-BR":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ru":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"zh-hans":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],"zh-hant":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}')})}static{this.cache=new Pl({getCacheKey:JSON.stringify},t=>{function a(h){const i=new Map;for(let w=0;w<h.length;w+=2){i.set(h[w],h[w+1])}return i}function x(h,i){const w=new Map(h);for(const[k,I]of i){w.set(k,I)}return w}function q(h,i){if(!h){return i}const w=new Map;for(const[k,I]of h){if(i.has(k)){w.set(k,I)}}return w}const b=this.ambiguousCharacterData.value;let u=t.filter(h=>!h.startsWith("_")&&h in b);if(u.length===0){u=["_default"]}let e=void 0;for(const h of u){const i=a(b[h]);e=q(e,i)}const g=a(b["_common"]);const n=x(g,e);return new wo(n)})}static getInstance(t){return wo.cache.get(Array.from(t))}static{this._locales=new yi(()=>Object.keys(wo.ambiguousCharacterData.value).filter(t=>!t.startsWith("_")))}static getLocales(){return wo._locales.value}constructor(t){this.confusableDictionary=t}isAmbiguous(t){return this.confusableDictionary.has(t)}containsAmbiguousCharacter(t){for(let a=0;a<t.length;a++){const x=t.codePointAt(a);if(typeof x==="number"&&this.isAmbiguous(x)){return true}}return false}getPrimaryConfusable(t){return this.confusableDictionary.get(t)}getConfusableCodePoints(){return new Set(this.confusableDictionary.keys())}}class vo{static getRawData(){return JSON.parse("[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]")}static{this._data=void 0}static getData(){if(!this._data){this._data=new Set(vo.getRawData())}return this._data}static isInvisibleCharacter(t){return vo.getData().has(t)}static containsInvisibleCharacter(t){for(let a=0;a<t.length;a++){const x=t.codePointAt(a);if(typeof x==="number"&&vo.isInvisibleCharacter(x)){return true}}return false}static get codePoints(){return vo.getData()}}function Va(m){return m===47||m===92}function Vi(m){return m.replace(/[\\/]/g,Sn.sep)}function ql(m){if(m.indexOf("/")===-1){m=Vi(m)}if(/^[a-zA-Z]:(\/|$)/.test(m)){m="/"+m}return m}function ki(m,t=Sn.sep){if(!m){return""}const a=m.length;const x=m.charCodeAt(0);if(Va(x)){if(Va(m.charCodeAt(1))){if(!Va(m.charCodeAt(2))){let b=3;const u=b;for(;b<a;b++){if(Va(m.charCodeAt(b))){break}}if(u!==b&&!Va(m.charCodeAt(b+1))){b+=1;for(;b<a;b++){if(Va(m.charCodeAt(b))){return m.slice(0,b+1).replace(/[\\/]/g,t)}}}}}return t}else if(Hl(x)){if(m.charCodeAt(1)===58){if(Va(m.charCodeAt(2))){return m.slice(0,2)+t}else{return m.slice(0,2)}}}let q=m.indexOf("://");if(q!==-1){q+=3;for(;q<a;q++){if(Va(m.charCodeAt(q))){return m.slice(0,q+1)}}}return""}function wi(m,t,a,x=$o){if(m===t){return true}if(!m||!t){return false}if(t.length>m.length){return false}if(a){const q=Ul(m,t);if(!q){return false}if(t.length===m.length){return true}let b=t.length;if(t.charAt(t.length-1)===x){b--}return m.charAt(b)===x}if(t.charAt(t.length-1)!==x){t+=x}return m.indexOf(t)===0}function Hl(m){return m>=65&&m<=90||m>=97&&m<=122}const jl=/^\w[\w\d+.-]*$/;const Gl=/^\//;const Kl=/^\/\//;function Xl(m,t){if(!m.scheme&&t){throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${m.authority}", path: "${m.path}", query: "${m.query}", fragment: "${m.fragment}"}`)}if(m.scheme&&!jl.test(m.scheme)){throw new Error("[UriError]: Scheme contains illegal characters.")}if(m.path){if(m.authority){if(!Gl.test(m.path)){throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character')}}else{if(Kl.test(m.path)){throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")')}}}}function Zl(m,t){if(!m&&!t){return"file"}return m}function Ql(m,t){switch(m){case"https":case"http":case"file":if(!t){t=$s}else if(t[0]!==$s){t=$s+t}break}return t}const In="";const $s="/";const Jl=/^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;class or{static isUri(t){if(t instanceof or){return true}if(!t){return false}return typeof t.authority==="string"&&typeof t.fragment==="string"&&typeof t.path==="string"&&typeof t.query==="string"&&typeof t.scheme==="string"&&typeof t.fsPath==="string"&&typeof t.with==="function"&&typeof t.toString==="function"}constructor(t,a,x,q,b,u=false){if(typeof t==="object"){this.scheme=t.scheme||In;this.authority=t.authority||In;this.path=t.path||In;this.query=t.query||In;this.fragment=t.fragment||In}else{this.scheme=Zl(t,u);this.authority=a||In;this.path=Ql(this.scheme,x||In);this.query=q||In;this.fragment=b||In;Xl(this,u)}}get fsPath(){return Ro(this,false)}with(t){if(!t){return this}let{scheme:a,authority:x,path:q,query:b,fragment:u}=t;if(a===void 0){a=this.scheme}else if(a===null){a=In}if(x===void 0){x=this.authority}else if(x===null){x=In}if(q===void 0){q=this.path}else if(q===null){q=In}if(b===void 0){b=this.query}else if(b===null){b=In}if(u===void 0){u=this.fragment}else if(u===null){u=In}if(a===this.scheme&&x===this.authority&&q===this.path&&b===this.query&&u===this.fragment){return this}return new io(a,x,q,b,u)}static parse(t,a=false){const x=Jl.exec(t);if(!x){return new io(In,In,In,In,In)}return new io(x[2]||In,Eo(x[4]||In),Eo(x[5]||In),Eo(x[7]||In),Eo(x[9]||In),a)}static file(t){let a=In;if(po){t=t.replace(/\\/g,$s)}if(t[0]===$s&&t[1]===$s){const x=t.indexOf($s,2);if(x===-1){a=t.substring(2);t=$s}else{a=t.substring(2,x);t=t.substring(x)||$s}}return new io("file",a,t,In,In)}static from(t,a){const x=new io(t.scheme,t.authority,t.path,t.query,t.fragment,a);return x}static joinPath(t,...a){if(!t.path){throw new Error(`[UriError]: cannot call joinPath on URI without path`)}let x;if(po&&t.scheme==="file"){x=or.file(Qn.join(Ro(t,true),...a)).path}else{x=Sn.join(t.path,...a)}return t.with({path:x})}toString(t=false){return ti(this,t)}toJSON(){return this}static revive(t){if(!t){return t}else if(t instanceof or){return t}else{const a=new io(t);a._formatted=t.external??null;a._fsPath=t._sep===zi?t.fsPath??null:null;return a}}[Symbol.for("debug.description")](){return`URI(${this.toString()})`}}const zi=po?1:void 0;class io extends or{constructor(){super(...arguments);this._formatted=null;this._fsPath=null}get fsPath(){if(!this._fsPath){this._fsPath=Ro(this,false)}return this._fsPath}toString(t=false){if(!t){if(!this._formatted){this._formatted=ti(this,false)}return this._formatted}else{return ti(this,true)}}toJSON(){const t={$mid:1};if(this._fsPath){t.fsPath=this._fsPath;t._sep=zi}if(this._formatted){t.external=this._formatted}if(this.path){t.path=this.path}if(this.scheme){t.scheme=this.scheme}if(this.authority){t.authority=this.authority}if(this.query){t.query=this.query}if(this.fragment){t.fragment=this.fragment}return t}}const Wi={[58]:"%3A",[47]:"%2F",[63]:"%3F",[35]:"%23",[91]:"%5B",[93]:"%5D",[64]:"%40",[33]:"%21",[36]:"%24",[38]:"%26",[39]:"%27",[40]:"%28",[41]:"%29",[42]:"%2A",[43]:"%2B",[44]:"%2C",[59]:"%3B",[61]:"%3D",[32]:"%20"};function vi(m,t,a){let x=void 0;let q=-1;for(let b=0;b<m.length;b++){const u=m.charCodeAt(b);if(u>=97&&u<=122||u>=65&&u<=90||u>=48&&u<=57||u===45||u===46||u===95||u===126||t&&u===47||a&&u===91||a&&u===93||a&&u===58){if(q!==-1){x+=encodeURIComponent(m.substring(q,b));q=-1}if(x!==void 0){x+=m.charAt(b)}}else{if(x===void 0){x=m.substr(0,b)}const e=Wi[u];if(e!==void 0){if(q!==-1){x+=encodeURIComponent(m.substring(q,b));q=-1}x+=e}else if(q===-1){q=b}}}if(q!==-1){x+=encodeURIComponent(m.substring(q))}return x!==void 0?x:m}function Yl(m){let t=void 0;for(let a=0;a<m.length;a++){const x=m.charCodeAt(a);if(x===35||x===63){if(t===void 0){t=m.substr(0,a)}t+=Wi[x]}else{if(t!==void 0){t+=m[a]}}}return t!==void 0?t:m}function Ro(m,t){let a;if(m.authority&&m.path.length>1&&m.scheme==="file"){a=`//${m.authority}${m.path}`}else if(m.path.charCodeAt(0)===47&&(m.path.charCodeAt(1)>=65&&m.path.charCodeAt(1)<=90||m.path.charCodeAt(1)>=97&&m.path.charCodeAt(1)<=122)&&m.path.charCodeAt(2)===58){if(!t){a=m.path[1].toLowerCase()+m.path.substr(2)}else{a=m.path.substr(1)}}else{a=m.path}if(po){a=a.replace(/\//g,"\\")}return a}function ti(m,t){const a=!t?vi:Yl;let x="";let{scheme:q,authority:b,path:u,query:e,fragment:g}=m;if(q){x+=q;x+=":"}if(b||q==="file"){x+=$s;x+=$s}if(b){let n=b.indexOf("@");if(n!==-1){const h=b.substr(0,n);b=b.substr(n+1);n=h.lastIndexOf(":");if(n===-1){x+=a(h,false,false)}else{x+=a(h.substr(0,n),false,false);x+=":";x+=a(h.substr(n+1),false,true)}x+="@"}b=b.toLowerCase();n=b.lastIndexOf(":");if(n===-1){x+=a(b,false,true)}else{x+=a(b.substr(0,n),false,true);x+=b.substr(n)}}if(u){if(u.length>=3&&u.charCodeAt(0)===47&&u.charCodeAt(2)===58){const n=u.charCodeAt(1);if(n>=65&&n<=90){u=`/${String.fromCharCode(n+32)}:${u.substr(3)}`}}else if(u.length>=2&&u.charCodeAt(1)===58){const n=u.charCodeAt(0);if(n>=65&&n<=90){u=`${String.fromCharCode(n+32)}:${u.substr(2)}`}}x+=a(u,true,false)}if(e){x+="?";x+=a(e,false,false)}if(g){x+="#";x+=!t?vi(g,false,false):g}return x}function Ui(m){try{return decodeURIComponent(m)}catch{if(m.length>3){return m.substr(0,3)+Ui(m.substr(3))}else{return m}}}const Ni=/(%[0-9A-Za-z][0-9A-Za-z])+/g;function Eo(m){if(!m.match(Ni)){return m}return m.replace(Ni,t=>Ui(t))}var ar;(function(m){m.inMemory="inmemory";m.vscode="vscode";m.internal="private";m.walkThrough="walkThrough";m.walkThroughSnippet="walkThroughSnippet";m.http="http";m.https="https";m.file="file";m.mailto="mailto";m.untitled="untitled";m.data="data";m.command="command";m.vscodeRemote="vscode-remote";m.vscodeRemoteResource="vscode-remote-resource";m.vscodeManagedRemoteResource="vscode-managed-remote-resource";m.vscodeUserData="vscode-userdata";m.vscodeCustomEditor="vscode-custom-editor";m.vscodeNotebookCell="vscode-notebook-cell";m.vscodeNotebookCellMetadata="vscode-notebook-cell-metadata";m.vscodeNotebookCellMetadataDiff="vscode-notebook-cell-metadata-diff";m.vscodeNotebookCellOutput="vscode-notebook-cell-output";m.vscodeNotebookCellOutputDiff="vscode-notebook-cell-output-diff";m.vscodeNotebookMetadata="vscode-notebook-metadata";m.vscodeInteractiveInput="vscode-interactive-input";m.vscodeSettings="vscode-settings";m.vscodeWorkspaceTrust="vscode-workspace-trust";m.vscodeTerminal="vscode-terminal";m.vscodeChatCodeBlock="vscode-chat-code-block";m.vscodeChatCodeCompareBlock="vscode-chat-code-compare-block";m.vscodeChatSesssion="vscode-chat-editor";m.webviewPanel="webview-panel";m.vscodeWebview="vscode-webview";m.extension="extension";m.vscodeFileResource="vscode-file";m.tmp="tmp";m.vsls="vsls";m.vscodeSourceControl="vscode-scm";m.commentsInput="comment";m.codeSetting="code-setting";m.outputChannel="output";m.accessibleView="accessible-view"})(ar||(ar={}));const ec="tkn";class tc{constructor(){this._hosts=Object.create(null);this._ports=Object.create(null);this._connectionTokens=Object.create(null);this._preferredWebSchema="http";this._delegate=null;this._serverRootPath="/"}setPreferredWebSchema(t){this._preferredWebSchema=t}setDelegate(t){this._delegate=t}setServerRootPath(t,a){this._serverRootPath=rc(t,a)}getServerRootPath(){return this._serverRootPath}get _remoteResourcesPath(){return Sn.join(this._serverRootPath,ar.vscodeRemoteResource)}set(t,a,x){this._hosts[t]=a;this._ports[t]=x}setConnectionToken(t,a){this._connectionTokens[t]=a}getPreferredWebSchema(){return this._preferredWebSchema}rewrite(t){if(this._delegate){try{return this._delegate(t)}catch(e){Ao(e);return t}}const a=t.authority;let x=this._hosts[a];if(x&&x.indexOf(":")!==-1&&x.indexOf("[")===-1){x=`[${x}]`}const q=this._ports[a];const b=this._connectionTokens[a];let u=`path=${encodeURIComponent(t.path)}`;if(typeof b==="string"){u+=`&${ec}=${encodeURIComponent(b)}`}return or.from({scheme:yl?this._preferredWebSchema:ar.vscodeRemoteResource,authority:`${x}:${q}`,path:this._remoteResourcesPath,query:u})}}const nc=new tc;function rc(m,t){return Sn.join(t??"/",`${m.quality??"oss"}-${m.commit??"dev"}`)}const sc="vscode-app";class No{constructor(){this.staticBrowserUris=new lo;this.appResourcePathUrls=new Map}static{this.FALLBACK_AUTHORITY=sc}registerAppResourcePathUrl(t,a){this.appResourcePathUrls.set(t,a)}toUrl(t){let a=this.appResourcePathUrls.get(t);if(typeof a==="function"){a=a()}return new URL(a??t,globalThis.location?.href??import.meta.url).toString()}asBrowserUri(t){const a=this.toUri(t,{toUrl:this.toUrl.bind(this)});return this.uriToBrowserUri(a)}uriToBrowserUri(t){if(t.scheme===ar.vscodeRemote){return nc.rewrite(t)}if(t.scheme===ar.file&&(gl||kl===`${ar.vscodeFileResource}://${No.FALLBACK_AUTHORITY}`)){return t.with({scheme:ar.vscodeFileResource,authority:t.authority||No.FALLBACK_AUTHORITY,query:null,fragment:null})}return this.staticBrowserUris.get(t)??t}asFileUri(t){const a=this.toUri(t,{toUrl:this.toUrl.bind(this)});return this.uriToFileUri(a)}uriToFileUri(t){if(t.scheme===ar.vscodeFileResource){return t.with({scheme:ar.file,authority:t.authority!==No.FALLBACK_AUTHORITY?t.authority:null,query:null,fragment:null})}return t}toUri(t,a){if(or.isUri(t)){return t}if(globalThis._VSCODE_FILE_ROOT){const x=globalThis._VSCODE_FILE_ROOT;if(/^\w[\w\d+.-]*:\/\//.test(x)){return or.joinPath(or.parse(x,true),t)}const q=Dl(x,t);return or.file(q)}return or.parse(a.toUrl(t))}registerStaticBrowserUri(t,a){this.staticBrowserUris.set(t,a);return ri(()=>{if(this.staticBrowserUris.get(t)===a){this.staticBrowserUris.delete(t)}})}getRegisteredBrowserUris(){return this.staticBrowserUris.keys()}}new No;var xi;(function(m){const t=new Map([["1",{"Cross-Origin-Opener-Policy":"same-origin"}],["2",{"Cross-Origin-Embedder-Policy":"require-corp"}],["3",{"Cross-Origin-Opener-Policy":"same-origin","Cross-Origin-Embedder-Policy":"require-corp"}]]);m.CoopAndCoep=Object.freeze(t.get("3"));const a="vscode-coi";function x(b){let u;if(typeof b==="string"){u=new URL(b).searchParams}else if(b instanceof URL){u=b.searchParams}else if(or.isUri(b)){u=new URL(b.toString(true)).searchParams}const e=u?.get(a);if(!e){return void 0}return t.get(e)}m.getHeadersFromQuery=x;function q(b,u,e){if(!globalThis.crossOriginIsolated){return}const g=u&&e?"3":e?"2":"1";if(b instanceof URLSearchParams){b.set(a,g)}else{b[a]=g}}m.addSearchParam=q})(xi||(xi={}));function Ea(m){return Ro(m,true)}class ac{constructor(t){this._ignorePathCasing=t}compare(t,a,x=false){if(t===a){return 0}return Vl(this.getComparisonKey(t,x),this.getComparisonKey(a,x))}isEqual(t,a,x=false){if(t===a){return true}if(!t||!a){return false}return this.getComparisonKey(t,x)===this.getComparisonKey(a,x)}getComparisonKey(t,a=false){return t.with({path:this._ignorePathCasing(t)?t.path.toLowerCase():void 0,fragment:a?null:void 0}).toString()}ignorePathCasing(t){return this._ignorePathCasing(t)}isEqualOrParent(t,a,x=false){if(t.scheme===a.scheme){if(t.scheme===ar.file){return wi(Ea(t),Ea(a),this._ignorePathCasing(t))&&t.query===a.query&&(x||t.fragment===a.fragment)}if(_i(t.authority,a.authority)){return wi(t.path,a.path,this._ignorePathCasing(t),"/")&&t.query===a.query&&(x||t.fragment===a.fragment)}}return false}joinPath(t,...a){return or.joinPath(t,...a)}basenameOrAuthority(t){return oc(t)||t.authority}basename(t){return Sn.basename(t.path)}extname(t){return Sn.extname(t.path)}dirname(t){if(t.path.length===0){return t}let a;if(t.scheme===ar.file){a=or.file(Bl(Ea(t))).path}else{a=Sn.dirname(t.path);if(t.authority&&a.length&&a.charCodeAt(0)!==47){console.error(`dirname("${t.toString})) resulted in a relative path`);a="/"}}return t.with({path:a})}normalizePath(t){if(!t.path.length){return t}let a;if(t.scheme===ar.file){a=or.file($l(Ea(t))).path}else{a=Sn.normalize(t.path)}return t.with({path:a})}relativePath(t,a){if(t.scheme!==a.scheme||!_i(t.authority,a.authority)){return void 0}if(t.scheme===ar.file){const b=Ol(Ea(t),Ea(a));return po?Vi(b):b}let x=t.path||"/";const q=a.path||"/";if(this._ignorePathCasing(t)){let b=0;for(const u=Math.min(x.length,q.length);b<u;b++){if(x.charCodeAt(b)!==q.charCodeAt(b)){if(x.charAt(b).toLowerCase()!==q.charAt(b).toLowerCase()){break}}}x=q.substr(0,b)+x.substr(b)}return Sn.relative(x,q)}resolvePath(t,a){if(t.scheme===ar.file){const x=or.file(Fl(Ea(t),a));return t.with({authority:x.authority,path:x.path})}a=ql(a);return t.with({path:Sn.resolve(t.path,a)})}isAbsolutePath(t){return!!t.path&&t.path[0]==="/"}isEqualAuthority(t,a){return t===a||t!==void 0&&a!==void 0&&Wl(t,a)}hasTrailingPathSeparator(t,a=$o){if(t.scheme===ar.file){const x=Ea(t);return x.length>ki(x).length&&x[x.length-1]===a}else{const x=t.path;return x.length>1&&x.charCodeAt(x.length-1)===47&&!/^[a-zA-Z]:(\/$|\\$)/.test(t.fsPath)}}removeTrailingPathSeparator(t,a=$o){if(Si(t,a)){return t.with({path:t.path.substr(0,t.path.length-1)})}return t}addTrailingPathSeparator(t,a=$o){let x=false;if(t.scheme===ar.file){const q=Ea(t);x=q!==void 0&&q.length===ki(q).length&&q[q.length-1]===a}else{a="/";const q=t.path;x=q.length===1&&q.charCodeAt(q.length-1)===47}if(!x&&!Si(t,a)){return t.with({path:t.path+"/"})}return t}}const mn=new ac(()=>false);mn.isEqual.bind(mn);mn.isEqualOrParent.bind(mn);mn.getComparisonKey.bind(mn);mn.basenameOrAuthority.bind(mn);const oc=mn.basename.bind(mn);mn.extname.bind(mn);mn.dirname.bind(mn);mn.joinPath.bind(mn);mn.normalizePath.bind(mn);mn.relativePath.bind(mn);mn.resolvePath.bind(mn);mn.isAbsolutePath.bind(mn);const _i=mn.isEqualAuthority.bind(mn);const Si=mn.hasTrailingPathSeparator.bind(mn);mn.removeTrailingPathSeparator.bind(mn);mn.addTrailingPathSeparator.bind(mn);var Ti;(function(m){m.META_DATA_LABEL="label";m.META_DATA_DESCRIPTION="description";m.META_DATA_SIZE="size";m.META_DATA_MIME="mime";function t(a){const x=new Map;const q=a.path.substring(a.path.indexOf(";")+1,a.path.lastIndexOf(";"));q.split(";").forEach(u=>{const[e,g]=u.split(":");if(e&&g){x.set(e,g)}});const b=a.path.substring(0,a.path.indexOf(";"));if(b){x.set(m.META_DATA_MIME,b)}return x}m.parseMetaData=t})(Ti||(Ti={}));var Ii;(function(m){async function t(x){let q=void 0;const b=await Promise.all(x.map(u=>u.then(e=>e,e=>{if(!q){q=e}return void 0})));if(typeof q!=="undefined"){throw q}return b}m.settled=t;function a(x){return new Promise(async(q,b)=>{try{await x(q,b)}catch(u){b(u)}})}m.withAsyncBody=a})(Ii||(Ii={}));class Ur{static fromArray(t){return new Ur(a=>{a.emitMany(t)})}static fromPromise(t){return new Ur(async a=>{a.emitMany(await t)})}static fromPromisesResolveOrder(t){return new Ur(async a=>{await Promise.all(t.map(async x=>a.emitOne(await x)))})}static merge(t){return new Ur(async a=>{await Promise.all(t.map(async x=>{for await(const q of x){a.emitOne(q)}}))})}static{this.EMPTY=Ur.fromArray([])}constructor(t,a){this._state=0;this._results=[];this._error=null;this._onReturn=a;this._onStateChanged=new sa;queueMicrotask(async()=>{const x={emitOne:q=>this.emitOne(q),emitMany:q=>this.emitMany(q),reject:q=>this.reject(q)};try{await Promise.resolve(t(x));this.resolve()}catch(q){this.reject(q)}finally{x.emitOne=void 0;x.emitMany=void 0;x.reject=void 0}})}[Symbol.asyncIterator](){let t=0;return{next:async()=>{do{if(this._state===2){throw this._error}if(t<this._results.length){return{done:false,value:this._results[t++]}}if(this._state===1){return{done:true,value:void 0}}await Oo.toPromise(this._onStateChanged.event)}while(true)},return:async()=>{this._onReturn?.();return{done:true,value:void 0}}}}static map(t,a){return new Ur(async x=>{for await(const q of t){x.emitOne(a(q))}})}map(t){return Ur.map(this,t)}static filter(t,a){return new Ur(async x=>{for await(const q of t){if(a(q)){x.emitOne(q)}}})}filter(t){return Ur.filter(this,t)}static coalesce(t){return Ur.filter(t,a=>!!a)}coalesce(){return Ur.coalesce(this)}static async toPromise(t){const a=[];for await(const x of t){a.push(x)}return a}toPromise(){return Ur.toPromise(this)}emitOne(t){if(this._state!==0){return}this._results.push(t);this._onStateChanged.fire()}emitMany(t){if(this._state!==0){return}this._results=this._results.concat(t);this._onStateChanged.fire()}resolve(){if(this._state!==0){return}this._state=1;this._onStateChanged.fire()}reject(t){if(this._state!==0){return}this._state=2;this._error=t;this._onStateChanged.fire()}}class cs{constructor(t,a){this.lineNumber=t;this.column=a}with(t=this.lineNumber,a=this.column){if(t===this.lineNumber&&a===this.column){return this}else{return new cs(t,a)}}delta(t=0,a=0){return this.with(this.lineNumber+t,this.column+a)}equals(t){return cs.equals(this,t)}static equals(t,a){if(!t&&!a){return true}return!!t&&!!a&&t.lineNumber===a.lineNumber&&t.column===a.column}isBefore(t){return cs.isBefore(this,t)}static isBefore(t,a){if(t.lineNumber<a.lineNumber){return true}if(a.lineNumber<t.lineNumber){return false}return t.column<a.column}isBeforeOrEqual(t){return cs.isBeforeOrEqual(this,t)}static isBeforeOrEqual(t,a){if(t.lineNumber<a.lineNumber){return true}if(a.lineNumber<t.lineNumber){return false}return t.column<=a.column}static compare(t,a){const x=t.lineNumber|0;const q=a.lineNumber|0;if(x===q){const b=t.column|0;const u=a.column|0;return b-u}return x-q}clone(){return new cs(this.lineNumber,this.column)}toString(){return"("+this.lineNumber+","+this.column+")"}static lift(t){return new cs(t.lineNumber,t.column)}static isIPosition(t){return t&&typeof t.lineNumber==="number"&&typeof t.column==="number"}toJSON(){return{lineNumber:this.lineNumber,column:this.column}}}class On{constructor(t,a,x,q){if(t>x||t===x&&a>q){this.startLineNumber=x;this.startColumn=q;this.endLineNumber=t;this.endColumn=a}else{this.startLineNumber=t;this.startColumn=a;this.endLineNumber=x;this.endColumn=q}}isEmpty(){return On.isEmpty(this)}static isEmpty(t){return t.startLineNumber===t.endLineNumber&&t.startColumn===t.endColumn}containsPosition(t){return On.containsPosition(this,t)}static containsPosition(t,a){if(a.lineNumber<t.startLineNumber||a.lineNumber>t.endLineNumber){return false}if(a.lineNumber===t.startLineNumber&&a.column<t.startColumn){return false}if(a.lineNumber===t.endLineNumber&&a.column>t.endColumn){return false}return true}static strictContainsPosition(t,a){if(a.lineNumber<t.startLineNumber||a.lineNumber>t.endLineNumber){return false}if(a.lineNumber===t.startLineNumber&&a.column<=t.startColumn){return false}if(a.lineNumber===t.endLineNumber&&a.column>=t.endColumn){return false}return true}containsRange(t){return On.containsRange(this,t)}static containsRange(t,a){if(a.startLineNumber<t.startLineNumber||a.endLineNumber<t.startLineNumber){return false}if(a.startLineNumber>t.endLineNumber||a.endLineNumber>t.endLineNumber){return false}if(a.startLineNumber===t.startLineNumber&&a.startColumn<t.startColumn){return false}if(a.endLineNumber===t.endLineNumber&&a.endColumn>t.endColumn){return false}return true}strictContainsRange(t){return On.strictContainsRange(this,t)}static strictContainsRange(t,a){if(a.startLineNumber<t.startLineNumber||a.endLineNumber<t.startLineNumber){return false}if(a.startLineNumber>t.endLineNumber||a.endLineNumber>t.endLineNumber){return false}if(a.startLineNumber===t.startLineNumber&&a.startColumn<=t.startColumn){return false}if(a.endLineNumber===t.endLineNumber&&a.endColumn>=t.endColumn){return false}return true}plusRange(t){return On.plusRange(this,t)}static plusRange(t,a){let x;let q;let b;let u;if(a.startLineNumber<t.startLineNumber){x=a.startLineNumber;q=a.startColumn}else if(a.startLineNumber===t.startLineNumber){x=a.startLineNumber;q=Math.min(a.startColumn,t.startColumn)}else{x=t.startLineNumber;q=t.startColumn}if(a.endLineNumber>t.endLineNumber){b=a.endLineNumber;u=a.endColumn}else if(a.endLineNumber===t.endLineNumber){b=a.endLineNumber;u=Math.max(a.endColumn,t.endColumn)}else{b=t.endLineNumber;u=t.endColumn}return new On(x,q,b,u)}intersectRanges(t){return On.intersectRanges(this,t)}static intersectRanges(t,a){let x=t.startLineNumber;let q=t.startColumn;let b=t.endLineNumber;let u=t.endColumn;const e=a.startLineNumber;const g=a.startColumn;const n=a.endLineNumber;const h=a.endColumn;if(x<e){x=e;q=g}else if(x===e){q=Math.max(q,g)}if(b>n){b=n;u=h}else if(b===n){u=Math.min(u,h)}if(x>b){return null}if(x===b&&q>u){return null}return new On(x,q,b,u)}equalsRange(t){return On.equalsRange(this,t)}static equalsRange(t,a){if(!t&&!a){return true}return!!t&&!!a&&t.startLineNumber===a.startLineNumber&&t.startColumn===a.startColumn&&t.endLineNumber===a.endLineNumber&&t.endColumn===a.endColumn}getEndPosition(){return On.getEndPosition(this)}static getEndPosition(t){return new cs(t.endLineNumber,t.endColumn)}getStartPosition(){return On.getStartPosition(this)}static getStartPosition(t){return new cs(t.startLineNumber,t.startColumn)}toString(){return"["+this.startLineNumber+","+this.startColumn+" -> "+this.endLineNumber+","+this.endColumn+"]"}setEndPosition(t,a){return new On(this.startLineNumber,this.startColumn,t,a)}setStartPosition(t,a){return new On(t,a,this.endLineNumber,this.endColumn)}collapseToStart(){return On.collapseToStart(this)}static collapseToStart(t){return new On(t.startLineNumber,t.startColumn,t.startLineNumber,t.startColumn)}collapseToEnd(){return On.collapseToEnd(this)}static collapseToEnd(t){return new On(t.endLineNumber,t.endColumn,t.endLineNumber,t.endColumn)}delta(t){return new On(this.startLineNumber+t,this.startColumn,this.endLineNumber+t,this.endColumn)}static fromPositions(t,a=t){return new On(t.lineNumber,t.column,a.lineNumber,a.column)}static lift(t){if(!t){return null}return new On(t.startLineNumber,t.startColumn,t.endLineNumber,t.endColumn)}static isIRange(t){return t&&typeof t.startLineNumber==="number"&&typeof t.startColumn==="number"&&typeof t.endLineNumber==="number"&&typeof t.endColumn==="number"}static areIntersectingOrTouching(t,a){if(t.endLineNumber<a.startLineNumber||t.endLineNumber===a.startLineNumber&&t.endColumn<a.startColumn){return false}if(a.endLineNumber<t.startLineNumber||a.endLineNumber===t.startLineNumber&&a.endColumn<t.startColumn){return false}return true}static areIntersecting(t,a){if(t.endLineNumber<a.startLineNumber||t.endLineNumber===a.startLineNumber&&t.endColumn<=a.startColumn){return false}if(a.endLineNumber<t.startLineNumber||a.endLineNumber===t.startLineNumber&&a.endColumn<=t.startColumn){return false}return true}static compareRangesUsingStarts(t,a){if(t&&a){const b=t.startLineNumber|0;const u=a.startLineNumber|0;if(b===u){const e=t.startColumn|0;const g=a.startColumn|0;if(e===g){const n=t.endLineNumber|0;const h=a.endLineNumber|0;if(n===h){const i=t.endColumn|0;const w=a.endColumn|0;return i-w}return n-h}return e-g}return b-u}const x=t?1:0;const q=a?1:0;return x-q}static compareRangesUsingEnds(t,a){if(t.endLineNumber===a.endLineNumber){if(t.endColumn===a.endColumn){if(t.startLineNumber===a.startLineNumber){return t.startColumn-a.startColumn}return t.startLineNumber-a.startLineNumber}return t.endColumn-a.endColumn}return t.endLineNumber-a.endLineNumber}static spansMultipleLines(t){return t.endLineNumber>t.startLineNumber}toJSON(){return this}}const ic="`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";function uc(m=""){let t="(-?\\d*\\.\\d\\w*)|([^";for(const a of ic){if(m.indexOf(a)>=0){continue}t+="\\"+a}t+="\\s]+)";return new RegExp(t,"g")}const lc=uc();function qi(m){let t=lc;if(m&&m instanceof RegExp){if(!m.global){let a="g";if(m.ignoreCase){a+="i"}if(m.multiline){a+="m"}if(m.unicode){a+="u"}t=new RegExp(m.source,a)}else{t=m}}t.lastIndex=0;return t}const Hi=new al;Hi.unshift({maxLen:1e3,windowSize:15,timeBudget:150});function ji(m,t,a,x,q){t=qi(t);if(!q){q=Fo.first(Hi)}if(a.length>q.maxLen){let n=m-q.maxLen/2;if(n<0){n=0}else{x+=n}a=a.substring(n,m+q.maxLen/2);return ji(m,t,a,x,q)}const b=Date.now();const u=m-1-x;let e=-1;let g=null;for(let n=1;;n++){if(Date.now()-b>=q.timeBudget){break}const h=u-q.windowSize*n;t.lastIndex=Math.max(0,h);const i=cc(t,a,u,e);if(!i&&g){break}g=i;if(h<=0){break}e=h}if(g){const n={word:g[0],startColumn:x+1+g.index,endColumn:x+1+g.index+g[0].length};t.lastIndex=0;return n}return null}function cc(m,t,a,x){let q;while(q=m.exec(t)){const b=q.index||0;if(b<=a&&m.lastIndex>=a){return q}else if(x>0&&b>x){return null}}return null}function uo(m){if(m<0){return 0}if(m>4294967295){return 4294967295}return m|0}class dc{constructor(t){this.values=t;this.prefixSum=new Uint32Array(t.length);this.prefixSumValidIndex=new Int32Array(1);this.prefixSumValidIndex[0]=-1}getCount(){return this.values.length}insertValues(t,a){t=uo(t);const x=this.values;const q=this.prefixSum;const b=a.length;if(b===0){return false}this.values=new Uint32Array(x.length+b);this.values.set(x.subarray(0,t),0);this.values.set(x.subarray(t),t+b);this.values.set(a,t);if(t-1<this.prefixSumValidIndex[0]){this.prefixSumValidIndex[0]=t-1}this.prefixSum=new Uint32Array(this.values.length);if(this.prefixSumValidIndex[0]>=0){this.prefixSum.set(q.subarray(0,this.prefixSumValidIndex[0]+1))}return true}setValue(t,a){t=uo(t);a=uo(a);if(this.values[t]===a){return false}this.values[t]=a;if(t-1<this.prefixSumValidIndex[0]){this.prefixSumValidIndex[0]=t-1}return true}removeValues(t,a){t=uo(t);a=uo(a);const x=this.values;const q=this.prefixSum;if(t>=x.length){return false}const b=x.length-t;if(a>=b){a=b}if(a===0){return false}this.values=new Uint32Array(x.length-a);this.values.set(x.subarray(0,t),0);this.values.set(x.subarray(t+a),t);this.prefixSum=new Uint32Array(this.values.length);if(t-1<this.prefixSumValidIndex[0]){this.prefixSumValidIndex[0]=t-1}if(this.prefixSumValidIndex[0]>=0){this.prefixSum.set(q.subarray(0,this.prefixSumValidIndex[0]+1))}return true}getTotalSum(){if(this.values.length===0){return 0}return this._getPrefixSum(this.values.length-1)}getPrefixSum(t){if(t<0){return 0}t=uo(t);return this._getPrefixSum(t)}_getPrefixSum(t){if(t<=this.prefixSumValidIndex[0]){return this.prefixSum[t]}let a=this.prefixSumValidIndex[0]+1;if(a===0){this.prefixSum[0]=this.values[0];a++}if(t>=this.values.length){t=this.values.length-1}for(let x=a;x<=t;x++){this.prefixSum[x]=this.prefixSum[x-1]+this.values[x]}this.prefixSumValidIndex[0]=Math.max(this.prefixSumValidIndex[0],t);return this.prefixSum[t]}getIndexOf(t){t=Math.floor(t);this.getTotalSum();let a=0;let x=this.values.length-1;let q=0;let b=0;let u=0;while(a<=x){q=a+(x-a)/2|0;b=this.prefixSum[q];u=b-this.values[q];if(t<u){x=q-1}else if(t>=b){a=q+1}else{break}}return new hc(q,t-u)}}class hc{constructor(t,a){this.index=t;this.remainder=a;this._prefixSumIndexOfResultBrand=void 0;this.index=t;this.remainder=a}}class pc{constructor(t,a,x,q){this._uri=t;this._lines=a;this._eol=x;this._versionId=q;this._lineStarts=null;this._cachedTextValue=null}dispose(){this._lines.length=0}get version(){return this._versionId}getText(){if(this._cachedTextValue===null){this._cachedTextValue=this._lines.join(this._eol)}return this._cachedTextValue}onEvents(t){if(t.eol&&t.eol!==this._eol){this._eol=t.eol;this._lineStarts=null}const a=t.changes;for(const x of a){this._acceptDeleteRange(x.range);this._acceptInsertText(new cs(x.range.startLineNumber,x.range.startColumn),x.text)}this._versionId=t.versionId;this._cachedTextValue=null}_ensureLineStarts(){if(!this._lineStarts){const t=this._eol.length;const a=this._lines.length;const x=new Uint32Array(a);for(let q=0;q<a;q++){x[q]=this._lines[q].length+t}this._lineStarts=new dc(x)}}_setLineText(t,a){this._lines[t]=a;if(this._lineStarts){this._lineStarts.setValue(t,this._lines[t].length+this._eol.length)}}_acceptDeleteRange(t){if(t.startLineNumber===t.endLineNumber){if(t.startColumn===t.endColumn){return}this._setLineText(t.startLineNumber-1,this._lines[t.startLineNumber-1].substring(0,t.startColumn-1)+this._lines[t.startLineNumber-1].substring(t.endColumn-1));return}this._setLineText(t.startLineNumber-1,this._lines[t.startLineNumber-1].substring(0,t.startColumn-1)+this._lines[t.endLineNumber-1].substring(t.endColumn-1));this._lines.splice(t.startLineNumber,t.endLineNumber-t.startLineNumber);if(this._lineStarts){this._lineStarts.removeValues(t.startLineNumber,t.endLineNumber-t.startLineNumber)}}_acceptInsertText(t,a){if(a.length===0){return}const x=Rl(a);if(x.length===1){this._setLineText(t.lineNumber-1,this._lines[t.lineNumber-1].substring(0,t.column-1)+x[0]+this._lines[t.lineNumber-1].substring(t.column-1));return}x[x.length-1]+=this._lines[t.lineNumber-1].substring(t.column-1);this._setLineText(t.lineNumber-1,this._lines[t.lineNumber-1].substring(0,t.column-1)+x[0]);const q=new Uint32Array(x.length-1);for(let b=1;b<x.length;b++){this._lines.splice(t.lineNumber+b-1,0,x[b]);q[b-1]=x[b].length+this._eol.length}if(this._lineStarts){this._lineStarts.insertValues(t.lineNumber,q)}}}const fc="workerTextModelSync";class mc{constructor(){this._models=Object.create(null)}bindToServer(t){t.setChannel(fc,this)}getModel(t){return this._models[t]}getModels(){const t=[];Object.keys(this._models).forEach(a=>t.push(this._models[a]));return t}$acceptNewModel(t){this._models[t.url]=new gc(or.parse(t.url),t.lines,t.EOL,t.versionId)}$acceptModelChanged(t,a){if(!this._models[t]){return}const x=this._models[t];x.onEvents(a)}$acceptRemovedModel(t){if(!this._models[t]){return}delete this._models[t]}}class gc extends pc{get uri(){return this._uri}get eol(){return this._eol}getValue(){return this.getText()}findMatches(t){const a=[];for(let x=0;x<this._lines.length;x++){const q=this._lines[x];const b=this.offsetAt(new cs(x+1,1));const u=q.matchAll(t);for(const e of u){if(e.index||e.index===0){e.index=e.index+b}a.push(e)}}return a}getLinesContent(){return this._lines.slice(0)}getLineCount(){return this._lines.length}getLineContent(t){return this._lines[t-1]}getWordAtPosition(t,a){const x=ji(t.column,qi(a),this._lines[t.lineNumber-1],0);if(x){return new On(t.lineNumber,x.startColumn,t.lineNumber,x.endColumn)}return null}getWordUntilPosition(t,a){const x=this.getWordAtPosition(t,a);if(!x){return{word:"",startColumn:t.column,endColumn:t.column}}return{word:this._lines[t.lineNumber-1].substring(x.startColumn-1,t.column-1),startColumn:x.startColumn,endColumn:t.column}}words(t){const a=this._lines;const x=this._wordenize.bind(this);let q=0;let b="";let u=0;let e=[];return{*[Symbol.iterator](){while(true){if(u<e.length){const g=b.substring(e[u].start,e[u].end);u+=1;yield g}else{if(q<a.length){b=a[q];e=x(b,t);u=0;q+=1}else{break}}}}}}getLineWords(t,a){const x=this._lines[t-1];const q=this._wordenize(x,a);const b=[];for(const u of q){b.push({word:x.substring(u.start,u.end),startColumn:u.start+1,endColumn:u.end+1})}return b}_wordenize(t,a){const x=[];let q;a.lastIndex=0;while(q=a.exec(t)){if(q[0].length===0){break}x.push({start:q.index,end:q.index+q[0].length})}return x}getValueInRange(t){t=this._validateRange(t);if(t.startLineNumber===t.endLineNumber){return this._lines[t.startLineNumber-1].substring(t.startColumn-1,t.endColumn-1)}const a=this._eol;const x=t.startLineNumber-1;const q=t.endLineNumber-1;const b=[];b.push(this._lines[x].substring(t.startColumn-1));for(let u=x+1;u<q;u++){b.push(this._lines[u])}b.push(this._lines[q].substring(0,t.endColumn-1));return b.join(a)}offsetAt(t){t=this._validatePosition(t);this._ensureLineStarts();return this._lineStarts.getPrefixSum(t.lineNumber-2)+(t.column-1)}positionAt(t){t=Math.floor(t);t=Math.max(0,t);this._ensureLineStarts();const a=this._lineStarts.getIndexOf(t);const x=this._lines[a.index].length;return{lineNumber:1+a.index,column:1+Math.min(a.remainder,x)}}_validateRange(t){const a=this._validatePosition({lineNumber:t.startLineNumber,column:t.startColumn});const x=this._validatePosition({lineNumber:t.endLineNumber,column:t.endColumn});if(a.lineNumber!==t.startLineNumber||a.column!==t.startColumn||x.lineNumber!==t.endLineNumber||x.column!==t.endColumn){return{startLineNumber:a.lineNumber,startColumn:a.column,endLineNumber:x.lineNumber,endColumn:x.column}}return t}_validatePosition(t){if(!cs.isIPosition(t)){throw new Error("bad position")}let{lineNumber:a,column:x}=t;let q=false;if(a<1){a=1;x=1;q=true}else if(a>this._lines.length){a=this._lines.length;x=this._lines[a-1].length+1;q=true}else{const b=this._lines[a-1].length+1;if(x<1){x=1;q=true}else if(x>b){x=b;q=true}}if(!q){return t}else{return{lineNumber:a,column:x}}}}function yc(m){return new ra(m)}class ra{static{this.expectedRelativeConfidence=.2}static{this.positiveConfidenceCorrectionBucket1=.05}static{this.positiveConfidenceCorrectionBucket2=.025}static{this.negativeConfidenceCorrection=.5}constructor(t){this._workerTextModelSyncServer=new mc;this._loadFailed=false;this.modelIdToCoreId=new Map;this._host=Do.getChannel(t);this._workerTextModelSyncServer.bindToServer(t)}async $detectLanguage(t,a,x,q){const b=[];const u=[];const e=new Vo;const g=this.getTextForDetection(t);if(!g){return}const n=async()=>{for await(const i of this.detectLanguagesImpl(g)){if(!this.modelIdToCoreId.has(i.languageId)){this.modelIdToCoreId.set(i.languageId,await this._host.$getLanguageId(i.languageId))}const w=this.modelIdToCoreId.get(i.languageId);if(w&&(!q?.length||q.includes(w))){b.push(w);u.push(i.confidence)}}e.stop();if(b.length){this._host.$sendTelemetryEvent(b,u,e.elapsed());return b[0]}return void 0};const h=await n();if(h){return h}return void 0}getTextForDetection(t){const a=this._workerTextModelSyncServer.getModel(t);if(!a){return}const x=a.positionAt(1e4);const q=a.getValueInRange({startColumn:1,startLineNumber:1,endColumn:x.column,endLineNumber:x.lineNumber});return q}async getModelOperations(){if(this._modelOperations){return this._modelOperations}this._modelOperations=new Wu.ModelOperations({modelJsonLoaderFunc:async()=>{const t=await fetch(await this._host.$getModelJsonUri());try{const a=await t.json();return a}catch(a){const x=`Failed to parse model JSON.`;throw new Error(x)}},weightsLoaderFunc:async()=>{const t=await fetch(await this._host.$getWeightsUri());const a=await t.arrayBuffer();return a}});return this._modelOperations}adjustLanguageConfidence(t){switch(t.languageId){case"js":case"html":case"json":case"ts":case"css":case"py":case"xml":case"php":t.confidence+=ra.positiveConfidenceCorrectionBucket1;break;case"cpp":case"sh":case"java":case"cs":case"c":t.confidence+=ra.positiveConfidenceCorrectionBucket2;break;case"bat":case"ini":case"makefile":case"sql":case"csv":case"toml":t.confidence-=ra.negativeConfidenceCorrection;break}return t}async*detectLanguagesImpl(t){if(this._loadFailed){return}let a;try{a=await this.getModelOperations()}catch(u){console.log(u);this._loadFailed=true;return}let x;try{x=await a.runModel(t)}catch(u){console.warn(u)}if(!x||x.length===0||x[0].confidence<ra.expectedRelativeConfidence){return}const q=this.adjustLanguageConfidence(x[0]);if(q.confidence<ra.expectedRelativeConfidence){return}const b=[q];for(let u of x){if(u===q){continue}u=this.adjustLanguageConfidence(u);const e=b[b.length-1];if(e.confidence-u.confidence>=ra.expectedRelativeConfidence){while(b.length){yield b.shift()}if(u.confidence>ra.expectedRelativeConfidence){b.push(u);continue}return}else{if(u.confidence>ra.expectedRelativeConfidence){b.push(u);continue}return}}}}const Ko="default";const bc="$initialize";class kc{constructor(t,a,x,q,b){this.vsWorker=t;this.req=a;this.channel=x;this.method=q;this.args=b;this.type=0}}class Ei{constructor(t,a,x,q){this.vsWorker=t;this.seq=a;this.res=x;this.err=q;this.type=1}}class wc{constructor(t,a,x,q,b){this.vsWorker=t;this.req=a;this.channel=x;this.eventName=q;this.arg=b;this.type=2}}class vc{constructor(t,a,x){this.vsWorker=t;this.req=a;this.event=x;this.type=3}}class Nc{constructor(t,a){this.vsWorker=t;this.req=a;this.type=4}}class xc{constructor(t){this._workerId=-1;this._handler=t;this._lastSentReq=0;this._pendingReplies=Object.create(null);this._pendingEmitters=new Map;this._pendingEvents=new Map}setWorkerId(t){this._workerId=t}sendMessage(t,a,x){const q=String(++this._lastSentReq);return new Promise((b,u)=>{this._pendingReplies[q]={resolve:b,reject:u};this._send(new kc(this._workerId,q,t,a,x))})}listen(t,a,x){let q=null;const b=new sa({onWillAddFirstListener:()=>{q=String(++this._lastSentReq);this._pendingEmitters.set(q,b);this._send(new wc(this._workerId,q,t,a,x))},onDidRemoveLastListener:()=>{this._pendingEmitters.delete(q);this._send(new Nc(this._workerId,q));q=null}});return b.event}handleMessage(t){if(!t||!t.vsWorker){return}if(this._workerId!==-1&&t.vsWorker!==this._workerId){return}this._handleMessage(t)}createProxyToRemoteChannel(t,a){const x={get:(q,b)=>{if(typeof b==="string"&&!q[b]){if(Ki(b)){q[b]=u=>{return this.listen(t,b,u)}}else if(Gi(b)){q[b]=this.listen(t,b,void 0)}else if(b.charCodeAt(0)===36){q[b]=async(...u)=>{await a?.();return this.sendMessage(t,b,u)}}}return q[b]}};return new Proxy(Object.create(null),x)}_handleMessage(t){switch(t.type){case 1:return this._handleReplyMessage(t);case 0:return this._handleRequestMessage(t);case 2:return this._handleSubscribeEventMessage(t);case 3:return this._handleEventMessage(t);case 4:return this._handleUnsubscribeEventMessage(t)}}_handleReplyMessage(t){if(!this._pendingReplies[t.seq]){console.warn("Got reply to unknown seq");return}const a=this._pendingReplies[t.seq];delete this._pendingReplies[t.seq];if(t.err){let x=t.err;if(t.err.$isError){x=new Error;x.name=t.err.name;x.message=t.err.message;x.stack=t.err.stack}a.reject(x);return}a.resolve(t.res)}_handleRequestMessage(t){const a=t.req;const x=this._handler.handleMessage(t.channel,t.method,t.args);x.then(q=>{this._send(new Ei(this._workerId,a,q,void 0))},q=>{if(q.detail instanceof Error){q.detail=ci(q.detail)}this._send(new Ei(this._workerId,a,void 0,ci(q)))})}_handleSubscribeEventMessage(t){const a=t.req;const x=this._handler.handleEvent(t.channel,t.eventName,t.arg)(q=>{this._send(new vc(this._workerId,a,q))});this._pendingEvents.set(a,x)}_handleEventMessage(t){if(!this._pendingEmitters.has(t.req)){console.warn("Got event for unknown req");return}this._pendingEmitters.get(t.req).fire(t.event)}_handleUnsubscribeEventMessage(t){if(!this._pendingEvents.has(t.req)){console.warn("Got unsubscribe for unknown req");return}this._pendingEvents.get(t.req).dispose();this._pendingEvents.delete(t.req)}_send(t){const a=[];if(t.type===0){for(let x=0;x<t.args.length;x++){if(t.args[x]instanceof ArrayBuffer){a.push(t.args[x])}}}else if(t.type===1){if(t.res instanceof ArrayBuffer){a.push(t.res)}}this._handler.sendMessage(t,a)}}function Gi(m){return m[0]==="o"&&m[1]==="n"&&Ri(m.charCodeAt(2))}function Ki(m){return/^onDynamic/.test(m)&&Ri(m.charCodeAt(9))}class _c{constructor(t,a){this._localChannels=new Map;this._remoteChannels=new Map;this._requestHandlerFactory=a;this._requestHandler=null;this._protocol=new xc({sendMessage:(x,q)=>{t(x,q)},handleMessage:(x,q,b)=>this._handleMessage(x,q,b),handleEvent:(x,q,b)=>this._handleEvent(x,q,b)})}onmessage(t){this._protocol.handleMessage(t)}_handleMessage(t,a,x){if(t===Ko&&a===bc){return this.initialize(x[0],x[1],x[2])}const q=t===Ko?this._requestHandler:this._localChannels.get(t);if(!q){return Promise.reject(new Error(`Missing channel ${t} on worker thread`))}if(typeof q[a]!=="function"){return Promise.reject(new Error(`Missing method ${a} on worker thread channel ${t}`))}try{return Promise.resolve(q[a].apply(q,x))}catch(b){return Promise.reject(b)}}_handleEvent(t,a,x){const q=t===Ko?this._requestHandler:this._localChannels.get(t);if(!q){throw new Error(`Missing channel ${t} on worker thread`)}if(Ki(a)){const b=q[a].call(q,x);if(typeof b!=="function"){throw new Error(`Missing dynamic event ${a} on request handler.`)}return b}if(Gi(a)){const b=q[a];if(typeof b!=="function"){throw new Error(`Missing event ${a} on request handler.`)}return b}throw new Error(`Malformed event name ${a}`)}setChannel(t,a){this._localChannels.set(t,a)}getChannel(t){if(!this._remoteChannels.has(t)){const a=this._protocol.createProxyToRemoteChannel(t);this._remoteChannels.set(t,a)}return this._remoteChannels.get(t)}async initialize(t,a,x){this._protocol.setWorkerId(t);if(this._requestHandlerFactory){this._requestHandler=this._requestHandlerFactory(this);return}if(a){if(typeof a.baseUrl!=="undefined"){delete a["baseUrl"]}if(typeof a.paths!=="undefined"){if(typeof a.paths.vs!=="undefined"){delete a.paths["vs"]}}if(typeof a.trustedTypesPolicy!=="undefined"){delete a["trustedTypesPolicy"]}a.catchError=true;globalThis.require.config(a)}return Promise.reject(new Error(`Unexpected usage`))}}let ni=false;function Sc(m){if(ni){return}ni=true;const t=new _c(a=>globalThis.postMessage(a),a=>m(a));globalThis.onmessage=a=>{t.onmessage(a.data)}}function Tc(m){globalThis.onmessage=t=>{if(!ni){Sc(m)}}}Tc(yc);
